SendMode Input
FileEncoding, UTF-8

; Функция для получения пути к данным приложения
GetAppDataDir() {
    appDataPath := A_AppData . "\@ocludes"
    if (!FileExist(appDataPath))
        FileCreateDir, %appDataPath%
    return appDataPath
}

; Инициализация глобальных путей
global appDataDir := GetAppDataDir()
SetWorkingDir %appDataDir%

global isTyping := false
global presetDir := appDataDir . "\presets"
global templatesDir := appDataDir . "\templates"
global slotsTemplatesDir := appDataDir . "\slots_templates"
global categoriesFile := appDataDir . "\presets\categories.ini"
global currentCategory := ""
global currentSubcategory := ""
global navigationLevel := "categories"  ; categories, subcategories, presets
global selectedPreset := ""  ; Для диалога перемещения
global currentTemplateNotes := ""  ; Заметки для текущего шаблона
global treeItemData := {}  ; Хранилище данных для элементов TreeView {itemID: {name, path, notesPath}}

; Создаём необходимые папки если не существуют
if (!FileExist(presetDir))
    FileCreateDir, %presetDir%
if (!FileExist(templatesDir))
    FileCreateDir, %templatesDir%
if (!FileExist(slotsTemplatesDir))
    FileCreateDir, %slotsTemplatesDir%
if (!FileExist(appDataDir . "\records"))
    FileCreateDir, % appDataDir . "\records"
if (!FileExist(appDataDir . "\letter_presets"))
    FileCreateDir, % appDataDir . "\letter_presets"

; Папка пресетов System Prompt для нейросети
NeuroSystemPresetsDir := appDataDir . "\neuro_system_presets"
if (!FileExist(NeuroSystemPresetsDir))
    FileCreateDir, %NeuroSystemPresetsDir%

global repeatCount := 0
global previousMessages := []
global lastGeneratedText := ""
global GenerationMethod := "Corpus"
global ModelVariant := "Default"
global MaxSentenceWords := 100
global UseCorpus := 1
global ShuffleCorpus := 0
global GeneratedCount := 0
global ModelCapitalize := 1
global ModelPunctuation := 1
global ModelCommas := 1
global ErrorLevelSetting := "Нет"
; ErrorShuffleLevel removed — shuffler is independent from error generator
global TextShuffleLevel := "Отключено"
global SpeedMultiplier := 1  ; Ускорение печати (1x-10000x)
global SpeedSendEngine := "SendInput" ; SendInput|SendEvent|SendPlay (для посимвольной печати)
global SpeedClipboardEngine := "SendInput" ; SendInput|SendEvent|SendPlay (для Ctrl+V)
global speedCfg := {}       ; Speed engine params (150+)
global speedCfgDefs := []   ; Definitions for UI
global ShuffleRandomMode := 0
global ShuffleLowProb := 30
global ShuffleMediumBehavior := 1
global ShuffleHighSuffixProb := 30
global ShuffleHighSuffixCount := 1
global ShuffleExtremeMode := 1
global TextCase := "Normal"
global CreativityLevel := 50
global ContextWindow := 10
; === НЕЙРОСЕТЬ (OpenRouter) ===
global NeuroTabIndex := 22
global NeuroModel := "arcee-ai/trinity-large-preview:free"
; Важно: ключ лучше хранить в INI, но по запросу пользователя даем дефолт прямо в скрипте.
global NeuroOpenRouterKeyDefault := "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"
; Фиксируем ключ и модель: UI не позволяет менять.
global NeuroApiKey := NeuroOpenRouterKeyDefault
global NeuroSystemPresetsDir := ""  ; будет инициализирован после appDataDir
global NeuroSelectedPresetText := ""
global NeuroSelectedPresetPath := ""
global NeuroLastResponse := ""
global neuroTreeItemData := {}  ; TreeView itemID -> {name, path}
global neuroSystemPromptAutosaveMs := 600
; multi-window feature removed (user requested) — targetWindows disabled
global isRecording := false
global recordedText := ""
global recordStartTime := 0
global isPlaying := false
global playbackSpeed := 1
global playbackRepeats := 1
global playbackMaxWords := 0
global playbackRandomize := false
global playbackErrorLevel := "Нет"
global slots := []  ; Массив слотов: каждый слот = {text: "", delay: 0, delayUnit: "Секунды", speed: 10}
global slotsRepeatCount := 1  ; Количество повторов для режима "По слотам"
global slotsErrorLevel := "Нет"  ; Уровень ошибок для слотов
global slotsCapitalizeFirst := 0  ; Первая буква всегда заглавная для слотов
global slotsPrintTranslit := "Выключено"  ; Печать транслитом для слотов
global slotsStartPosition := "С начала"  ; Откуда начать печатать слоты
global quickDelayRowIndex := 0  ; Индекс строки для быстрого редактирования задержки
global bulkSelectedRows := []  ; Массив выделенных строк для массового редактирования
global clipboardDelayValue := 0  ; Задержка перед вставкой через буфер обмена (значение)
global clipboardDelayUnit := "мс"  ; Единица измерения задержки (мс/сек/мин)
global mainDelayMode := "Отсутствует"
global mainDelayValue := 0
global mainDelayMin := 0
global mainDelayMax := 0
global playbackDelayMode := "Отсутствует"
global playbackDelayValue := 0
global playbackDelayMin := 0
global playbackDelayMax := 0
global noRepeatText := 0
global startPosition := "С начала"
global StartLineNumber := 1
global usedLines := []
global customInserts := []  ; Массив пользовательских вставок
global insertCount := 0      ; Количество вставок
global insertRules := []     ; Массив правил вставки слов
global insertRepeatCount := 1  ; Количество N-раз повторения вставки в строке
global AutoEnterInsertPerChunk := 0 ; Если 1 — применять позицию вставки для каждого фрагмента Auto-Enter
global hotkeyMap := {} ; mapping hotkey string -> insert index
global ignoredWords := []  ; Массив игнорируемых слов для генератора
global customWords := []  ; Массив собственных слов для генератора (расширенный формат)
global actionBinds := []  ; Массив биндов на действия {hotkey, action, parameter, enabled}
global errorWordVariations := {}  ; Словарь: слово -> массив вариаций для ошибок
global smartErrorMode := false  ; Умный режим генерации вариаций
global smartErrorMode := true  ; Умный режим генерации ошибок
global errorWordCount := 5  ; Количество слов с ошибками
global errorPosition := "Каждое N-слово"  ; Позиция ошибок
global errorFrequency := 3  ; Частота ошибок (каждое N-слово)
global errorChance := 50  ; Шанс на ошибку (%)
global errorType := "Обычный"  ; Тип ошибок
global errorCount := 2  ; Количество ошибок (для перемешивания)
global randomCharsCount := 1  ; Количество случайных букв/символов
global randomCharsInComplexWords := false  ; В сложных словах добавлять случайные буквы
global randomCharsPerWord := 1  ; N-количество случайных букв на слово
global errorCapitalize := true  ; Сохранять заглавные буквы
global errorPreserveLength := false  ; Сохранять длину слова
global errorSmartMode := true  ; Умный режим (учитывать контекст)

; === РАСШИРЕННЫЕ ТИПЫ ОШИБОК ===
global advErrorSwapNeighbors := false  ; Перестановка соседних букв
global advErrorAddRandom := false  ; Добавление случайного символа
global advErrorDeleteRandom := false  ; Удаление случайного символа
global advErrorMoveCharBetweenWords := false  ; Перенос символа между словами
global advErrorDeleteSpace := false  ; Удаление пробела между словами
global advErrorMoveCharInWord := false  ; Перенос буквы внутри слова
global advErrorMoveCharToStart := false  ; Перенос буквы в начало слова
global advErrorSequenceError := false  ; Ошибка последовательности нажатий
global advErrorMoveCharToPrevWord := false  ; Перенос буквы внутрь предыдущего слова
global advErrorInsertSpaceInWord := false  ; Вставка пробела внутри слова
global advErrorInsertSpecialChars := false  ; Вставка символа "=" или цифр
global advErrorExtendedSettings := false  ; Расширенные настройки ошибок
global advErrorCustomSplit := false  ; Кастомное разбиение строк
global advErrorCombinedErrors := false  ; Комбинированные ошибки в словах
global advErrorShuffleWords := false  ; Перемешивать слова
global advErrorShuffleLines := false  ; Перемешивать строки
global advErrorRandomPhraseOrder := false  ; Случайный порядок фраз
global advErrorJoinPhrases := false  ; Соединять фразы в одну строку

; === ВИЗУАЛЬНЫЙ РЕДАКТОР ПРАВИЛ ОШИБОК ===
global errorRules := []  ; Массив правил ошибок {name, enabled, type, conditions, actions, probability}
global errorRulesPresetsDir := appDataDir . "\error_rules"  ; Папка для пресетов правил

global GenCustomLines := 5  ; Количество строк для построчной генерации
global GenCustomWordsPerLine := 10  ; Количество слов на строку для построчной генерации
global GenByWords := 1  ; Режим генерации по словам (1) или по строкам (0)
global GenByLines := 0  ; Режим генерации по строкам (противоположность GenByWords)
global GenCountValue := 5  ; Количество слов/строк для генерации
global PrintLimitType := 1  ; 1 = без ограничений, 2 = по словам, 3 = по строкам, 4 = по времени
global PrintWordLimit := 150  ; Количество слов для печати
global PrintLineLimit := 5  ; Количество строк для печати
global PrintTimeLimit := 1  ; Количество времени для печати (число)
global PrintTimeUnit := "Секунда"  ; Миллисекунда|Секунда|Минута

; Циклы ограничения печати (по циклам DoAutoType)
global PrintLimitCyclesEnabled := 0
global printLimitCycles := []  ; [{type:"words"|"lines"|"time", value:n, unit:"Миллисекунда"|"Секунда"|"Минута"}]

; Лимит времени: применяется при SendTextWithSpecialTags (обрезает ввод по дедлайну)
global printTimeDeadline := 0
global printTimeLimitHit := false

; Настройки "случайного выбора строки" (веса/шансы)
global RandomLineBiasEnabled := 0
global RandomLineChanceTop := 25
global RandomLineChanceMiddle := 25
global RandomLineChanceBottom := 25
global RandomLineChanceRandom := 25

; === Справка/информация ===
global OpenTelegramOnStart := 1
global TelegramChannelUrl := "https://t.me/magnitical"
global telegramOpenedThisRun := 0

; === Бинды управления скриптом (старт/стоп/пауза/экстренная остановка) ===
global ControlStartHotkey := "F8"
global ControlStopHotkey := "F9"
global ControlPauseHotkey := "F10"
global ControlEmergencyHotkey := "F12"
global controlHotkeysPrev := {}  ; internal: previous registered hotkeys
global selectedInsertIndex := 0  ; Индекс выбранной вставки для управления
global contextMenuActions := []  ; Массив пользовательских действий для контекстного меню {name, action, parameter, enabled}
global letterReplacements := {}  ; Объект для хранения замен букв (исходная буква -> замена)
global letterReplacementsEnabled := true  ; Включение/выключение функции замены букв
global letterReplacementsPresetsDir := appDataDir . "\letter_presets"  ; Папка для пресетов замены букв
global restrictedLetters := {}  ; Объект для хранения ограниченных букв (буква -> 1 если ограничена)

; === СЛОВАРЬ (локальный, внутри AutoTyper) ===
global dictDir := appDataDir . "\dictionary"
if (!FileExist(dictDir))
    FileCreateDir, %dictDir%
global dictEnabled := true
global dictCaptureOnStart := true
global dictCaptureTypeTextEdits := true  ; Логировать изменения TypeText (внутри AutoTyper)
global dictTypeTextDebounceMs := 800  ; Фиксировать ввод после паузы
global dictTypeTextMinChars := 1  ; Минимальная длина, чтобы писать снимок
global dictCaptureSentMessages := true
global dictCaptureGenerator := true
global dictStoreEvents := true
global dictStoreWords := true
global dictStoreLines := true
global dictStoreJsonl := true  ; Под датасет: события в JSONL
global dictJsonlMaxMB := 50  ; Ротация events.jsonl при превышении (0 = без лимита)
global dictClipboardSplitLines := true
global dictImportMaxLines := 100000
global dictImportSplitLines := true
global dictNormalizeLower := true
global dictStripPunct := true
global dictCollapseSpaces := true
global dictIgnoreNumbers := false
global dictMinWordLen := 2
global dictMaxWordLen := 30
global dictMaxEventsPerDay := 5000
global dictNoRepeatEvents := false
global dictAutosaveEnabled := true
global dictAutosaveIntervalSec := 10
global dictTopWordsLimit := 500
global dictStopWordsText := ""
global dictStripUrls := true
global dictStripEmails := true
global dictStripMentions := false
global dictStripHashtags := false
global dictStripEmojis := false
global dictKeepCyrillicOnly := false
global dictKeepLatinOnly := false
global dictMaxCharsPerEvent := 2000
global dictAppendSourceTag := true
global dictAppendTimestamp := true
global dictAppendNewline := true
global dictCollectTopLines := true
global dictTopLinesLimit := 200
global dictTopWordsOnlyLetters := false
global dictEnableBigrams := false
global dictEnableTrigrams := false
global dictBigramsFreq := {}
global dictTrigramsFreq := {}
global dictCustomDictionaries := [] ; {name, pathTxt, pathJson}
global dictDayEvents := [] ; [{ts,source,text}]
global dictWordFreq := {}  ; word -> count
global dictLineFreq := {}  ; line -> count
global dictTreeData := {}  ; TreeView itemID -> file path
global dictTypeTextPending := ""
global dictTypeTextLastSnapshot := ""

; === НОВЫЕ ПЕРЕМЕННЫЕ ГЕНЕРАТОРА ===
global genTemplatesDir := appDataDir . "\gen_templates"  ; Папка для шаблонов генератора
global genCategoriesFile := appDataDir . "\gen_templates\gen_categories.ini"  ; Файл категорий генератора
global genCurrentCategory := ""  ; Текущая категория генератора
global genCurrentSubcategory := ""  ; Текущая подкатегория генератора
global genNavigationLevel := "categories"  ; Уровень навигации: categories, subcategories, templates
global genCurrentTemplate := ""  ; Текущий выбранный шаблон
global genContentVisible := false  ; Видимость содержимого шаблона
global genGenerationMode := "single"  ; Режим генерации: infinite, lines, random, single
global genEffect := "normal"  ; Эффект: normal, explosive, wavy
global genErrorLevel := "Нет"  ; Уровень ошибок генерации
global genUsedWords := []  ; Использованные слова (для режима без повторов)

; === LEGIT-РЕЖИМ ПЕРЕМЕННЫЕ ===
global legitModeEnabled := false  ; Включен ли Legit-режим
global legitWPM := 80  ; Скорость в словах в минуту (10-5000)
global legitWPMMultiplier := 1.0  ; Множитель скорости WPM (1.0x - 3.0x)
global legitSpeedVariation := 15  ; Вариация скорости в процентах
global legitWordPause := 50  ; Дополнительная пауза между словами (мс)
global legitThinkingEnabled := false  ; Включены ли паузы раздумья
global legitThinkingFreq := 15  ; Частота пауз раздумья (1 из N слов)
global legitThinkingMin := 200  ; Минимальная длительность паузы раздумья
global legitThinkingMax := 800  ; Максимальная длительность паузы раздумья
global legitTyposEnabled := false  ; Включены ли опечатки
global legitTypoFreq := 3  ; Частота опечаток в процентах
global legitAutoCorrect := true  ; Автоисправление опечаток
global legitRhythm := "Равномерный"  ; Стиль ритма печати
global legitCharDifficulty := false  ; Учитывать сложность символов
global legitBurstMode := false  ; Burst-режим для коротких слов
global legitFatigue := false  ; Усталость (замедление со временем)
global legitCapsDelay := false  ; Задержка на заглавных буквах
global legitPunctDelay := false  ; Задержка на пунктуации
global legitCharIndex := 0  ; Индекс текущего символа для усталости

; === BURST-РЕЖИМ ПЕРЕМЕННЫЕ ===
global burstWords := []  ; Массив слов для Burst-режима {word, style, customWPM}
global burstDefaultStyle := "Резкий"  ; Стиль по умолчанию

; === ОСТАНОВКИ ПЕЧАТИ ===
global legitPauseEnabled := false
global legitPauseDuration := 500
global legitPauseUnit := "мс"
global legitPauseCount := 3
global legitPauseInterval := 50

; === РАСШИРЕННЫЕ НАСТРОЙКИ ===
global legitWordPauseEnabled := false
global legitWordPauseRandom := false
global legitWordPauseMin := 30
global legitWordPauseMax := 100
global legitThinkingChance := 100
global legitRhythmIntensity := 30
global legitMinDelay := 0
global legitMaxDelay := 0

; === RAGE-РЕЖИМ ПЕРЕМЕННЫЕ ===
global rageModeEnabled := false
global rageSpeed := 9999  ; Максимальная скорость
global rageNoDelay := true  ; Без задержек
global rageInstantPaste := true  ; Мгновенная вставка
global rageBypassDetection := false  ; Обход детекции
global rageRandomizeOrder := false  ; Случайный порядок
global rageSpamMode := false  ; Режим спама
global rageSpamCount := 10  ; Количество повторов спама
global rageExploits := []  ; Массив эксплоитов

; === ПЕРЕМЕННЫЕ ГЕНЕРАЦИИ RAGE ===
global rageGenLines := 5  ; Количество строк для генерации
global rageGenWordsPerLine := 10  ; Количество слов в строке
global rageGenInstantSend := false  ; Мгновенная отправка каждой строки
global rageGenRandomWords := false  ; Случайные слова из словаря
global rageGenAutoEnter := false  ; Auto-Enter после строки
global rageGenNoRepeat := false  ; Не повторять слова
global rageDispatchEnabled := false  ; Включить массовую отправку сообщений в Burst
global rageDispatchMessageCount := 100  ; Сколько сообщений отправить
global rageDispatchTimeValue := 1  ; За какое время отправить
global rageDispatchTimeUnit := "Секунды"  ; Единица времени для массовой отправки
global rageBurstSentCounter := 0  ; Счетчик отправленных Burst-сообщений за текущий запуск
global RageAdvEnablePacketSize := 0
global RageAdvBurstPacketSize := 1000
global RageAdvEnablePacketDelay := 0
global RageAdvBurstPacketDelay := 0
global RageAdvEnableThreads := 0
global RageAdvBurstThreads := 1
global RageAdvBurstStrategy1 := 1
global RageAdvBurstStrategy2 := 0
global RageAdvBurstStrategy3 := 0
global RageAdvBurstStrategy4 := 0
global RageBurstOptJitter := 0
global RageBurstJitterMin := 0
global RageBurstJitterMax := 15
global RageBurstOptRetry := 0
global RageBurstRetryCount := 2
global RageBurstRetryDelay := 5
global RageBurstOptCooldown := 0
global RageBurstCooldownEvery := 25
global RageBurstCooldownMs := 150
global RageBurstOptWarmup := 0
global RageBurstWarmupCount := 15
global RageBurstWarmupStartMs := 30
global RageBurstOptDedupe := 0
global RageBurstDedupeAttempts := 3
global RageBurstOptRandomCase := 0
global RageBurstRandomCaseChance := 20
global RageBurstOptRandomPunct := 0
global RageBurstRandomPunctChance := 20
global RageBurstOptAdaptiveRate := 0
global RageBurstRateLimit := 30
global RageBurstOptPrefixCounter := 0
global RageBurstCounterFormat := "[#n]"
global RageBurstOptStats := 0
global RageBurstStatsInterval := 10
global RageBurstOptAutoRebuild := 1
global RageBurstOptPacketPause := 0
global RageBurstPacketSize2 := 100
global RageBurstPacketPauseMs := 40
global RageBurstOptForceInstant := 1
global RageBurstForceThresholdMs := 5
global RageBurstOptStrictUnique := 0
global RageBurstUniqueAttempts := 4
global RageBurstUniqueSuffix := 0
global rageCustomExploits := []
global rageCustomOverrides := []
global stealthModeEnabled := 0
global stealthLastSentText := ""
global stealthLastCanonical := ""
global stealthMessageCounter := 0
global stealthLongConfirmGiven := false
global stealthBlockReason := ""
global stealthRecentCanonicals := []
global stealthRecentSet := {}
global SmallCapsEnabled := 0

; === ПЕРЕМЕННЫЕ ДЛЯ ВСТАВКИ БУКВ ВНУТРИ СЛОВ ===
global letterInserts := []  ; Массив вставок букв {word, letter, position, enabled}

; === ПЕРЕМЕННЫЕ ДЛЯ РЕГИСТРА СЛОВ ===
global caseWords := []  ; Массив слов с определённым регистром {word, case, frequency, currentCount}

; === ПЕРЕМЕННЫЕ ДЛЯ СЛУЧАЙНЫХ ПРОБЕЛОВ ===
global randomSpacesEnabled := false
global randomSpacesFrequency := 10  ; Частота (1 из N слов)
global randomSpacesType := "Двойной"  ; Двойной, Тройной, Случайный

; === ПЕРЕМЕННЫЕ ДЛЯ DOUBLE/TRIPLE БУКВ ===
global doubleLettersEnabled := false
global doubleLettersFrequency := 5  ; Частота (1 из N букв)
global doubleLettersType := "Double"  ; Double, Triple, Случайный
global doubleLettersChars := "аеиоуыэюя"  ; Какие буквы дублировать

; === ПЕРЕМЕННЫЕ ДЛЯ ПЕРЕВОДЧИКА ===
global translatorEnabled := false
global translatorSourceLang := "ru"
global translatorTargetLang := "en"

; === ПЕРЕМЕННЫЕ ДЛЯ АВТО-КОРРЕКЦИИ ===
global autoCorrectEnabled := false
global autoCorrectDictionary := {}  ; Словарь исправлений

; === ПЕРЕМЕННЫЕ ДЛЯ ПАУЗ МЕЖДУ СООБЩЕНИЯМИ ===
global messagePauseEnabled := false
global messagePauseMin := 500
global messagePauseMax := 2000
global messagePauseUnit := "мс"

; === ПЕРЕМЕННЫЕ ДЛЯ ЗАДЕРЖКИ МЕЖДУ БУКВАМИ ===
global charDelayEnabled := false
global charDelayMin := 10
global charDelayMax := 50

; === ПЕРЕМЕННЫЕ ДЛЯ BURST-СЛОВ (СКОРОСТЬ) ===
global speedBurstWords := []  ; Массив слов для мгновенного ввода

; === ПЕРЕМЕННЫЕ ДЛЯ НАСТРОЕК СКОРОСТИ ===
global arrhythmiaEnabled := false
global arrhythmiaIntensity := 30
global smoothnessEnabled := false
global smoothnessLevel := 50
global accuracyLevel := 95
global errorPercent := 5
global speedVariationEnabled := false
global speedVariationMin := 80
global speedVariationMax := 120
global consistencyLevel := 80

; === ПЕРЕМЕННЫЕ ДЛЯ ПРЕСЕТОВ НАСТРОЕК ===
global settingsPresetsDir := appDataDir . "\settings_presets"
global currentSettingsPreset := ""

; === ПЕРЕМЕННЫЕ ДЛЯ ПЕЧАТИ ПО БИНДАМ ===
global bindTemplates := []  ; Массив шаблонов {hotkey, text, speedType, speedValue, textCase, errorLevel, enabled}
global bindPresetsDir := appDataDir . "\bind_presets"  ; Папка для пресетов биндов
global bindVariationsDir := appDataDir . "\bind_variations"  ; Папка для вариаций шаблонов
global bindWordInserts := []  ; Вставки слов для биндов {word, position, enabled}
global bindLetterInserts := []  ; Вставки букв для биндов {letter, position, frequency, enabled}
global bindRepeats := []  ; Повторы для биндов {count, delay, enabled}
global isCapturingHotkey := false  ; Флаг захвата клавиш
global capturedHotkey := ""  ; Захваченная комбинация клавиш
global captureTargetControl := ""  ; Целевой контрол для захвата

; === ПЕРЕМЕННЫЕ ДЛЯ AUTO-ENTER ЦИКЛОВ ===
global autoEnterCycles := []  ; Массив циклов Auto-Enter {words, enabled}
global autoEnterBinds := []  ; Массив биндов для Auto-Enter {hotkey, action, enabled}
global autoEnterCurrentCycle := 1  ; Текущий цикл

; === ПЕРЕМЕННЫЕ ДЛЯ ЗАПИСИ ВВОДА ПОЛЬЗОВАТЕЛЯ ===
global recordingKeyTimes := []  ; Массив времён нажатий {char, delay, timestamp}
global recordingStartTime := 0  ; Время начала записи
global recordingLastKeyTime := 0  ; Время последнего нажатия
global recordingPauses := []  ; Массив пауз между нажатиями
global recordingFullData := {}  ; Полные данные записи {text, keyTimes, pauses, totalTime}

; Создаём папки для новых функций
if (!FileExist(settingsPresetsDir))
    FileCreateDir, %settingsPresetsDir%
if (!FileExist(bindPresetsDir))
    FileCreateDir, %bindPresetsDir%
if (!FileExist(bindVariationsDir))
    FileCreateDir, %bindVariationsDir%
if (!FileExist(errorRulesPresetsDir))
    FileCreateDir, %errorRulesPresetsDir%

; Создаём папку для пресетов правил вставки
global insertRulesPresetsDir := appDataDir . "\insert_rules_presets"
if (!FileExist(insertRulesPresetsDir))
    FileCreateDir, %insertRulesPresetsDir%

; Создаём дефолтные пресеты правил вставки
Gosub, CreateDefaultInsertRulesPresets

; Создаём папку для шаблонов генератора если не существует
if (!FileExist(genTemplatesDir))
    FileCreateDir, %genTemplatesDir%

; === ЛИЦЕНЗИОННАЯ СИСТЕМА ===
global AppVersion := "2.0.0"
; Публичный репозиторий: это не "безопасная" защита (любой может увидеть файл/ключи).
; Система рассчитана на управление доступом, а не на криптографическую защиту.
global LicenseURL := "https://raw.githubusercontent.com/IIo3uTuV4iK/mercurical/main/licenses.ini"
global LicenseKeyLocal := ""
global LicenseValidated := false
global LicenseIniSection := "License"
global UpdateManifestURL := "https://raw.githubusercontent.com/IIo3uTuV4iK/mercurical/main/update.ini"
global AutoUpdateEnabled := 1

; === STARTUP LICENSE CHECK ===
; Попытаемся прочитать сохранённый ключ/URL и проверить их до создания GUI
IniRead, savedLicenseKey_start, %appDataDir%\AutoTyper.ini, %LicenseIniSection%, Key
if (savedLicenseKey_start != "") {
    LicenseKeyLocal := savedLicenseKey_start
    Gosub, ValidateLicense
}

if (!LicenseValidated) {
    ; Попросим ввести ключ до отображения GUI
    InputBox, startupKey, Лицензия, Введите лицензионный ключ (или Cancel для выхода):, , 420, 140
    if ErrorLevel
        ExitApp
    LicenseKeyLocal := startupKey
    Gosub, ValidateLicense
    if (!LicenseValidated) {
        MsgBox, 16, Неверный ключ, Ключ не прошёл проверку. Скрипт будет закрыт.
        ExitApp
    }
    ; Сохраняем ключ и URL
    IniWrite, %LicenseKeyLocal%, %appDataDir%\AutoTyper.ini, %LicenseIniSection%, Key
}

; === AUTO-UPDATE ===
if (AutoUpdateEnabled) {
    Gosub, AutoUpdateCheck
}

; === СТАТИСТИКА / АНАЛИТИКА ===
global stat_totalChars := 0
global stat_startTime := 0
global stat_lastKeyTime := 0
global stat_pauses := []
global stat_minPause := 0
global stat_maxPause := 0
global stat_sumPauses := 0
global stat_corrections := 0
global stat_currentCorrectionSeries := 0
global stat_correctionSeriesCount := 0
global stat_correctionSeriesLengths := []
global stat_arrhythmia := 0
global stat_updateInterval := 1000 ; ms

; === КОНТЕКСТНОЕ МЕНЮ (ПЕРЕПИСАННАЯ СИСТЕМА) ===
; Создаем подменю для вставок
Menu, InsertsSubmenu, Add, (Загрузка...), DoNothing
Menu, InsertsSubmenu, Disable, (Загрузка...)

; Создаем подменю для режимов
Menu, ModesSubmenu, Add, 🎯 Legit-режим, ContextSetLegitMode
Menu, ModesSubmenu, Add, 🔥 Rage-режим, ContextSetRageMode
Menu, ModesSubmenu, Add, 📝 Обычный текст, ContextSetNormalMode
Menu, ModesSubmenu, Add, 🎲 Генератор, ContextSetGeneratorMode

; Создаем подменю для быстрых действий
Menu, QuickActionsSubmenu, Add, ▶ Старт печати, ContextStartTyping
Menu, QuickActionsSubmenu, Add, ⏹ Стоп печати, ContextStopTyping
Menu, QuickActionsSubmenu, Add, ⏸ Пауза, ContextPauseTyping
Menu, QuickActionsSubmenu, Add
Menu, QuickActionsSubmenu, Add, 🔄 Сбросить настройки, ContextResetSettings

; Основное контекстное меню
Menu, ContextMenu, Add, 📋 Добавить в вставку текста, AddSelectedToInsert
Menu, ContextMenu, Add, 📝 Добавить в основной текст, AddSelectedToMainText
Menu, ContextMenu, Add
Menu, ContextMenu, Add, 🔤 Изменить регистр, ChangeTextCase
Menu, ContextMenu, Add, ⚠️ Изменить уровень ошибок, ChangeErrorLevel
Menu, ContextMenu, Add, 📊 Изменить генерацию строк/слов, ChangeGeneratorCount
Menu, ContextMenu, Add, ⏎ Сменить Auto-Enter, ChangeAutoEnter
Menu, ContextMenu, Add
Menu, ContextMenu, Add, 📝 Управление вставками, :InsertsSubmenu
Menu, ContextMenu, Add, 🧠 Режимы печати, :ModesSubmenu
Menu, ContextMenu, Add, ⚡ Быстрые действия, :QuickActionsSubmenu
Menu, ContextMenu, Add
Menu, ContextMenu, Add, ⚙️ Открыть настройки, ContextOpenSettings
Menu, ContextMenu, Add, ❌ Закрыть, CloseContextMenu

; Контекстное меню нейросети (Alt+Z)
Menu, NeuroMenu, Add, 🤖 Открыть вкладку "Нейросеть", NeuroMenuOpenTab
Menu, NeuroMenu, Add, ⚙️ Настройки нейросети, NeuroMenuOpenSettings
Menu, NeuroMenu, Add
Menu, NeuroMenu, Add, ▶ Запрос... (InputBox), NeuroMenuAsk
Menu, NeuroMenu, Add, ▶ Запрос из буфера, NeuroMenuAskClipboard
Menu, NeuroMenu, Add
Menu, NeuroMenu, Add, 📋 Копия последнего ответа, NeuroCopyLast

; === ГЛАВНЫЙ ИНТЕРФЕЙС ===
Gui, +Resize +MinSize800x700
OnMessage(0x115, "OnScroll")
OnMessage(0x20A, "OnMouseWheel")
Gui, Color, White, White

; === БОКОВАЯ ПАНЕЛЬ ===
; Фон боковой панели
Gui, Font, s11 Bold, Segoe UI
Gui, Add, Text, x0 y0 w180 h1000 BackgroundF0F0F0, 
Gui, Add, Text, x10 y15 w160 h30 c0066CC BackgroundTrans Center, AUTOTYPER

; === РАЗДЕЛ: Текст ===
Gui, Font, s8 Normal, Segoe UI
Gui, Add, Text, x10 y55 w160 h20 c808080 BackgroundTrans, Текст
Gui, Font, s9 Normal, Segoe UI
Gui, Add, Text, vMenuText x10 y75 w170 h25 c0066CC BackgroundTrans gMenuText, ⬤  Основной текст
Gui, Add, Text, vMenuSlots x10 y100 w170 h25 cBlack BackgroundTrans gMenuSlots,     По слотам
Gui, Add, Text, vMenuRecord x10 y125 w170 h25 cBlack BackgroundTrans gMenuRecord,     Запись текста
Gui, Add, Text, vMenuLegit x10 y150 w170 h25 cBlack BackgroundTrans gMenuLegit,     Legit-режим
Gui, Add, Text, vMenuLegitAdv x10 y175 w170 h25 cBlack BackgroundTrans gMenuLegitAdv,     Доп. Legit

; === РАЗДЕЛ: Генераторы ===
Gui, Font, s8 Normal, Segoe UI
Gui, Add, Text, x10 y210 w160 h20 c808080 BackgroundTrans, Генераторы
Gui, Font, s9 Normal, Segoe UI
Gui, Add, Text, vMenuGenerator x10 y230 w170 h25 cBlack BackgroundTrans gMenuGenerator,     Генератор текста
Gui, Add, Text, vMenuGenSettings x10 y255 w170 h25 cBlack BackgroundTrans gMenuGenSettings,     Доп. генератора

; === РАЗДЕЛ: Обработка ===
Gui, Font, s8 Normal, Segoe UI
Gui, Add, Text, x10 y290 w160 h20 c808080 BackgroundTrans, Обработка
Gui, Font, s9 Normal, Segoe UI
Gui, Add, Text, vMenuAutoEnter x10 y310 w170 h25 cBlack BackgroundTrans gMenuAutoEnter,     Auto-Enter
Gui, Add, Text, vMenuErrors x10 y335 w170 h25 cBlack BackgroundTrans gMenuErrors,     Генератор ошибок
Gui, Add, Text, vMenuShuffle x10 y360 w170 h25 cBlack BackgroundTrans gMenuShuffle,     Перемешивание
Gui, Add, Text, vMenuSplitter x10 y385 w170 h25 cBlack BackgroundTrans gMenuSplitter,     Разделитель

; === РАЗДЕЛ: Настройки ===
Gui, Font, s8 Normal, Segoe UI
Gui, Add, Text, x10 y410 w160 h20 c808080 BackgroundTrans, Настройки
Gui, Font, s9 Normal, Segoe UI
Gui, Add, Text, vMenuSettings x10 y430 w170 h25 cBlack BackgroundTrans gMenuSettings,     Основные

; === РАЗДЕЛ: Дополнительно ===
Gui, Font, s8 Normal, Segoe UI
Gui, Add, Text, x10 y465 w160 h20 c808080 BackgroundTrans, Дополнительно
Gui, Font, s9 Normal, Segoe UI
Gui, Add, Text, vMenuRage x10 y485 w170 h25 cBlack BackgroundTrans gMenuRage,     Rage-режим
Gui, Add, Text, vMenuBinds x10 y510 w170 h25 cBlack BackgroundTrans gMenuBinds,     По биндам
; Gui, Add, Text, vMenuConstructor x10 y535 w170 h25 cBlack BackgroundTrans gMenuConstructor,     Конструктор
; Gui, Add, Text, vMenuContextMenu x10 y560 w170 h25 cBlack BackgroundTrans gMenuContextMenu,     Контекстное меню
Gui, Add, Text, vMenuModeSelect x10 y535 w170 h25 cBlack BackgroundTrans gMenuModeSelect,     Режим Печати
Gui, Add, Text, vMenuDictionary x10 y560 w170 h25 cBlack BackgroundTrans gMenuDictionary,     Словарь
Gui, Add, Text, x10 y585 w160 h20 c808080 BackgroundTrans, Справка
Gui, Add, Text, vMenuInfo x10 y605 w170 h25 cBlack BackgroundTrans gMenuInfo,     Информация
Gui, Add, Text, vMenuKnowledge x10 y630 w170 h25 cBlack BackgroundTrans gMenuKnowledge,     База знаний
Gui, Add, Text, vMenuNeuro x10 y655 w170 h25 cBlack BackgroundTrans gMenuNeuro,     Нейросеть
; Gui, Add, Text, vMenuOnline x10 y620 w170 h25 cBlack BackgroundTrans gMenuOnline,     Онлайн-Шаблоны
 
; Глобальная переменная для текущей вкладки
global currentTab := 1

; === ВКЛАДКИ ДЛЯ КОНТЕНТА (СКРЫТЫЕ) ===
Gui, Font, s9, Segoe UI
Gui, Add, Tab3, x180 y-100 w620 h1100 vMainTabs -Background, Текст|Слоты|Запись|Legit|Доп.Legit|Генератор|Доп.Генератор|Auto-Enter|Ошибки|Перемешивание|Разделитель|Удалитель|Настройки|Конструктор|Контекст|Rage|Бинды|Режим Печати|Словарь|Информация|База знаний|Нейросеть

; === ВКЛАДКА ТЕКСТА ===
Gui, Tab, 1

; ═══════════════════════════════════════════════════════════════════════════════
; 📝 ОСНОВНОЙ ТЕКСТ - ПОЛНЫЙ РЕДИЗАЙН С TREEVIEW
; ═══════════════════════════════════════════════════════════════════════════════

; === ЛЕВАЯ ПАНЕЛЬ: TREEVIEW ШАБЛОНОВ ===
Gui, Add, GroupBox, x200 y40 w250 h480, 📂 Шаблоны текста
Gui, Add, TreeView, vMainTextTree x210 y60 w230 h360 gMainTextTreeSelect
Gui, Add, Button, x210 y425 w110 h22 gMainTreeRefresh, 🔄 Обновить
Gui, Add, Button, x325 y425 w115 h22 gMainTreeExpand, ⬇ Развернуть
Gui, Add, Button, x210 y452 w110 h22 gMainTreeNewCategory, ➕ Категория
Gui, Add, Button, x325 y452 w115 h22 gMainTreeNewSubcat, ➕ Подкат.
Gui, Add, Button, x210 y479 w110 h22 gMainTreeNewTemplate, ➕ Шаблон
Gui, Add, Button, x325 y479 w115 h22 gMainTreeDelete, ❌ Удалить
Gui, Add, Text, vMainTreePath x210 y505 w230 h15 cGray, Путь: /

; === ПРАВАЯ ПАНЕЛЬ: РЕДАКТОР ТЕКСТА ===
Gui, Add, GroupBox, x460 y40 w280 h480, 📝 Редактор текста
Gui, Add, Edit, vTypeText x470 y60 w260 h280 Multi VScroll gMainTextChanged
Gui, Add, Text, vTypeTextCharCount x470 y345 w260 h15 cGray, 0 символов | 0 слов | 0 строк

; Поле для заметок
Gui, Add, Text, x470 y365 w260 h15, 📝 Заметки и комментарии:
Gui, Add, Edit, vTemplateNotes x470 y380 w260 h60 Multi VScroll gTemplateNotesChanged
Gui, Add, Text, vTemplateNotesCount x470 y445 w260 h15 cGray, Заметок: 0 символов

; Кнопки управления
Gui, Add, Button, x470 y465 w85 h22 gMainTextSave, 💾 Сохранить
Gui, Add, Button, x560 y465 w85 h22 gMainTextLoad, 📂 Загрузить
Gui, Add, Button, x650 y465 w80 h22 gMainTextClear, 🗑 Очистить
Gui, Add, Button, x470 y492 w85 h22 gMainTextCopy, 📋 Копировать
Gui, Add, Button, x560 y492 w85 h22 gMainTextPaste, 📥 Вставить
Gui, Add, Button, x650 y492 w80 h22 gMainTextToSlots, 📦 В слоты

; === НАСТРОЙКИ ТЕКСТА ===
Gui, Add, GroupBox, x200 y525 w540 h145, ⚙️ Параметры печати
Gui, Add, Checkbox, vRandomizeMessages x210 y545, 🎲 Случайный выбор строки
Gui, Add, Button, x410 y542 w35 h22 gOpenRandomLineSettings, ⚙
Gui, Add, Checkbox, vNoRepeatText x210 y570, 🔁 Не повторять текст
Gui, Add, Text, x210 y595, 📍 Начать с:
Gui, Add, DropDownList, vStartPosition x290 y592 w150 gStartPositionChanged, С начала|С середины|С конца|Начать со строки
Gui, Add, Checkbox, vMainTextAutoSave x460 y545, 💾 Автосохранение
Gui, Add, Checkbox, vMainTextShowPreview x460 y570, 👁 Показать превью
Gui, Add, Button, x460 y590 w130 h25 gMainTextRename, ✏️ Переименовать
Gui, Add, Button, x595 y590 w135 h25 gMainTextMove, 📁 Переместить

; ═══════════════════════════════════════════════════════════════════════════════
; 📊 ОГРАНИЧЕНИЕ ПЕЧАТИ - ЧЕКБОКСЫ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y625 w540 h330, 📊 Ограничение печати

; Первая строка - чекбокс "Без ограничений"
Gui, Add, Checkbox, vPrintLimitNone x220 y650 gPrintLimitChanged Checked, ⚪ Без ограничений

; Вторая строка - "По словам" с полем ввода
Gui, Add, Checkbox, vPrintLimitWords x220 y672 gPrintLimitChanged, 🔢 По словам:
Gui, Add, Edit, vPrintWordLimit x330 y669 w80 h22 Number Disabled Center, 150
Gui, Add, Text, x415 y672 cGray, слов

; Третья строка - "По строкам" с полем ввода  
Gui, Add, Checkbox, vPrintLimitLines x480 y672 gPrintLimitChanged, 📄 По строкам:
Gui, Add, Edit, vPrintLineLimit x600 y669 w80 h22 Number Disabled Center, 5
Gui, Add, Text, x685 y672 cGray, строк

; Четвертая строка - "По времени" с полем ввода + единицы
Gui, Add, Checkbox, vPrintLimitTime x220 y694 gPrintLimitChanged, ⏱ По времени:
Gui, Add, Edit, vPrintTimeLimit x340 y691 w80 h22 Number Disabled Center, 1
Gui, Add, DropDownList, vPrintTimeUnit x425 y691 w130 Disabled, Миллисекунда|Секунда||Минута

; Циклы ограничения печати (N-циклов)
Gui, Add, Checkbox, vPrintLimitCyclesEnabled x220 y720 gPrintLimitCyclesToggle, 🔁 Циклы ограничения печати (по циклам)
Gui, Add, Text, x220 y744, ➕ Добавить цикл:
Gui, Add, DropDownList, vPrintLimitCycleType x335 y741 w120 gPrintLimitCycleTypeChanged, Слова|Строки|Время
Gui, Add, Edit, vPrintLimitCycleValue x460 y741 w70 h22 Number Center, 2
Gui, Add, DropDownList, vPrintLimitCycleUnit x535 y741 w120 Disabled, Миллисекунда|Секунда||Минута
Gui, Add, Button, x660 y740 w70 h22 gAddPrintLimitCycle, Добавить

Gui, Add, ListView, vPrintLimitCyclesList x220 y768 w510 h120 Grid AltSubmit, №|Тип|Лимит
Gui, Add, Button, x220 y892 w90 h22 gEditPrintLimitCycle, ✏️ Изм.
Gui, Add, Button, x315 y892 w90 h22 gDeletePrintLimitCycle, ❌ Удал.
Gui, Add, Button, x410 y892 w90 h22 gMovePrintLimitCycleUp, ⬆ Вверх
Gui, Add, Button, x505 y892 w90 h22 gMovePrintLimitCycleDown, ⬇ Вниз
Gui, Add, Button, x600 y892 w130 h22 gClearPrintLimitCycles, 🗑 Очистить
Gui, Add, Text, vPrintLimitCyclesInfo x220 y918 w510 cGray, Циклы: выкл.

; === ВКЛАДКА LEGIT-РЕЖИМ ===
Gui, Tab, 4

; ═══════════════════════════════════════════════════════════════════════════════
; 🎯 LEGIT-РЕЖИМ - ЧЕЛОВЕЧЕСКАЯ ПЕЧАТЬ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y40 w540 h100, 🎯 Legit-режим: Человеческая печать
Gui, Add, Text, x210 y60, Этот режим имитирует реальную человеческую печать с естественными паузами,
Gui, Add, Text, x210 y75, вариациями скорости, ошибками и исправлениями для максимальной реалистичности.
Gui, Add, Checkbox, vLegitModeEnabled x210 y100 gLegitModeToggle, Включить Legit-режим (заменяет стандартную печать)

; ═══════════════════════════════════════════════════════════════════════════════
; СКОРОСТЬ ПЕЧАТИ (WPM)
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y145 w540 h110, Скорость печати (WPM - слов в минуту)
Gui, Add, Text, x210 y165, Базовая скорость:
Gui, Add, Slider, vLegitWPM x210 y185 w350 Range10-5000 TickInterval500 gLegitWPMChanged, 80
Gui, Add, Edit, vLegitWPMInput x570 y182 w60 Number gLegitWPMInputChanged, 80
Gui, Add, Text, x640 y185, WPM
Gui, Add, Text, vLegitWPMDesc x210 y215 w520 cGray, 80 WPM = Средний (40-60: новичок / 60-80: средний / 80-120: быстрый / 120+: профи)
Gui, Add, Button, x210 y235 w100 h20 gLegitPresetSlow, Медленно
Gui, Add, Button, x315 y235 w100 h20 gLegitPresetNormal, Обычно
Gui, Add, Button, x420 y235 w100 h20 gLegitPresetFast, Быстро
Gui, Add, Button, x525 y235 w100 h20 gLegitPresetPro, Про
Gui, Add, Button, x630 y235 w100 h20 gLegitPresetInsane, Insane

; ═══════════════════════════════════════════════════════════════════════════════
; ВАРИАЦИЯ И УСКОРЕНИЕ СКОРОСТИ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y260 w265 h195, Вариация и ускорение
Gui, Add, Text, x210 y280, Множитель WPM:
Gui, Add, Slider, vLegitWPMMultiplier x210 y300 w120 Range10-30 TickInterval5 gLegitWPMMultiplierChanged AltSubmit, 10
Gui, Add, Edit, vLegitWPMMultiplierInput x340 y297 w40 gLegitWPMMultiplierInputChanged, 1.0
Gui, Add, Text, x385 y300, x
Gui, Add, Button, x210 y322 w40 h18 gLegitMultiplier10, 1.0x
Gui, Add, Button, x255 y322 w40 h18 gLegitMultiplier12, 1.2x
Gui, Add, Button, x300 y322 w40 h18 gLegitMultiplier15, 1.5x
Gui, Add, Button, x345 y322 w40 h18 gLegitMultiplier20, 2.0x
Gui, Add, Button, x390 y322 w40 h18 gLegitMultiplier30, 3.0x
Gui, Add, Text, x210 y345, Разброс скорости:
Gui, Add, Slider, vLegitSpeedVariation x210 y365 w120 Range0-80 ToolTip, 15
Gui, Add, Edit, vLegitSpeedVarInput x340 y362 w40 Number, 15
Gui, Add, Text, x385 y365, `%
Gui, Add, Checkbox, vLegitAccelEnabled x210 y390, Ускорение WPM
Gui, Add, Text, x210 y415, Начальный WPM:
Gui, Add, Edit, vLegitAccelStartWPM x330 y412 w50 Number, 40
Gui, Add, Text, x210 y440, Конечный WPM:
Gui, Add, Edit, vLegitAccelEndWPM x330 y437 w50 Number, 120

; ═══════════════════════════════════════════════════════════════════════════════
; УПРАВЛЕНИЕ ЗАДЕРЖКАМИ МЕЖДУ БУКВАМИ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x475 y260 w265 h195, Задержки между буквами
Gui, Add, Text, x485 y280, Мин. задержка (мс):
Gui, Add, Edit, vLegitMinDelay x620 y277 w50 Number, 0
Gui, Add, Text, x485 y305, Макс. задержка (мс):
Gui, Add, Edit, vLegitMaxDelay x620 y302 w50 Number, 0
Gui, Add, Text, x485 y330 cGray, 0 = авто (по WPM)
Gui, Add, Checkbox, vLegitRandomDelay x485 y355, Случайная задержка
Gui, Add, Text, x485 y380, Мин:
Gui, Add, Edit, vLegitRandomDelayMin x520 y377 w40 Number, 20
Gui, Add, Text, x565 y380, Макс:
Gui, Add, Edit, vLegitRandomDelayMax x600 y377 w50 Number, 150
Gui, Add, Text, x655 y380, мс
Gui, Add, Checkbox, vLegitAdaptiveDelay x485 y405, Адаптивная задержка (по длине слова)
Gui, Add, Text, x485 y430, Время разгона:
Gui, Add, Edit, vLegitAccelTime x600 y427 w40 Number, 5
Gui, Add, Text, x645 y430, сек

; ═══════════════════════════════════════════════════════════════════════════════
; ПАУЗЫ МЕЖДУ СЛОВАМИ (расширенные настройки)
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y460 w265 h105, Паузы между словами
Gui, Add, Checkbox, vLegitWordPauseEnabled x210 y480, Включить паузы
Gui, Add, Text, x210 y505, Пауза:
Gui, Add, Edit, vLegitWordPauseInput x265 y502 w50 Number, 50
Gui, Add, DropDownList, vLegitWordPauseUnit x320 y500 w50, мс|сек|мин
Gui, Add, Text, x210 y530, Мин:
Gui, Add, Edit, vLegitWordPauseMin x245 y527 w40 Number, 30
Gui, Add, Text, x290 y530, Макс:
Gui, Add, Edit, vLegitWordPauseMax x325 y527 w40 Number, 100
Gui, Add, Text, x375 y530, мс
Gui, Add, Checkbox, vLegitWordPauseRandom x210 y550, Случайная (мин-макс)

; ═══════════════════════════════════════════════════════════════════════════════
; ПАУЗЫ РАЗДУМЬЯ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x475 y460 w265 h105, Паузы раздумья
Gui, Add, Checkbox, vLegitThinkingEnabled x485 y480, Включить паузы раздумья
Gui, Add, Text, x485 y505, Частота (1 из N):
Gui, Add, Edit, vLegitThinkingFreq x590 y502 w40 Number, 15
Gui, Add, Text, x485 y530, Длит:
Gui, Add, Edit, vLegitThinkingMin x520 y527 w35 Number, 200
Gui, Add, Text, x558 y530, -
Gui, Add, Edit, vLegitThinkingMax x570 y527 w35 Number, 800
Gui, Add, DropDownList, vLegitThinkingUnit x610 y525 w45, мс|сек
Gui, Add, Text, x660 y530, Шанс:
Gui, Add, Edit, vLegitThinkingChance x695 y527 w35 Number, 100

; ═══════════════════════════════════════════════════════════════════════════════
; ОШИБКИ И ИСПРАВЛЕНИЯ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y570 w265 h100, Ошибки и исправления
Gui, Add, Checkbox, vLegitTyposEnabled x210 y590, Включить опечатки
Gui, Add, Text, x210 y615, Частота:
Gui, Add, Slider, vLegitTypoFreq x270 y615 w100 Range0-20 ToolTip, 3
Gui, Add, Edit, vLegitTypoFreqInput x375 y612 w35 Number, 3
Gui, Add, Text, x415 y615, `%
Gui, Add, Checkbox, vLegitAutoCorrect x210 y640, Автоисправление (Backspace)

; ═══════════════════════════════════════════════════════════════════════════════
; ОСТАНОВКИ ПЕЧАТИ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x475 y570 w265 h100, Остановки печати
Gui, Add, Checkbox, vLegitPauseEnabled x485 y590, Включить остановки
Gui, Add, Text, x485 y615, Длит:
Gui, Add, Edit, vLegitPauseDuration x525 y612 w35 Number, 500
Gui, Add, DropDownList, vLegitPauseUnit x565 y610 w45, мс|сек|мин
Gui, Add, Text, x615 y615, Кол-во:
Gui, Add, Edit, vLegitPauseCount x660 y612 w35 Number, 3
Gui, Add, Text, x485 y640, Интервал (симв):
Gui, Add, Edit, vLegitPauseInterval x590 y637 w40 Number, 50

; ═══════════════════════════════════════════════════════════════════════════════
; РИТМ ПЕЧАТИ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y675 w265 h80, Ритм печати
Gui, Add, Text, x210 y695, Стиль:
Gui, Add, DropDownList, vLegitRhythm x255 y692 w140, Равномерный|Волнообразный|Рваный|Ускоряющийся|Замедляющийся
Gui, Add, Text, x210 y725, Интенсивность:
Gui, Add, Slider, vLegitRhythmIntensity x310 y725 w100 Range1-100 ToolTip, 30
Gui, Add, Edit, vLegitRhythmIntInput x415 y722 w35 Number, 30

; ═══════════════════════════════════════════════════════════════════════════════
; ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x475 y675 w265 h80, Дополнительные настройки
Gui, Add, Checkbox, vLegitBurstMode x485 y695, Burst
Gui, Add, Button, vLegitBurstSettings x540 y693 w20 h18 gOpenBurstSettings, ⚙
Gui, Add, Checkbox, vLegitFatigue x570 y695, Усталость
Gui, Add, Checkbox, vLegitCharDifficulty x660 y695, Сложн.букв
Gui, Add, Checkbox, vLegitCapsDelay x485 y720, Shift-задержка
Gui, Add, Checkbox, vLegitPunctDelay x600 y720, Пунктуация

; ═══════════════════════════════════════════════════════════════════════════════
; ТЕСТ LEGIT-РЕЖИМА
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y760 w540 h65, Тест Legit-режима
Gui, Add, Text, x210 y780, Тест:
Gui, Add, Edit, vLegitTestInput x250 y777 w380 h22, Привет как дела? Это тест человеческой печати!
Gui, Add, Button, x640 y777 w90 h22 gLegitTestType, Тест
Gui, Add, Text, vLegitTestStats x210 y805 w520, Статистика: ожидание теста...

; ═══════════════════════════════════════════════════════════════════════════════
; === ВКЛАДКА ДОПОЛНИТЕЛЬНЫХ НАСТРОЕК LEGIT-РЕЖИМА ===
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Tab, 5

; ═══════════════════════════════════════════════════════════════════════════════
; 🎭 ИМИТАЦИЯ ЧЕЛОВЕЧЕСКОГО ПОВЕДЕНИЯ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y40 w540 h140, 🎭 Имитация человеческого поведения
Gui, Add, Checkbox, vLegitHumanMistakes x210 y60, Случайные ошибки при быстром наборе
Gui, Add, Text, x210 y85, Шанс ошибки при скорости > 150 WPM:
Gui, Add, Edit, vLegitFastErrorChance x420 y82 w40 Number, 5
Gui, Add, Text, x465 y85, `%
Gui, Add, Checkbox, vLegitDoublePress x210 y110, Случайное двойное нажатие клавиши
Gui, Add, Text, x210 y135, Шанс двойного нажатия:
Gui, Add, Edit, vLegitDoublePressChance x370 y132 w40 Number, 1
Gui, Add, Text, x415 y135, `%
Gui, Add, Checkbox, vLegitMissedKey x500 y110, Пропуск буквы
Gui, Add, Text, x500 y135, Шанс:
Gui, Add, Edit, vLegitMissedKeyChance x545 y132 w40 Number, 1
Gui, Add, Text, x590 y135, `%

; ═══════════════════════════════════════════════════════════════════════════════
; ⌨️ РЕАЛИСТИЧНАЯ КЛАВИАТУРА
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y185 w265 h150, ⌨️ Расположение клавиш
Gui, Add, Checkbox, vLegitKeyDistance x210 y205, Учитывать расстояние между клавишами
Gui, Add, Text, x210 y230 cGray, Далёкие клавиши = больше задержка
Gui, Add, Checkbox, vLegitHandSwitch x210 y255, Задержка при смене руки
Gui, Add, Text, x210 y280, Доп. задержка (мс):
Gui, Add, Edit, vLegitHandSwitchDelay x350 y277 w50 Number, 20
Gui, Add, Checkbox, vLegitFingerStrength x210 y305, Сила пальцев (мизинец медленнее)
Gui, Add, Text, x210 y325 cGray, Мизинец +30`%, безымянный +15`%

; ═══════════════════════════════════════════════════════════════════════════════
; 🧠 КОГНИТИВНЫЕ ПАУЗЫ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x475 y185 w265 h150, 🧠 Когнитивные паузы
Gui, Add, Checkbox, vLegitSentencePause x485 y205, Пауза в конце предложения
Gui, Add, Text, x485 y230, Длительность (мс):
Gui, Add, Edit, vLegitSentencePauseMin x610 y227 w40 Number, 100
Gui, Add, Text, x655 y230, -
Gui, Add, Edit, vLegitSentencePauseMax x670 y227 w40 Number, 500
Gui, Add, Checkbox, vLegitCommaPause x485 y255, Пауза после запятой
Gui, Add, Edit, vLegitCommaPauseMs x640 y252 w50 Number, 50
Gui, Add, Text, x695 y255, мс
Gui, Add, Checkbox, vLegitNewWordPause x485 y280, Микропауза перед новым словом
Gui, Add, Edit, vLegitNewWordPauseMs x670 y277 w40 Number, 15
Gui, Add, Text, x485 y305 cGray, Имитация чтения следующего слова

; ═══════════════════════════════════════════════════════════════════════════════
; 📊 ЕСТЕСТВЕННАЯ ВАРИАЦИЯ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y340 w265 h130, 📊 Естественная вариация
Gui, Add, Checkbox, vLegitNaturalVariation x210 y360, Естественная вариация скорости
Gui, Add, Text, x210 y385, Амплитуда волны:
Gui, Add, Edit, vLegitWaveAmplitude x340 y382 w40 Number, 20
Gui, Add, Text, x385 y385, `%
Gui, Add, Text, x210 y410, Период волны (символов):
Gui, Add, Edit, vLegitWavePeriod x370 y407 w40 Number, 30
Gui, Add, Checkbox, vLegitRandomSpikes x210 y435, Случайные всплески скорости
Gui, Add, Text, x210 y455 cGray, Иногда печатать быстрее/медленнее

; ═══════════════════════════════════════════════════════════════════════════════
; 😴 УСТАЛОСТЬ И КОНЦЕНТРАЦИЯ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x475 y340 w265 h130, 😴 Усталость и концентрация
Gui, Add, Checkbox, vLegitProgressiveFatigue x485 y360, Прогрессивная усталость
Gui, Add, Text, x485 y385, Замедление к концу:
Gui, Add, Edit, vLegitFatiguePercent x620 y382 w40 Number, 20
Gui, Add, Text, x665 y385, `%
Gui, Add, Checkbox, vLegitConcentrationLoss x485 y410, Потеря концентрации
Gui, Add, Text, x485 y435, Шанс отвлечься:
Gui, Add, Edit, vLegitDistractionChance x610 y432 w40 Number, 2
Gui, Add, Text, x655 y435, `%
Gui, Add, Text, x485 y455 cGray, Случайные длинные паузы

; ═══════════════════════════════════════════════════════════════════════════════
; 🔤 ОСОБЕННОСТИ НАБОРА
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y475 w265 h120, 🔤 Особенности набора
Gui, Add, Checkbox, vLegitCapsLockDelay x210 y495, Задержка на CapsLock/Shift
Gui, Add, Edit, vLegitCapsLockMs x400 y492 w40 Number, 30
Gui, Add, Text, x445 y495, мс
Gui, Add, Checkbox, vLegitNumberRowDelay x210 y520, Задержка на цифровом ряду
Gui, Add, Edit, vLegitNumberRowMs x420 y517 w40 Number, 25
Gui, Add, Text, x465 y520, мс
Gui, Add, Checkbox, vLegitSpecialCharDelay x210 y545, Задержка на спецсимволах
Gui, Add, Edit, vLegitSpecialCharMs x420 y542 w40 Number, 40
Gui, Add, Text, x465 y545, мс
Gui, Add, Text, x210 y570 cGray, @#$`%^&*() и другие

; ═══════════════════════════════════════════════════════════════════════════════
; 🎯 ТОЧНОСТЬ НАБОРА
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x475 y475 w265 h120, 🎯 Точность набора
Gui, Add, Checkbox, vLegitNeighborKeyError x485 y495, Ошибка соседней клавиши
Gui, Add, Text, x485 y520, Шанс:
Gui, Add, Edit, vLegitNeighborKeyChance x530 y517 w40 Number, 2
Gui, Add, Text, x575 y520, `%
Gui, Add, Checkbox, vLegitSwapLetters x485 y545, Перестановка букв (опечатка)
Gui, Add, Text, x485 y570, Шанс:
Gui, Add, Edit, vLegitSwapLettersChance x530 y567 w40 Number, 1
Gui, Add, Text, x575 y570, `%

; ═══════════════════════════════════════════════════════════════════════════════
; 🔧 ДОПОЛНИТЕЛЬНЫЕ ЭФФЕКТЫ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y600 w540 h80, 🔧 Дополнительные эффекты
Gui, Add, Checkbox, vLegitWarmup x210 y620, Разогрев (первые слова медленнее)
Gui, Add, Edit, vLegitWarmupWords x420 y617 w40 Number, 5
Gui, Add, Text, x465 y620, слов
Gui, Add, Checkbox, vLegitEndRush x210 y645, Ускорение в конце (спешка)
Gui, Add, Edit, vLegitEndRushPercent x420 y642 w40 Number, 10
Gui, Add, Text, x465 y645, `% текста
Gui, Add, Checkbox, vLegitLongWordSlow x500 y620, Длинные слова медленнее
Gui, Add, Text, x500 y645, Порог:
Gui, Add, Edit, vLegitLongWordThreshold x545 y642 w30 Number, 8
Gui, Add, Text, x580 y645, букв

; ═══════════════════════════════════════════════════════════════════════════════
; 📋 ПРЕСЕТЫ РЕАЛИЗМА
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y685 w540 h60, 📋 Пресеты реализма
Gui, Add, Button, x210 y705 w100 h30 gLegitPresetRobot, 🤖 Робот
Gui, Add, Button, x320 y705 w100 h30 gLegitPresetBeginner, 👶 Новичок
Gui, Add, Button, x430 y705 w100 h30 gLegitPresetAverage, 👤 Средний
Gui, Add, Button, x540 y705 w100 h30 gLegitPresetProRealism, 💪 Профи
Gui, Add, Button, x650 y705 w80 h30 gLegitPresetUltra, 🔥 Ультра

; === ВКЛАДКА ГЕНЕРАТОРА ТЕКСТА ===
Gui, Tab, 6

; ═══════════════════════════════════════════════════════════════════════════════
; 🎲 ГЕНЕРАТОР ТЕКСТА - ПОЛНЫЙ РЕДИЗАЙН С TREEVIEW
; ═══════════════════════════════════════════════════════════════════════════════

; === ЛЕВАЯ ПАНЕЛЬ: TREEVIEW ШАБЛОНОВ ГЕНЕРАТОРА ===
Gui, Add, GroupBox, x200 y40 w250 h520, 📂 Шаблоны генератора
Gui, Add, TreeView, vGenTextTree x210 y60 w230 h360 gGenTextTreeSelect
Gui, Add, Button, x210 y425 w230 h25 gGenLoadSelectedTemplate, 📥 Загрузить шаблон
Gui, Add, Button, x210 y455 w110 h22 gGenTreeRefresh, 🔄 Обновить
Gui, Add, Button, x325 y455 w115 h22 gGenTreeExpand, ⬇ Развернуть
Gui, Add, Button, x210 y482 w110 h22 gGenTreeNewCategory, ➕ Категория
Gui, Add, Button, x325 y482 w115 h22 gGenTreeNewSubcat, ➕ Подкат.
Gui, Add, Button, x210 y509 w110 h22 gGenTreeNewTemplate, ➕ Шаблон
Gui, Add, Button, x325 y509 w115 h22 gGenTreeDelete, ❌ Удалить
Gui, Add, Button, x210 y536 w230 h22 gGenTreeOpenFolder, 📁 Открыть папку
Gui, Add, Text, vGenTreePath x210 y563 w230 h15 cGray, Путь: /

; === ПРАВАЯ ПАНЕЛЬ: ПРОСМОТР И НАСТРОЙКИ ===
Gui, Add, GroupBox, x460 y40 w280 h200, 📝 Содержимое шаблона
Gui, Add, Edit, vGenTemplateContent x470 y60 w260 h150 Multi VScroll ReadOnly
Gui, Add, Button, x470 y215 w85 h22 gGenContentEdit, ✏️ Редактировать
Gui, Add, Button, x560 y215 w85 h22 gGenContentCopy, 📋 Копировать
Gui, Add, Button, x650 y215 w80 h22 gGenContentClear, 🗑 Очистить

; === РЕЖИМ ГЕНЕРАЦИИ ===
Gui, Add, GroupBox, x460 y245 w280 h95, 🎯 Режим генерации
Gui, Add, Radio, vGenModeSingle x470 y265 Checked gGenModeChanged, 🎯 Случайная строка
Gui, Add, Radio, vGenModeInfinite x470 y285 gGenModeChanged, ∞ Бесконечность
Gui, Add, Radio, vGenModeLines x470 y305 gGenModeChanged, 📄 По строкам
Gui, Add, Radio, vGenModeRandom x470 y325 gGenModeChanged, 🎲 Случайный порядок

; === ЭФФЕКТЫ И ОШИБКИ ===
Gui, Add, GroupBox, x460 y345 w280 h95, ✨ Эффекты и ошибки
Gui, Add, Text, x470 y365, Эффект:
Gui, Add, DropDownList, vGenEffect x520 y362 w210, Обычный|💥 Взрывной|🌊 Волнистый
Gui, Add, Text, x470 y390, Ошибки:
Gui, Add, DropDownList, vGenErrorLevel x520 y387 w210, Нет|Лёгкий|Средний|Высокий|Экстремальный
Gui, Add, Checkbox, vGenAutoCorrect x470 y415, ✏️ Автокоррекция текста

; === НАСТРОЙКИ ГЕНЕРАЦИИ ===
Gui, Add, GroupBox, x460 y445 w280 h115, ⚙️ Настройки генерации
Gui, Add, Checkbox, vGenNoRepeat x470 y465, 🔁 Не повторять слова
Gui, Add, Checkbox, vGenTranslit x470 y485, 🔤 Транслит (латиница)
Gui, Add, Checkbox, vGenCapitalize x470 y505, 🔠 Заглавные буквы
Gui, Add, Checkbox, vGenPunctuation x470 y525, ⏺ Точки в конце
Gui, Add, Checkbox, vGenAddPunctMarks x470 y545, ❗ Запятые/!/?

; === ПАРАМЕТРЫ ГЕНЕРАЦИИ ===
Gui, Add, GroupBox, x200 y565 w540 h95, 📊 Параметры генерации
Gui, Add, Text, x210 y585, Режим:
Gui, Add, DropDownList, vGenGenerationMode x270 y582 w150 gGenModeChanged, По словам|По строкам
Gui, Add, Text, x430 y585, Количество:
Gui, Add, Edit, vGenCountValue x510 y582 w60 Number, 5
Gui, Add, Text, x575 y585 cGray, (0=все)
Gui, Add, Checkbox, vShuffleCorpus x210 y615, 🔀 Перемешать корпус
Gui, Add, Checkbox, vModelCapitalize x370 y615, 🔠 Капитализация
Gui, Add, Checkbox, vModelPunctuation x530 y615, ⏺ Пунктуация

; === ИГНОРИРУЕМЫЕ СЛОВА ===
Gui, Add, GroupBox, x200 y665 w540 h130, 🚫 Игнорируемые слова
Gui, Add, ListView, vGenIgnoredList x210 y685 w420 h80 -Hdr gGenIgnoredSelected, Слово
Gui, Add, Edit, vGenIgnoredInput x210 y770 w300 h22
Gui, Add, Button, x520 y770 w110 h22 gGenAddIgnored, ➕ Добавить
Gui, Add, Button, x640 y685 w90 h24 gGenRemoveIgnored, ❌ Удалить
Gui, Add, Button, x640 y713 w90 h24 gGenClearIgnored, 🗑 Очистить
Gui, Add, Button, x640 y741 w90 h24 gGenLoadIgnored, 📂 Загрузить

; === ТЕСТИРОВАНИЕ ===
Gui, Add, GroupBox, x200 y800 w540 h100, 🧪 Тестирование генерации
Gui, Add, Button, x210 y820 w520 h28 gTestGeneration, 🔍 ТЕСТОВАЯ ГЕНЕРАЦИЯ
Gui, Add, Edit, vTestGenOutput x210 y853 w520 h30 ReadOnly
Gui, Add, Button, x210 y888 w170 h22 gCopyGenToClipboard, 📋 В буфер
Gui, Add, Button, x385 y888 w180 h22 gAddGenToMainText, ➕ В основной текст
Gui, Add, Button, x570 y888 w160 h22 gAddGenToSplitText, ➕ В разбивку

; === ВКЛАДКА НАСТРОЕК ===
Gui, Tab, 13

; ═══════════════════════════════════════════════════════════════════════════════
; 🏷 ФОРМАТИРОВАНИЕ СООБЩЕНИЙ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y40 w540 h90, 🏷 Форматирование сообщений
Gui, Add, Text, x210 y60, Начало:
Gui, Add, Edit, vPrefixInput x280 y57 w200, [Bot]
Gui, Add, Text, x490 y60, Середина:
Gui, Add, Edit, vMidfixInput x560 y57 w170
Gui, Add, Text, x210 y90, Конец:
Gui, Add, Edit, vPostfixInput x280 y87 w450

; ═══════════════════════════════════════════════════════════════════════════════
; 📝 ВСТАВКА СВОЕГО ТЕКСТА
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y135 w540 h130, 📝 Вставка своего текста
Gui, Add, ListView, vInsertsList x210 y155 w420 h75 Grid, Текст|Позиция|Игнор.
LV_ModifyCol(1, 180)
LV_ModifyCol(2, 140)
LV_ModifyCol(3, 80)
Gui, Add, Button, x640 y155 w90 h22 gAddInsert, ➕ Добавить
Gui, Add, Button, x640 y182 w90 h22 gEditInsert, ✏️ Редакт.
Gui, Add, Button, x640 y209 w90 h22 gDeleteInsert, ❌ Удалить
Gui, Add, Button, x640 y236 w90 h22 gClearInserts, 🗑 Очистить
Gui, Add, Text, x210 y235 cGray, 💡 Alt+C для быстрого добавления

; ═══════════════════════════════════════════════════════════════════════════════
; ⚡ СКОРОСТЬ И ПОВТОРЕНИЯ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y270 w265 h180, ⚡ Скорость
Gui, Add, Text, x210 y290, Тип:
Gui, Add, DropDownList, vSpeedType x250 y287 w150 gUpdateSpeedType, Букв в секунду|Слов в минуту|Интервал|Задержка|Вставка через буфер обмена
Gui, Add, Button, vSpeedSettingsBtn x405 y287 w20 h22 gOpenSpeedSettings, ⚙
GuiControl, ChooseString, SpeedType, Букв в секунду
Gui, Add, Text, x210 y317, Значение:
Gui, Add, Edit, vSpeedInput x280 y314 w60, 10
Gui, Add, Text, vSpeedUnit x345 y317, букв/сек
Gui, Add, Text, vClipboardDelayLabel x210 y317 Hidden, Задержка:
Gui, Add, Edit, vClipboardDelayInput x280 y314 w60 Number Hidden, 0
Gui, Add, DropDownList, vClipboardDelayUnit x345 y312 w60 Hidden, мс|сек|мин
Gui, Add, Text, x210 y347, Ускорение:
Gui, Add, DropDownList, vSpeedMultiplier x280 y344 w120, 1x|2x|3x|5x|10x|20x|50x|100x|200x|500x|1000x|2000x|5000x|10000x
Gui, Add, Button, vSpeedAccelBtn x405 y344 w20 h22 gOpenAccelerationAdvanced, ⚙
GuiControl, Choose, SpeedMultiplier, 1
Gui, Add, Text, x210 y377, Повторы:
Gui, Add, Edit, vRepeatInput x280 y374 w60, 1
Gui, Add, Text, x345 y377 cGray, (0=∞)
Gui, Add, Text, x210 y407, Задержка букв:
Gui, Add, Edit, vCharDelayMin x300 y404 w40 Number, 0
Gui, Add, Text, x343 y407, -
Gui, Add, Edit, vCharDelayMax x355 y404 w40 Number, 0
Gui, Add, Text, x400 y407, мс

; ═══════════════════════════════════════════════════════════════════════════════
; ⏱ ПАУЗЫ И ЗАДЕРЖКИ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x475 y270 w265 h180, ⏱ Паузы
Gui, Add, Text, x485 y290, Между сообщениями:
Gui, Add, Edit, vMessageDelay x610 y287 w60, 1000
Gui, Add, Text, x675 y290, мс
Gui, Add, Checkbox, vMessagePauseEnabled x485 y317, Случайная пауза
Gui, Add, Text, x485 y342, Мин:
Gui, Add, Edit, vMessagePauseMin x520 y339 w50 Number, 500
Gui, Add, Text, x575 y342, Макс:
Gui, Add, Edit, vMessagePauseMax x610 y339 w50 Number, 2000
Gui, Add, Text, x665 y342, мс
Gui, Add, Checkbox, vRandomSpacesEnabled x485 y367, Случайные пробелы
Gui, Add, Text, x485 y392, Частота:
Gui, Add, Edit, vRandomSpacesFrequency x540 y389 w40 Number, 10
Gui, Add, Text, x585 y392, Тип:
Gui, Add, DropDownList, vRandomSpacesType x615 y389 w100, Двойной|Тройной|Случайный

; ═══════════════════════════════════════════════════════════════════════════════
; 📝 ОБРАБОТКА ТЕКСТА
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y455 w265 h130, 📝 Обработка текста
Gui, Add, Text, x210 y475, Ошибки:
Gui, Add, DropDownList, vErrorLevelSetting x270 y472 w130, Нет|Лёгкий|Средний|Высокий|Экстремальный|Кастомный
Gui, Add, Button, x405 y472 w20 h22 gOpenErrorSettings, ⚙
Gui, Add, Text, x210 y502, Регистр:
Gui, Add, DropDownList, vTextCase x270 y499 w100, Обычный|ВЕРХНИЙ|нижний|Случайный
Gui, Add, Button, vCaseSettingsBtn x375 y499 w20 h22 gOpenCaseSettings, ⚙
Gui, Add, Text, x210 y532, Транслит:
Gui, Add, DropDownList, vPrintTranslit x270 y529 w100, Выключено|Включено
Gui, Add, Button, vTranslatorBtn x375 y529 w50 h22 gOpenTranslator, 🌐

; ═══════════════════════════════════════════════════════════════════════════════
; 🔤 ДОПОЛНИТЕЛЬНЫЕ ЭФФЕКТЫ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x475 y455 w265 h200, 🔤 Дополнительно
Gui, Add, Checkbox, vDoubleLettersEnabled x485 y475, Double/Triple буквы
Gui, Add, DropDownList, vDoubleLettersType x630 y472 w100, Double|Triple|Случайный
Gui, Add, Text, x485 y502, Частота:
Gui, Add, Edit, vDoubleLettersFrequency x540 y499 w40 Number, 5
Gui, Add, Text, x585 y502, (1 из N)
Gui, Add, Text, x485 y532, Авто-коррекция:
Gui, Add, DropDownList, vAutoCorrect x580 y529 w100, Нет|Базовая|Агрессивная
Gui, Add, Button, vAutoCorrectBtn x685 y529 w20 h22 gOpenAutoCorrectSettings, ⚙
Gui, Add, Checkbox, vStealthModeEnabled x485 y560, Stealth-режим
Gui, Add, Button, x605 y557 w30 h22 gOpenStealthAdvanced, ⚙
Gui, Add, Checkbox, vSmallCapsEnabled x485 y585 w250, Small Capital
Gui, Add, Text, x505 y605 w230 h35 cGray, (ᴀбʙᴦдᴇёжзийᴋᴧʍ`nноᴨᴩᴄᴛуɸхцчɯщъыь϶юя)

; ═══════════════════════════════════════════════════════════════════════════════
; 🔧 ВСТАВКА БУКВ ВНУТРИ СЛОВ (во все слова)
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y660 w540 h130, 🔧 Вставка букв внутри слов
Gui, Add, ListView, vLetterInsertsList x210 y680 w420 h80 Grid, Буквы|Позиция|N-раз|Статус
LV_ModifyCol(1, 150)
LV_ModifyCol(2, 130)
LV_ModifyCol(3, 60)
LV_ModifyCol(4, 60)
Gui, Add, Button, x640 y680 w90 h22 gAddLetterInsert, ➕ Добавить
Gui, Add, Button, x640 y707 w90 h22 gEditLetterInsert, ✏️ Редакт.
Gui, Add, Button, x640 y734 w90 h22 gDeleteLetterInsert, ❌ Удалить
Gui, Add, Button, x640 y761 w90 h22 gClearLetterInserts, 🗑 Очистить

; ═══════════════════════════════════════════════════════════════════════════════
; 💾 ПРЕСЕТЫ НАСТРОЕК
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y795 w365 h105, 💾 Пресеты настроек
Gui, Add, Text, x210 y818, Пресет:
Gui, Add, DropDownList, vSettingsPresetList x260 y815 w160
Gui, Add, Button, x425 y814 w65 h22 gLoadSettingsPreset, 📂 Загр.
Gui, Add, Button, x495 y814 w65 h22 gSaveSettingsPreset, 💾 Сохр.
Gui, Add, Button, x260 y840 w140 h22 gRenameSettingsPreset, ✏️ Переим.
Gui, Add, Button, x425 y840 w135 h22 gDeleteSettingsPreset, ❌ Удал.
Gui, Add, Checkbox, vAutoSave x210 y867, Автосохранение при выходе
GuiControl,, AutoSave, 1
Gui, Add, Checkbox, vAutoBackup x400 y867, Резервные копии

Gui, Add, GroupBox, x575 y795 w165 h105, 🔤 Буквы
Gui, Add, Button, x585 y818 w145 h25 gOpenLetterRestriction, 🚫 Ограничение букв
Gui, Add, Button, x585 y848 w145 h25 gOpenLetterChanger, 🔤 Изменитель букв

; === ВКЛАДКА AUTO-ENTER ===
Gui, Tab, 8

; ═══════════════════════════════════════════════════════════════════════════════
; ⏎ AUTO-ENTER - ПОЛНЫЙ РЕДИЗАЙН
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y40 w540 h90, ⏎ Режимы Auto-Enter
Gui, Add, Radio, vAutoEnterMode x210 y60 gUpdateAutoEnterMode, Отключено
Gui, Add, Radio, x210 y80 gUpdateAutoEnterMode, Максимум слов в сообщении
Gui, Add, Radio, x210 y100 gUpdateAutoEnterMode, Enter через время
Gui, Add, Radio, x400 y60 gUpdateAutoEnterMode, По циклам
Gui, Add, Radio, x400 y80 gUpdateAutoEnterMode, По биндам

; ═══════════════════════════════════════════════════════════════════════════════
; ⚙️ НАСТРОЙКИ AUTO-ENTER
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y135 w265 h100, ⚙️ Основные настройки
Gui, Add, Text, vMaxWordsLabel x210 y155, Макс. слов:
Gui, Add, Edit, vMaxWordsInput x290 y152 w60 Number, 0
Gui, Add, Text, vMaxWordsHint x360 y155 cGray, (0 = без лимита)
Gui, Add, Checkbox, vAutoEnterInsertPerChunk x210 y180, Вставка в каждый фрагмент
GuiControl,, AutoEnterInsertPerChunk, 0
Gui, Add, Text, vTimeLabel x210 y205 hidden, Интервал:
Gui, Add, Edit, vTimeInput x290 y202 w60 hidden Number, 1000
Gui, Add, DropDownList, vTimeUnit x360 y200 w60 hidden, мс|сек
Gui, Add, Text, vTimeHint x430 y205 hidden cGray, до Enter

Gui, Add, GroupBox, x475 y135 w265 h100, 🔄 Дополнительно
Gui, Add, Checkbox, vAutoEnterSound x485 y155, 🔊 Звук при Enter
Gui, Add, Checkbox, vAutoEnterDelay x485 y180, ⏱️ Задержка после Enter
Gui, Add, Edit, vAutoEnterDelayValue x620 y177 w50 Number, 100
Gui, Add, Text, x675 y180, мс
Gui, Add, Checkbox, vAutoEnterRandomDelay x485 y205, 🎲 Случайная задержка

; ═══════════════════════════════════════════════════════════════════════════════
; 🔁 ЦИКЛЫ AUTO-ENTER
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y240 w540 h180, 🔁 Циклы Auto-Enter (слов на цикл)
Gui, Add, ListView, vAutoEnterCyclesList x210 y260 w360 h120 Grid, №|Слов|Статус
LV_ModifyCol(1, 40)
LV_ModifyCol(2, 200)
LV_ModifyCol(3, 100)
Gui, Add, Text, x580 y260, Слов в цикле:
Gui, Add, Edit, vAutoEnterCycleWords x580 y280 w150 Number, 1
Gui, Add, Button, x580 y310 w150 h25 gAddAutoEnterCycle, ➕ Добавить цикл
Gui, Add, Button, x580 y340 w70 h25 gEditAutoEnterCycle, ✏️ Изм.
Gui, Add, Button, x660 y340 w70 h25 gDeleteAutoEnterCycle, ❌ Удал.
Gui, Add, Button, x580 y370 w150 h25 gClearAutoEnterCycles, 🗑️ Очистить все
Gui, Add, Text, vAutoEnterCycleInfo x210 y385 w360 cGray, Цикл 1: 1 слово → Цикл 2: 2 слова → ...

; ═══════════════════════════════════════════════════════════════════════════════
; ⌨️ БИНДЫ AUTO-ENTER
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y425 w540 h150, ⌨️ Бинды Auto-Enter
Gui, Add, ListView, vAutoEnterBindsList x210 y445 w360 h100 Grid, Бинд|Действие|Статус
LV_ModifyCol(1, 100)
LV_ModifyCol(2, 180)
LV_ModifyCol(3, 60)
Gui, Add, Text, x580 y445, Бинд:
Gui, Add, Edit, vAutoEnterBindHotkey x580 y465 w100 ReadOnly
Gui, Add, Button, vAutoEnterBindCapture x685 y465 w45 h22 gCaptureAutoEnterBind, 🎯
Gui, Add, Text, x580 y495, Действие:
Gui, Add, DropDownList, vAutoEnterBindAction x580 y515 w150, Следующий цикл|Предыдущий цикл|Сброс циклов|Вкл/Выкл Auto-Enter
Gui, Add, Button, x580 y545 w70 h22 gAddAutoEnterBind, ➕ Добав.
Gui, Add, Button, x660 y545 w70 h22 gDeleteAutoEnterBind, ❌ Удал.

; ═══════════════════════════════════════════════════════════════════════════════
; 🧪 ТЕСТ AUTO-ENTER
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y580 w540 h50, 🧪 Тест Auto-Enter
Gui, Add, Text, vAutoEnterTestStatus x210 y600 w400, Статус: Отключено | Текущий цикл: 1 | Слов: 0
Gui, Add, Button, x620 y597 w110 h25 gTestAutoEnter, 🔍 Тестировать

; === ВКЛАДКА ГЕНЕРАТОРА ОШИБОК ===
Gui, Tab, 9
Gui, Font, s9 Normal, Segoe UI

; === ЛЕВАЯ ПАНЕЛЬ: Основные настройки ===
Gui, Add, GroupBox, x200 y40 w360 h240, ⚡ Уровень генератора ошибок
Gui, Add, Radio, vErrorGenLevel x210 y60 gUpdateErrorGenLevel, Отключено
Gui, Add, Radio, x210 y85 gUpdateErrorGenLevel, Маленький (5 букв)
Gui, Add, Radio, x210 y110 gUpdateErrorGenLevel, Средний (10 букв)
Gui, Add, Radio, x210 y135 gUpdateErrorGenLevel, Высокий (15 букв)
Gui, Add, Radio, x210 y160 gUpdateErrorGenLevel, Гигантский (20 букв)
Gui, Add, Radio, x210 y185 gUpdateErrorGenLevel, Экстремальный (25 букв)
Gui, Add, Radio, x210 y210 gUpdateErrorGenLevel, Свой
Gui, Add, Edit, vCustomErrorCount x350 y207 w80 hidden, 10
Gui, Add, Text, vCustomErrorText x440 y210 hidden, случайных букв

Gui, Add, GroupBox, x200 y290 w360 h180, 📍 Местоположение ошибок
Gui, Add, Radio, vErrorLocation x210 y310, В слове
Gui, Add, Radio, x350 y310, В предложении
Gui, Add, Radio, x210 y335, В разброс
Gui, Add, Radio, x350 y335, В начале слова
Gui, Add, Radio, x210 y360, В конце слова
Gui, Add, Radio, x350 y360, В середине слова
Gui, Add, Text, x210 y385, Ошибки в словах:
Gui, Add, DropDownList, vErrorWordsCount x210 y403 w340 gErrorWordsCountChanged, 1|2|3|4|5|N
Gui, Add, Edit, vErrorWordsCustom x210 y430 w340 h20 hidden, 1

Gui, Add, GroupBox, x200 y480 w360 h260, ✅ Типы ошибок
Gui, Add, Checkbox, vErrorTypeTypo x210 y500 Checked, Опечатки (typo)
Gui, Add, Checkbox, vErrorTypeSwap x210 y520 Checked, Перестановка букв
Gui, Add, Checkbox, vErrorTypeMissing x210 y540, Пропуск букв
Gui, Add, Checkbox, vErrorTypeExtra x210 y560, Лишние буквы
Gui, Add, Checkbox, vErrorTypeCase x210 y580, Изменение регистра
Gui, Add, Checkbox, vErrorTypeDouble x210 y600, Дублирование букв
Gui, Add, Checkbox, vErrorTypeReplace x210 y620, Замена букв
Gui, Add, Checkbox, vErrorTypeRandom x210 y640, Случайные символы
Gui, Add, Checkbox, vErrorTypeTranslit x210 y660, Транслитерация
Gui, Add, Checkbox, vErrorTypeKeyboard x210 y680, Ошибки клавиатуры (QWERTY)

Gui, Add, GroupBox, x200 y750 w360 h70, 🎯 Дополнительные опции
Gui, Add, Checkbox, vErrorPreserveSpaces x210 y770 Checked, Сохранять пробелы
Gui, Add, Checkbox, vErrorPreservePunctuation x210 y790 Checked, Сохранять знаки препинания
Gui, Add, Checkbox, vErrorSmartMode x350 y770, Умный режим
Gui, Add, Checkbox, vErrorExcludeNumbers x350 y790, Исключать числа

; === ПРАВАЯ ПАНЕЛЬ: Профили и история ===
Gui, Add, GroupBox, x570 y40 w170 h280, 🌳 Профили ошибок
Gui, Add, TreeView, vErrorProfilesTree x580 y60 w150 h200
Gui, Add, Button, x580 y265 w50 h22 gAddErrorProfile, ➕
Gui, Add, Button, x635 y265 w50 h22 gDeleteErrorProfile, ➖
Gui, Add, Button, x690 y265 w45 h22 gSaveErrorProfile, 💾

Gui, Add, GroupBox, x570 y330 w170 h400, 📊 История и статистика
Gui, Add, ListView, vErrorHistoryList x580 y350 w150 h180 AltSubmit -Multi, №|Время|Уровень|Тип
Gui, Add, Button, x580 y535 w70 h22 gLoadErrorHistory, 📂 Загрузить
Gui, Add, Button, x655 y535 w70 h22 gClearErrorHistory, 🗑️ Очистить
Gui, Add, Text, x580 y565, Применено: 0
Gui, Add, Text, vErrorStatsApplied x640 y565 w90, 0 раз
Gui, Add, Text, x580 y585, Ошибок: 0
Gui, Add, Text, vErrorStatsCreated x640 y585 w90, 0
Gui, Add, Text, x580 y605, Успешно: 0
Gui, Add, Text, vErrorStatsSuccess x640 y605 w90, 0 раз
Gui, Add, Text, x580 y630, Популярные типы:
Gui, Add, ListView, vErrorTypesList x580 y650 w150 h70 AltSubmit -Multi, Тип|Кол-во
Gui, Add, Button, x580 y725 w150 h22 gResetErrorStats, 🔄 Сбросить

; === НИЖНЯЯ ПАНЕЛЬ: Тестирование ===
Gui, Add, GroupBox, x200 y830 w540 h80, 🧪 Тестирование генератора ошибок
Gui, Add, Text, x210 y850, Тестовый текст:
Gui, Add, Edit, vTestErrorText x210 y868 w520 h25, Это тестовый текст для проверки генератора ошибок
Gui, Add, Button, x210 y900 w120 h25 gTestErrorGenerator, 🔍 Тестировать
Gui, Add, Button, x340 y900 w120 h25 gApplyTestErrorToText, 💾 Применить
Gui, Add, Button, x470 y900 w100 h25 gErrorPreview, 👁️ Превью
Gui, Add, Button, x580 y900 w100 h25 gErrorExport, 📤 Экспорт

; === ВКЛАДКА ПЕРЕМЕШИВАНИЯ ТЕКСТА ===
Gui, Tab, 10
Gui, Font, s9 Normal, Segoe UI

; === ЛЕВАЯ ПАНЕЛЬ: Основные настройки ===
Gui, Add, GroupBox, x200 y40 w360 h200, 🔀 Основные параметры
Gui, Add, Text, x210 y60, Уровень перемешивания:
Gui, Add, DropDownList, vTextShuffleLevel x210 y78 w340, Отключено|Низкий|Средний|Высокий|Экстремальный|Кастомный
Gui, Add, Text, x210 y110, Режим перемешивания:
Gui, Add, DropDownList, vShuffleRandomMode x210 y128 w340, Выключено|Включено|Адаптивный|Случайный
Gui, Add, Text, x210 y160, Интенсивность (Low):
Gui, Add, DropDownList, vShuffleLowProb x210 y178 w340, Редко|Обычно|Часто|Очень часто|Максимально

Gui, Add, GroupBox, x200 y250 w360 h180, ⚙️ Продвинутые настройки
Gui, Add, Text, x210 y270, Поведение (Medium):
Gui, Add, DropDownList, vShuffleMediumBehavior x210 y288 w340, Влево|Вправо|Дублировать первую букву|Случайное направление|Циклическое
Gui, Add, Text, x210 y320, Вероятность суффикса (High):
Gui, Add, DropDownList, vShuffleHighSuffixProb x210 y338 w340, Никогда|Редко|Обычно|Часто|Всегда
Gui, Add, Text, x210 y370, Букв для перемещения:
Gui, Add, DropDownList, vShuffleHighSuffixCount x210 y388 w340, 0|1|2|3|4|5
Gui, Add, Text, x210 y415, Экстрим режим:
Gui, Add, DropDownList, vShuffleExtremeMode x210 y433 w340, Реверс|Полная перестановка|Анаграмма|Случайный порядок

Gui, Add, GroupBox, x200 y440 w360 h200, ✅ Дополнительные опции
Gui, Add, Checkbox, vShufflePreserveSpaces x210 y460 Checked, Сохранять пробелы
Gui, Add, Checkbox, vShufflePreservePunctuation x210 y480 Checked, Сохранять знаки препинания
Gui, Add, Checkbox, vShufflePreserveCase x210 y500, Сохранять регистр букв
Gui, Add, Checkbox, vShuffleWordsOnly x210 y520, Перемешивать только слова
Gui, Add, Checkbox, vShuffleLettersOnly x210 y540, Перемешивать только буквы
Gui, Add, Checkbox, vShuffleSmartMode x210 y560, Умный режим (сохранять структуру)
Gui, Add, Checkbox, vShuffleExcludeNumbers x210 y580, Исключать числа
Gui, Add, Checkbox, vShuffleExcludeSpecial x210 y600, Исключать спецсимволы

; === ПРАВАЯ ПАНЕЛЬ: Дерево настроек и история ===
Gui, Add, GroupBox, x570 y40 w170 h280, 🌳 Профили перемешивания
Gui, Add, TreeView, vShuffleProfilesTree x580 y60 w150 h200
Gui, Add, Button, x580 y265 w50 h22 gAddShuffleProfile, ➕
Gui, Add, Button, x635 y265 w50 h22 gDeleteShuffleProfile, ➖
Gui, Add, Button, x690 y265 w45 h22 gSaveShuffleProfile, 💾

Gui, Add, GroupBox, x570 y330 w170 h310, 📊 История и статистика
Gui, Add, ListView, vShuffleHistoryList x580 y350 w150 h180 AltSubmit -Multi, №|Время|Уровень|Результат
Gui, Add, Button, x580 y535 w70 h22 gLoadShuffleHistory, 📂 Загрузить
Gui, Add, Button, x655 y535 w70 h22 gClearShuffleHistory, 🗑️ Очистить
Gui, Add, Text, x580 y565, Применено: 0
Gui, Add, Text, vShuffleStatsApplied x640 y565 w90, 0 раз
Gui, Add, Text, x580 y585, Успешно: 0
Gui, Add, Text, vShuffleStatsSuccess x640 y585 w90, 0 раз

; === НИЖНЯЯ ПАНЕЛЬ: Тестирование и результат ===
Gui, Add, GroupBox, x200 y650 w540 h90, 🧪 Тестирование перемешивания
Gui, Add, Text, x210 y670, Входной текст:
Gui, Add, Edit, vShuffleTestInput x210 y688 w520 h30
Gui, Add, Button, x210 y725 w120 h25 gRunShuffleTest, 🔍 Тестировать
Gui, Add, Edit, vShuffleTestOutput x340 y725 w410 h25 ReadOnly

; === ВКЛАДКА РАЗДЕЛИТЕЛЯ ТЕКСТА ===
Gui, Tab, 11
Gui, Font, s9 Normal, Segoe UI

; === ЛЕВАЯ ПАНЕЛЬ: Настройки разделения ===
Gui, Add, GroupBox, x200 y40 w360 h280, ⚙️ Параметры разделения
Gui, Add, Text, x210 y60, Исходный текст:
Gui, Add, DropDownList, vSplitSource x210 y78 w340, Основной текст|Введено вручную|Из буфера обмена|Из файла
Gui, Add, Edit, vSplitManualInput x210 y105 w340 h60 Multi VScroll

Gui, Add, Text, x210 y175, Метод разделения:
Gui, Add, Radio, vSplitMethodChars x210 y195 gUpdateSplitMethod Checked, По символам
Gui, Add, Radio, vSplitMethodParagraphs x210 y215 gUpdateSplitMethod, По абзацам
Gui, Add, Radio, vSplitMethodCustom x210 y235 gUpdateSplitMethod, По разделителю
Gui, Add, Radio, vSplitMethodWords x210 y255 gUpdateSplitMethod, По словам
Gui, Add, Radio, vSplitMethodLines x210 y275 gUpdateSplitMethod, По строкам
Gui, Add, Edit, vSplitCustomDelimiter x210 y295 w340 h20 Hidden

Gui, Add, GroupBox, x200 y330 w360 h200, 📊 Дополнительные настройки
Gui, Add, Checkbox, vSplitTrimWhitespace x210 y350 Checked, Удалять пробелы в начале/конце
Gui, Add, Checkbox, vSplitRemoveEmpty x210 y370 Checked, Удалять пустые блоки
Gui, Add, Checkbox, vSplitPreserveFormatting x210 y390, Сохранять форматирование
Gui, Add, Checkbox, vSplitAddNumbering x210 y410, Добавлять нумерацию блоков
Gui, Add, Checkbox, vSplitAddSeparator x210 y430, Добавлять разделитель между блоками
Gui, Add, Text, x210 y455, Разделитель между блоками:
Gui, Add, Edit, vSplitBlockSeparator x210 y473 w340 h20, `n

Gui, Add, Text, x210 y500, Ограничение по символам:
Gui, Add, Slider, vSplitCharLimitSlider x210 y520 w250 Range100-10000 TickInterval500 gUpdateSplitCharLimit, 4800
Gui, Add, Edit, vSplitCharLimitInput x470 y517 w80 h20 Number, 4800

; === ПРАВАЯ ПАНЕЛЬ: История и результаты ===
Gui, Add, GroupBox, x570 y40 w170 h280, 📋 История разделений
Gui, Add, ListView, vSplitHistoryList x580 y60 w150 h200 AltSubmit -Multi, №|Дата|Метод
Gui, Add, Button, x580 y265 w70 h22 gLoadSplitHistory, 📂 Загрузить
Gui, Add, Button, x655 y265 w70 h22 gClearSplitHistory, 🗑️ Очистить

Gui, Add, GroupBox, x570 y330 w170 h200, 📈 Статистика
Gui, Add, Text, x580 y350, Блоков: 0
Gui, Add, Text, vSplitStatsBlocks x640 y350 w90, 0
Gui, Add, Text, x580 y375, Символов: 0
Gui, Add, Text, vSplitStatsChars x640 y375 w90, 0
Gui, Add, Text, x580 y400, Слов: 0
Gui, Add, Text, vSplitStatsWords x640 y400 w90, 0
Gui, Add, Text, x580 y425, Средний размер:
Gui, Add, Text, vSplitStatsAvg x640 y445 w90, 0 симв.

; === НИЖНЯЯ ПАНЕЛЬ: Результаты и действия ===
Gui, Add, GroupBox, x200 y540 w540 h200, 🧪 Результат разделения
Gui, Add, Text, x210 y560, Текст для разделения:
Gui, Add, Edit, vTextSplitterInput x210 y578 w520 h60 Multi VScroll gUpdateTextSplitterCharCount
Gui, Add, Text, vTextSplitterCharCount x210 y643 w520 h15 Right cGray, 0 Символов (UTF-8)

Gui, Add, Text, x210 y665, Результат:
Gui, Add, Edit, vTextSplitterOutput x210 y683 w520 h40 Multi VScroll ReadOnly

Gui, Add, Button, x210 y730 w100 h25 gSplitTextButton, ✂️ Разделить
Gui, Add, Button, x320 y730 w100 h25 gRunSplitTest, 🧪 Тест
Gui, Add, Button, x430 y730 w100 h25 gSplitTextCopy, 📋 Копировать
Gui, Add, Button, x540 y730 w100 h25 gSplitTextToMain, ➕ В основной текст
Gui, Add, Button, x650 y730 w70 h25 gSplitTextClear, 🗑️ Очистить

; === ВКЛАДКА ЗАПИСИ ТЕКСТА ===
Gui, Tab, 3

; ═══════════════════════════════════════════════════════════════════════════════
; 🎙️ ЗАПИСЬ ТЕКСТА - ПОЛНЫЙ РЕДИЗАЙН
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y40 w540 h110, 🎙️ Управление записью
Gui, Add, Text, x210 y60, Статус:
Gui, Font, Bold
Gui, Add, Text, vRecordStatus x280 y60 w150 cRed, ⏹ Остановлено
Gui, Font, Normal
Gui, Add, Text, x440 y60, Время:
Gui, Add, Text, vRecordDuration x490 y60 w80, 0 сек
Gui, Add, Text, x580 y60, Символов:
Gui, Add, Text, vRecordCharCount x650 y60 w80, 0

Gui, Add, Edit, vRecordedTextDisplay x210 y85 w520 h30 ReadOnly

Gui, Add, Button, x210 y120 w80 h22 gStartRecording, 🎤 Запись
Gui, Add, Button, x295 y120 w80 h22 gStopRecording, ⏹ Стоп
Gui, Add, Button, x380 y120 w80 h22 gPauseRecording, ⏸ Пауза
Gui, Add, Button, x465 y120 w80 h22 gClearRecording, ❌ Очистить
Gui, Add, Button, x550 y120 w80 h22 gPlayRecording, ▶ Воспр.
Gui, Add, Button, x635 y120 w95 h22 gSaveRecording, 💾 Сохранить

; ═══════════════════════════════════════════════════════════════════════════════
; 📊 СТАТИСТИКА ВВОДА (ЗАПОМИНАНИЕ СКОРОСТИ)
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y155 w540 h130, 📊 Статистика ввода (запоминание скорости пользователя)
Gui, Add, Text, x210 y175, Символов:
Gui, Add, Text, vStatTotalChars x280 y175 w60, 0
Gui, Add, Text, x350 y175, Время (сек):
Gui, Add, Text, vStatTotalTime x430 y175 w60, 0
Gui, Add, Text, x500 y175, CPM:
Gui, Add, Text, vStatCPM x540 y175 w60, 0
Gui, Add, Text, x610 y175, WPM:
Gui, Add, Text, vStatWPM x650 y175 w60, 0

Gui, Add, Text, x210 y200, Мин. пауза (мс):
Gui, Add, Text, vStatMinPause x310 y200 w50, -
Gui, Add, Text, x370 y200, Макс. пауза:
Gui, Add, Text, vStatMaxPause x460 y200 w50, -
Gui, Add, Text, x520 y200, Средняя:
Gui, Add, Text, vStatAvgPause x590 y200 w50, -
Gui, Add, Text, x650 y200, Аритмия:
Gui, Add, Text, vStatArrhythmia x710 y200 w30, 0

Gui, Add, Text, x210 y225, Gross WPM:
Gui, Add, Text, vStatGross x290 y225 w50, 0
Gui, Add, Text, x350 y225, Net WPM:
Gui, Add, Text, vStatNet x420 y225 w50, 0
Gui, Add, Text, x480 y225, Исправлений:
Gui, Add, Text, vStatCorrections x570 y225 w40, 0
Gui, Add, Text, x620 y225, Серий исправл.:
Gui, Add, Text, vStatCorrectionSeries x720 y225 w30, 0

Gui, Add, Checkbox, vRecordRememberTiming x210 y250 Checked, 🧠 Запоминать тайминги (скорость, паузы, ритм)
Gui, Add, Checkbox, vRecordRememberPauses x450 y250 Checked, ⏱️ Запоминать паузы раздумья
Gui, Add, Button, x620 y247 w110 h22 gResetStats, 🔄 Сброс стат.

; ═══════════════════════════════════════════════════════════════════════════════
; ⏩ НАСТРОЙКИ ВОСПРОИЗВЕДЕНИЯ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y290 w265 h120, ⏩ Воспроизведение
Gui, Add, Text, x210 y310, Скорость:
Gui, Add, Slider, vPlaybackSpeed x280 y307 w100 Range1-1000 ToolTip, 1
Gui, Add, Edit, vPlaybackSpeedInput x390 y307 w40 Number, 1
Gui, Add, Text, x435 y310, x
Gui, Add, Text, x210 y340, Повторы:
Gui, Add, DropDownList, vPlaybackRepeats x280 y337 w80, 1|2|3|5|10|∞|Нет
Gui, Add, Text, x370 y340, Макс. слов:
Gui, Add, Edit, vPlaybackMaxWords x440 y337 w50 Number, 0
Gui, Add, Checkbox, vPlaybackRandomize x210 y370, 🎲 Случайный порядок
Gui, Add, Checkbox, vPlaybackUseTiming x330 y370, 🧠 Использовать записанные тайминги

Gui, Add, GroupBox, x475 y290 w265 h120, ⏰ Задержки
Gui, Add, Text, x485 y310, Режим:
Gui, Add, DropDownList, vPlaybackDelayMode x540 y307 w120 gUpdatePlaybackDelayMode, Отсутствует|Записанные|Миллисекунды|Секунды
Gui, Add, Text, vPlaybackDelayLabel x485 y340 hidden, Задержка:
Gui, Add, Edit, vPlaybackDelayValue x555 y337 w60 hidden Number, 0
Gui, Add, Text, vPlaybackDelayUnit x620 y340 hidden, мс
Gui, Add, Text, x485 y370, Мин:
Gui, Add, Edit, vPlaybackDelayMin x520 y367 w50 Number, 20
Gui, Add, Text, x580 y370, Макс:
Gui, Add, Edit, vPlaybackDelayMax x620 y367 w50 Number, 150
Gui, Add, Text, x675 y370, мс

; ═══════════════════════════════════════════════════════════════════════════════
; 💾 СОХРАНЕНИЕ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y415 w540 h80, 💾 Сохранение записи
Gui, Add, Text, x210 y435, Имя файла:
Gui, Add, Edit, vRecordFileName x290 y432 w200, recorded_text
Gui, Add, Text, x500 y435, .txt
Gui, Add, Text, x540 y435, Папка:
Gui, Add, Edit, vRecordFolder x590 y432 w140, %appDataDir%\records
Gui, Add, Button, x210 y460 w170 h25 gQuickSave, 💾 Быстрое сохранение
Gui, Add, Button, x390 y460 w170 h25 gSaveWithDialog, 💾 Сохранить как...
Gui, Add, Button, x570 y460 w160 h25 gExportWithTiming, 📤 Экспорт с таймингами

; ═══════════════════════════════════════════════════════════════════════════════
; ⚙️ ДОПОЛНИТЕЛЬНО
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y500 w540 h70, ⚙️ Дополнительные настройки
Gui, Add, Checkbox, vRecordIncludeTimestamps x210 y520, Добавлять временные метки
Gui, Add, Checkbox, vRecordRemoveDuplicates x400 y520, Удалять дубликаты строк
Gui, Add, Button, x210 y545 w125 h20 gAddFromClipboard, 📋 Из буфера
Gui, Add, Button, x345 y545 w125 h20 gAddManualText, ✏️ Вручную
Gui, Add, Button, x480 y545 w125 h20 gLoadRecordedText, 📁 В основной
Gui, Add, Button, x615 y545 w115 h20 gOpenRecordsFolder, 📂 Папка

; ═══════════════════════════════════════════════════════════════════════════════
; 🔐 ЛИЦЕНЗИЯ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y575 w540 h55, 🔐 Лицензия
Gui, Add, Text, x210 y595, URL:
Gui, Add, Edit, vLicenseURL x250 y592 w300 ReadOnly cGray, %LicenseURL%
Gui, Add, Text, vLicenseStatus x560 y595 w80, Не проверено
Gui, Add, Button, x650 y592 w80 h22 gEnterLicenseKey, 🔑 Ключ

; === ВКЛАДКА ПО СЛОТАМ ===
Gui, Tab, 2
Gui, Add, GroupBox, x200 y40 w540 h420, 📦 Управление слотами
Gui, Add, ListView, vSlotsList x210 y60 w520 h300 gSlotSelected AltSubmit Multi, Текст|Задержка|Скорость (букв/сек)
LV_ModifyCol(1, 300)
LV_ModifyCol(2, 110)
LV_ModifyCol(3, 110)

Gui, Add, Button, x210 y370 w125 h25 gCreateSlot, ➕ Создать слот
Gui, Add, Button, x345 y370 w125 h25 gEditSlot, ✏️ Редактировать
Gui, Add, Button, x480 y370 w125 h25 gDeleteSlot, ❌ Удалить
Gui, Add, Button, x615 y370 w115 h25 gMoveSlotUp, ⬆️ Вверх
Gui, Add, Button, x615 y400 w115 h25 gMoveSlotDown, ⬇️ Вниз

Gui, Add, Button, x210 y400 w125 h25 gBulkEditDelay, ⏱ Изм. задержку
Gui, Add, Button, x345 y400 w125 h25 gBulkEditSpeed, ⚡ Изм. скорость
Gui, Add, Button, x480 y400 w125 h25 gOpenSlotsSettings, ⚙ Настройки

Gui, Add, GroupBox, x200 y470 w540 h100, 💾 Шаблоны слотов
Gui, Add, Text, x210 y490, Шаблон:
Gui, Add, DropDownList, vSlotsTemplateList x210 y510 w350 gSlotsTemplateSelected
Gui, Add, Button, x570 y508 w160 h25 gLoadSlotsTemplate, 📂 Загрузить
Gui, Add, Button, x210 y540 w125 h25 gSaveSlotsTemplate, 💾 Сохранить
Gui, Add, Button, x345 y540 w125 h25 gDeleteSlotsTemplate, ❌ Удалить
Gui, Add, Button, x480 y540 w125 h25 gRefreshSlotsTemplates, 🔄 Обновить

; === ВКЛАДКА ДОП. НАСТРОЙКИ ГЕНЕРАТОРА ===
Gui, Tab, 7

; ═══════════════════════════════════════════════════════════════════════════════
; 🔧 CUSTOM-СЛОВА - ПОЛНЫЙ РЕДИЗАЙН
; ═══════════════════════════════════════════════════════════════════════════════

; === ЛЕВАЯ ПАНЕЛЬ: СПИСОК CUSTOM-СЛОВ ===
Gui, Add, GroupBox, x200 y40 w350 h400, 🔧 Custom-слова для генерации
Gui, Add, ListView, vCustomWordsList x210 y60 w330 h280 gCustomWordDoubleClick AltSubmit Grid, Слово|Позиция|Возле|Статус
LV_ModifyCol(1, 120)
LV_ModifyCol(2, 70)
LV_ModifyCol(3, 80)
LV_ModifyCol(4, 50)

; Кнопки управления списком
Gui, Add, Button, x210 y345 w80 h22 gAddCustomWord, ➕ Добавить
Gui, Add, Button, x295 y345 w80 h22 gEditCustomWord, ✏️ Изменить
Gui, Add, Button, x380 y345 w80 h22 gDeleteCustomWord, ❌ Удалить
Gui, Add, Button, x465 y345 w75 h22 gToggleCustomWord, 🔁 Вкл/Выкл

Gui, Add, Button, x210 y372 w165 h22 gClearCustomWords, 🗑 Очистить всё
Gui, Add, Button, x380 y372 w160 h22 gRefreshCustomWords, 🔄 Обновить

; Статистика
Gui, Add, Text, vCustomWordsStats x210 y400 w330 h35 cGray, Всего: 0 | Активных: 0 | С вариациями: 0

; === ПРАВАЯ ПАНЕЛЬ: РЕДАКТОР CUSTOM-СЛОВА ===
Gui, Add, GroupBox, x560 y40 w180 h400, ✏️ Редактор слова

Gui, Add, Text, x570 y60, Слово:
Gui, Add, Edit, vCustomWordInput x570 y78 w160 h22

Gui, Add, Text, x570 y108, Позиция:
Gui, Add, DropDownList, vCustomWordPosition x570 y126 w160, До|После|Любая

Gui, Add, Text, x570 y156, Возле слова:
Gui, Add, Edit, vCustomWordNear x570 y174 w160 h22

Gui, Add, Text, x570 y204, Регистр:
Gui, Add, DropDownList, vCustomWordCase x570 y222 w160, Обычный|ВЕРХНИЙ|нижний|Случайный

Gui, Add, Text, x570 y252, Вариации:
Gui, Add, Edit, vCustomWordVariations x570 y270 w160 h60 Multi

Gui, Add, Checkbox, vCustomWordSmartErrors x570 y338 w160, 🧠 Умный режим

Gui, Add, Button, x570 y365 w160 h30 gSaveCustomWord, 💾 Сохранить
Gui, Add, Button, x570 y400 w160 h30 gClearCustomWordForm, 🗑 Очистить форму

; === ВАРИАЦИИ ОШИБОК ===
Gui, Add, GroupBox, x200 y445 w540 h120, ⚠️ Вариации ошибок для выбранного слова
Gui, Add, Text, x210 y465, Выберите слово из списка, затем добавьте вариации ошибок (через запятую):
Gui, Add, Edit, vCustomWordErrorVars x210 y488 w420 h22
Gui, Add, Button, x640 y488 w90 h22 gSetCustomWordErrors, 💾 Сохранить

Gui, Add, Checkbox, vCustomWordAutoErrors x210 y518, 🧠 Автогенерация вариаций (примеры: "привет" → "превет", "привед")
Gui, Add, Text, x210 y540 cGray, Умный режим создаёт реалистичные опечатки автоматически

; === ТЕСТИРОВАНИЕ ===
Gui, Add, GroupBox, x200 y570 w540 h100, 🧪 Тестирование Custom-слов
Gui, Add, Text, x210 y590, Тестовый текст:
Gui, Add, Edit, vCustomWordTestInput x210 y608 w420 h22, Привет как дела сегодня хорошая погода
Gui, Add, Button, x640 y608 w90 h22 gTestCustomWords, 🔍 Тест

Gui, Add, Text, x210 y638, Результат:
Gui, Add, Edit, vCustomWordTestOutput x270 y635 w460 h22 ReadOnly

; === ИМПОРТ/ЭКСПОРТ ===
Gui, Add, GroupBox, x200 y675 w540 h75, 💾 Импорт/Экспорт Custom-слов
Gui, Add, Button, x210 y695 w170 h24 gExportCustomWords, � Эксопорт в файл
Gui, Add, Button, x385 y695 w170 h24 gImportCustomWords, � ИмпоЗрт из файла
Gui, Add, Button, x560 y695 w170 h24 gLoadCustomWordsPreset, 📂 Загрузить пресет

Gui, Add, Text, x210 y725 w520 h20 cGray Center, Custom-слова позволяют добавлять собственные слова в генерируемый текст

; === ВКЛАДКА КОНСТРУКТОР ===
Gui, Tab, 14
Gui, Add, GroupBox, x200 y40 w540 h420, 🎮 Конструктор биндов
Gui, Add, Text, x210 y60, Привязка горячих клавиш к действиям:
Gui, Add, ListView, vBindsList x210 y80 w520 h280 gBindSelected AltSubmit, Бинд|Действие|Параметр|Статус
LV_ModifyCol(1, 100)
LV_ModifyCol(2, 200)
LV_ModifyCol(3, 120)
LV_ModifyCol(4, 80)

Gui, Add, Button, x210 y370 w125 h25 gAddBind, ➕ Добавить бинд
Gui, Add, Button, x345 y370 w125 h25 gEditBind, ✏️ Редактировать
Gui, Add, Button, x480 y370 w125 h25 gDeleteBind, ❌ Удалить
Gui, Add, Button, x615 y370 w115 h25 gToggleBind, 🔁 Вкл/Выкл

Gui, Add, Button, x210 y400 w255 h25 gClearBinds, 🗑 Очистить все
Gui, Add, Button, x475 y400 w255 h25 gTestBind, 🧪 Тест бинда

Gui, Add, GroupBox, x200 y470 w540 h60, ℹ️ Информация
Gui, Add, Text, x210 y490 w520 h25, Конструктор позволяет создавать горячие клавиши для любых действий.

; === ВКЛАДКА КОНТЕКСТНОГО МЕНЮ ===
Gui, Tab, 15
Gui, Add, GroupBox, x200 y40 w540 h420, 📋 Управление контекстным меню (Alt+C)
Gui, Add, Text, x210 y60, Быстрые действия в контекстном меню:
Gui, Add, ListView, vContextMenuList x210 y80 w520 h280 gContextMenuSelected AltSubmit, Название|Действие|Параметр|Статус
LV_ModifyCol(1, 150)
LV_ModifyCol(2, 180)
LV_ModifyCol(3, 100)
LV_ModifyCol(4, 70)

Gui, Add, Button, x210 y370 w125 h25 gAddContextAction, ➕ Добавить
Gui, Add, Button, x345 y370 w125 h25 gEditContextAction, ✏️ Редактировать
Gui, Add, Button, x480 y370 w125 h25 gDeleteContextAction, ❌ Удалить
Gui, Add, Button, x615 y370 w115 h25 gToggleContextAction, 🔁 Вкл/Выкл

Gui, Add, Button, x210 y400 w520 h25 gClearContextActions, 🗑 Очистить все действия

Gui, Add, GroupBox, x200 y470 w540 h60, ℹ️ Информация
Gui, Add, Text, x210 y490 w520 h25, Добавляйте свои быстрые действия в контекстное меню.

; === ВКЛАДКА RAGE-РЕЖИМ ===
Gui, Tab, 16

; ═══════════════════════════════════════════════════════════════════════════════
; 🔥 RAGE-РЕЖИМ - КРАСИВЫЙ РЕДИЗАЙН
; ═══════════════════════════════════════════════════════════════════════════════

; === ЗАГОЛОВОК С ГРАДИЕНТОМ ===
Gui, Font, s14 Bold, Segoe UI
Gui, Add, Text, x200 y40 w540 h40 cFF3333 Center BackgroundTrans, 🔥 RAGE MODE - МАКСИМАЛЬНАЯ СКОРОСТЬ
Gui, Font, s9 Normal, Segoe UI
Gui, Add, Text, x200 y80 w540 h20 cGray Center, 500+ функций • Эксплойты • Обходы • Burst-режимы
Gui, Add, Progress, x200 y102 w540 h3 cRed Background333333, 100

; === ГЛАВНЫЙ ПЕРЕКЛЮЧАТЕЛЬ ===
Gui, Font, s10 Bold, Segoe UI
Gui, Add, Checkbox, vRageModeEnabled x210 y115 w520 h30 gRageModeToggle, ⚡ ВКЛЮЧИТЬ RAGE-РЕЖИМ (заменяет стандартную печать)
Gui, Font, s9 Normal, Segoe UI

; === РЕЖИМ РАБОТЫ - КРАСИВЫЕ КНОПКИ ===
Gui, Add, GroupBox, x200 y150 w540 h70, 🎯 Режим работы
Gui, Add, Radio, vRageWorkModeNormal x210 y170 w160 h35 Checked gRageWorkModeChanged, 📝 Обычный`n(работа с текстом)
Gui, Add, Radio, vRageWorkModeGenerator x380 y170 w160 h35 gRageWorkModeChanged, 🎲 Генератор`n(авто-генерация)
Gui, Add, Radio, vRageWorkModeHybrid x550 y170 w180 h35 gRageWorkModeChanged, 🔀 Гибрид`n(текст + генератор)

; ═══════════════════════════════════════════════════════════════════════════════
; ⚡ СКОРОСТЬ - КАРТОЧКА 1
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y230 w260 h220, ⚡ Скорость и производительность
Gui, Add, Text, x210 y250 cFF3333, Базовая скорость:
Gui, Add, Slider, vRageSpeed x210 y270 w180 Range100-99999 TickInterval10000 gRageSpeedChanged Thick, 9999
Gui, Add, Edit, vRageSpeedInput x400 y267 w50 Number Center, 9999
Gui, Add, Text, x210 y295, симв/сек
Gui, Font, s8 Bold, Segoe UI
Gui, Add, Button, x210 y315 w75 h25 gRagePresetFast, 🚀 Быстро
Gui, Add, Button, x290 y315 w75 h25 gRagePresetMax, ⚡ МАКС
Gui, Add, Button, x370 y315 w80 h25 gRagePresetGod, 👑 GOD
Gui, Font, s9 Normal, Segoe UI
Gui, Add, Checkbox, vRageNoDelay x210 y350, ⚡ Без задержек
Gui, Add, Checkbox, vRageTurboMode x210 y370, 🔥 Turbo (x2)
Gui, Add, Checkbox, vRageHyperMode x210 y390, 💨 Hyper (x5)
Gui, Add, Checkbox, vRageGodMode x210 y410, 👑 God (x10)
Gui, Add, Text, x210 y430, Множитель:
Gui, Add, Edit, vRageSpeedMultiplier x280 y427 w50 Center, 1.0
Gui, Add, UpDown, Range0.1-100, 1.0

; ═══════════════════════════════════════════════════════════════════════════════
; 🎯 МЕТОДЫ ОТПРАВКИ - КАРТОЧКА 2
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x470 y230 w270 h220, 🎯 Методы отправки
Gui, Add, Radio, vRageSendText x480 y250 Checked, 📝 Send {Text}
Gui, Add, Radio, vRageSendRaw x480 y270, 📄 SendRaw
Gui, Add, Radio, vRageSendInput x480 y290, ⌨️ SendInput
Gui, Add, Radio, vRageSendPlay x480 y310, 🎮 SendPlay
Gui, Add, Radio, vRageSendEvent x480 y330, 📡 SendEvent
Gui, Add, Radio, vRageClipboard x480 y350, 📋 Clipboard
Gui, Add, Radio, vRageCOMObject x480 y370, 🔧 COM Object
Gui, Add, Checkbox, vRageDLLCall x480 y390, 💻 DLL Call
Gui, Add, Checkbox, vRageMemoryWrite x480 y410, 🧠 Memory Write
Gui, Add, Checkbox, vRageDirectInput x480 y430, 🎯 Direct Input

; ═══════════════════════════════════════════════════════════════════════════════
; 💣 ЭКСПЛОЙТЫ - КАРТОЧКА 3
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y460 w260 h130, 💣 Эксплойты
Gui, Add, Checkbox, vRageBypassDetection x210 y480, 🔓 Обход детекции
Gui, Add, Checkbox, vRageBypassAntiCheat x210 y500, 🛡️ Обход античита
Gui, Add, Checkbox, vRageBypassRateLimit x210 y520, ⏱️ Обход лимита
Gui, Add, Checkbox, vRageBypassFlood x210 y540, 🌊 Обход флуда
Gui, Add, Checkbox, vRageBypassCaptcha x210 y560, 🤖 Обход капчи
Gui, Add, Checkbox, vRageBypassValidation x210 y580, ✅ Обход валидации

; ═══════════════════════════════════════════════════════════════════════════════
; 🎲 РАНДОМИЗАЦИЯ - КАРТОЧКА 4
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x470 y460 w270 h130, 🎲 Рандомизация
Gui, Add, Checkbox, vRageRandomizeOrder x480 y480, 🔀 Случайный порядок
Gui, Add, Checkbox, vRageRandomizeWords x480 y500, 📝 Случайные слова
Gui, Add, Checkbox, vRageRandomizeChars x480 y520, 🔤 Случайные буквы
Gui, Add, Checkbox, vRageRandomizeCase x480 y540, 🔠 Случайный регистр
Gui, Add, Checkbox, vRageRandomizeSpaces x480 y560, ␣ Случайные пробелы
Gui, Add, Checkbox, vRageRandomizePunct x480 y580, .,!? Случайная пунктуация

; ═══════════════════════════════════════════════════════════════════════════════
; 💥 BURST-РЕЖИМЫ - БОЛЬШАЯ КАРТОЧКА
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y600 w540 h90, 💥 Burst-режимы (массовая отправка)
Gui, Add, Checkbox, vRageBurstMode x210 y620 w150 h25, ⚡ Включить Burst
Gui, Add, Text, x370 y623, Размер пакета:
Gui, Add, Edit, vRageBurstSize x460 y620 w70 Number Center, 100
Gui, Add, Text, x535 y623, строк
Gui, Font, s8 Bold, Segoe UI
Gui, Font, s8 Bold, Segoe UI
Gui, Add, Checkbox, vRageMicroBurst x210 y655 gRageBurstChanged, Micro (10)
Gui, Add, Checkbox, vRageMiniBurst x285 y655 gRageBurstChanged, Mini (50)
Gui, Add, Checkbox, vRageNormalBurst x360 y655 gRageBurstChanged, Normal (100)
Gui, Add, Checkbox, vRageMegaBurst x435 y655 gRageBurstChanged, Mega (500)
Gui, Add, Checkbox, vRageGigaBurst x510 y655 gRageBurstChanged, Giga (1000)
Gui, Add, Checkbox, vRageUltraBurst x585 y655 gRageBurstChanged, Ultra (5000)
Gui, Add, Checkbox, vRageInfiniteBurst x660 y655 gRageBurstChanged, ∞ Infinite
Gui, Font, s9 Normal, Segoe UI

; ═══════════════════════════════════════════════════════════════════════════════
; 🔧 РАСШИРЕННЫЕ НАСТРОЙКИ - БОЛЬШАЯ КНОПКА
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Font, s11 Bold, Segoe UI
Gui, Add, Button, x200 y800 w540 h35 gOpenRageAdvanced, 🔧 РАСШИРЕННЫЕ НАСТРОЙКИ (500+ параметров)
Gui, Font, s9 Normal, Segoe UI

; === ВКЛАДКА ПО БИНДАМ ===
Gui, Tab, 17

; ═══════════════════════════════════════════════════════════════════════════════
; ⌨️ ПЕЧАТЬ ПО БИНДАМ - ПОЛНЫЙ РЕДИЗАЙН
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y40 w540 h250, ⌨️ Шаблоны биндов
Gui, Add, ListView, vBindTemplatesList x210 y60 w520 h150 Grid, Бинд|Текст|Скорость|Регистр|Ошибки|Статус
LV_ModifyCol(1, 70)
LV_ModifyCol(2, 180)
LV_ModifyCol(3, 80)
LV_ModifyCol(4, 70)
LV_ModifyCol(5, 60)
LV_ModifyCol(6, 50)

Gui, Add, Button, x210 y220 w100 h25 gAddBindTemplate, ➕ Добавить
Gui, Add, Button, x320 y220 w100 h25 gEditBindTemplate, ✏️ Редактир.
Gui, Add, Button, x430 y220 w100 h25 gDeleteBindTemplate, ❌ Удалить
Gui, Add, Button, x540 y220 w90 h25 gToggleBindTemplate, 🔁 Вкл/Выкл
Gui, Add, Button, x640 y220 w90 h25 gDuplicateBindTemplate, � Коопия

Gui, Add, Button, x210 y255 w170 h22 gClearBindTemplates, 🗑️ Очистить все
Gui, Add, Button, x390 y255 w170 h22 gTestBindTemplate, 🧪 Тест бинда

; ═══════════════════════════════════════════════════════════════════════════════
; 💾 ПРЕСЕТЫ БИНДОВ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y295 w265 h100, 💾 Пресеты биндов
Gui, Add, DropDownList, vBindPresetList x210 y315 w245
Gui, Add, Button, x210 y345 w80 h22 gSaveBindPreset, 💾 Сохран.
Gui, Add, Button, x295 y345 w80 h22 gLoadBindPreset, 📂 Загруз.
Gui, Add, Button, x380 y345 w75 h22 gDeleteBindPreset, ❌ Удал.
Gui, Add, Button, x210 y372 w245 h18 gRefreshBindPresets, 🔄 Обновить список

; ═══════════════════════════════════════════════════════════════════════════════
; 🎭 ВАРИАЦИИ ШАБЛОНОВ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x475 y295 w265 h100, 🎭 Вариации шаблонов
Gui, Add, ListView, vBindVariationsList x485 y315 w165 h55 Grid, Вариация
LV_ModifyCol(1, 155)
Gui, Add, Button, x660 y315 w70 h25 gAddBindVariation, ➕ Добав.
Gui, Add, Button, x660 y345 w70 h25 gDeleteBindVariation, ❌ Удал.
Gui, Add, Checkbox, vBindVariationRandom x485 y375, 🎲 Случайный выбор вариации

; ═══════════════════════════════════════════════════════════════════════════════
; 📝 ВСТАВКИ СЛОВ/БУКВ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y400 w265 h130, 📝 Вставки слов
Gui, Add, ListView, vBindWordInsertsList x210 y420 w165 h60 Grid, Слово|Позиция
LV_ModifyCol(1, 100)
LV_ModifyCol(2, 55)
Gui, Add, Button, x385 y420 w70 h25 gAddBindWordInsert, ➕ Добав.
Gui, Add, Button, x385 y450 w70 h25 gDeleteBindWordInsert, ❌ Удал.
Gui, Add, Text, x210 y485, Слово:
Gui, Add, Edit, vBindWordInsertText x260 y482 w115 h20
Gui, Add, Text, x210 y510, Позиция:
Gui, Add, DropDownList, vBindWordInsertPos x260 y507 w115, В начале|В конце|Случайно

Gui, Add, GroupBox, x475 y400 w265 h130, 🔤 Вставки букв
Gui, Add, ListView, vBindLetterInsertsList x485 y420 w165 h60 Grid, Буква|Частота
LV_ModifyCol(1, 80)
LV_ModifyCol(2, 75)
Gui, Add, Button, x660 y420 w70 h25 gAddBindLetterInsert, ➕ Добав.
Gui, Add, Button, x660 y450 w70 h25 gDeleteBindLetterInsert, ❌ Удал.
Gui, Add, Text, x485 y485, Буква:
Gui, Add, Edit, vBindLetterInsertChar x535 y482 w40 h20
Gui, Add, Text, x585 y485, Частота:
Gui, Add, Edit, vBindLetterInsertFreq x640 y482 w40 Number, 5
Gui, Add, Text, x685 y485, `%

; ═══════════════════════════════════════════════════════════════════════════════
; 🔁 ПОВТОРЫ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y535 w540 h60, 🔁 Повторы
Gui, Add, Checkbox, vBindRepeatEnabled x210 y555, Включить повторы
Gui, Add, Text, x340 y558, Кол-во:
Gui, Add, Edit, vBindRepeatCount x390 y555 w50 Number, 1
Gui, Add, Text, x450 y558, Задержка:
Gui, Add, Edit, vBindRepeatDelay x510 y555 w50 Number, 100
Gui, Add, DropDownList, vBindRepeatDelayUnit x565 y553 w50, мс|сек
Gui, Add, Checkbox, vBindRepeatRandom x630 y555, 🎲 Случ.

; ═══════════════════════════════════════════════════════════════════════════════
; 📥 ИМПОРТ/ЭКСПОРТ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y600 w540 h40, 📥 Импорт/Экспорт
Gui, Add, Button, x210 y615 w170 h20 gImportBindTemplates, 📥 Импорт из файла
Gui, Add, Button, x390 y615 w170 h20 gExportBindTemplates, 📤 Экспорт в файл
Gui, Add, Button, x570 y615 w160 h20 gOpenBindsFolder, 📂 Открыть папку

; ═══════════════════════════════════════════════════════════════════════════════
; 🧷 БИНДЫ УПРАВЛЕНИЯ СКРИПТОМ
; ═══════════════════════════════════════════════════════════════════════════════
Gui, Add, GroupBox, x200 y650 w540 h110, 🧷 Бинды управления (старт/стоп/пауза/экстренно)
Gui, Add, Text, x210 y675, Старт:
Gui, Add, Edit, vControlStartHotkey x265 y672 w110 h22 ReadOnly Center
Gui, Add, Button, vControlStartCapture x380 y672 w45 h22 gCaptureControlStartHotkey, 🎯
Gui, Add, Text, x435 y675, Стоп:
Gui, Add, Edit, vControlStopHotkey x480 y672 w110 h22 ReadOnly Center
Gui, Add, Button, vControlStopCapture x595 y672 w45 h22 gCaptureControlStopHotkey, 🎯

Gui, Add, Text, x210 y705, Пауза:
Gui, Add, Edit, vControlPauseHotkey x265 y702 w110 h22 ReadOnly Center
Gui, Add, Button, vControlPauseCapture x380 y702 w45 h22 gCaptureControlPauseHotkey, 🎯
Gui, Add, Text, x435 y705, Экстренно:
Gui, Add, Edit, vControlEmergencyHotkey x510 y702 w80 h22 ReadOnly Center
Gui, Add, Button, vControlEmergencyCapture x595 y702 w45 h22 gCaptureControlEmergencyHotkey, 🎯

Gui, Add, Button, x210 y733 w130 h22 gApplyControlHotkeys, ✅ Применить
Gui, Add, Button, x345 y733 w160 h22 gResetControlHotkeys, 🔄 По умолчанию
Gui, Add, Text, vControlHotkeysHint x510 y736 w220 h18 cGray, F12 = экстренная остановка

; === ВКЛАДКА РЕЖИМ ПЕЧАТИ ===
Gui, Tab, 18

; ═══════════════════════════════════════════════════════════════════════════════
; 🎯 РЕЖИМ ПЕЧАТИ - ВЫБОР РЕЖИМА ПЕЧАТИ
; ═══════════════════════════════════════════════════════════════════════════════

Gui, Add, GroupBox, x200 y40 w540 h80, 🎯 Режим Печати
Gui, Font, s11 Bold, Segoe UI
Gui, Add, Text, x210 y60 w520 h40 Center, Выберите режим печати для работы программы

; === КНОПКИ ВЫБОРА РЕЖИМА (БОЛЬШИЕ КАРТОЧКИ) ===
Gui, Font, s10 Bold, Segoe UI

; Обычный текст
Gui, Add, Button, vModeBtn1 x200 y140 w150 h100 gSelectMode1, 📝`n`nОбычный текст

; Генератор текста
Gui, Add, Button, vModeBtn2 x370 y140 w150 h100 gSelectMode2, 🎲`n`nГенератор текста

; По слотам
Gui, Add, Button, vModeBtn3 x540 y140 w150 h100 gSelectMode3, 📦`n`nПо слотам

; Legit-режим
Gui, Add, Button, vModeBtn4 x200 y260 w150 h100 gSelectMode4, 🎯`n`nLegit-режим

; Rage-режим
Gui, Add, Button, vModeBtn5 x370 y260 w150 h100 gSelectMode5, 🔥`n`nRage-режим

; По биндам
Gui, Add, Button, vModeBtn6 x540 y260 w150 h100 gSelectMode6, ⌨️`n`nПо биндам

; Печать через нейросеть
Gui, Add, Button, vModeBtn7 x200 y380 w150 h100 gSelectMode7, 🤖`n`nНейросеть

; === ОПИСАНИЕ ВЫБРАННОГО РЕЖИМА ===
Gui, Add, GroupBox, x200 y490 w540 h240, 📝 Описание режима
Gui, Font, s11 Bold, Segoe UI
Gui, Add, Text, vModeDescTitle x210 y515 w520 h30 Center, 📝 Обычный текст
Gui, Font, s9 Normal, Segoe UI
Gui, Add, Text, vModeDescText x210 y555 w520 h160 Center, Печать обычного текста из основного поля.`n`nИспользуйте этот режим для простой печати`nзаранее подготовленного текста с настройками`nскорости, ошибок и других параметров.`n`nГорячие клавиши:`nF8 - Старт | F9 - Стоп | F10 - Пауза

; === ТЕКУЩИЙ АКТИВНЫЙ РЕЖИМ ===
Gui, Add, GroupBox, x200 y740 w540 h80, ⚙️ Текущий режим
Gui, Font, s10 Bold, Segoe UI
Gui, Add, Text, x210 y765, Активный режим:
Gui, Add, Text, vCurrentModeLabel x340 y765 w200 h25 c0066CC, Обычный текст
Gui, Add, Button, x550 y760 w180 h30 gOpenModeSettings, ⚙️ Открыть настройки

; === ВКЛАДКА СЛОВАРЬ ===
Gui, Tab, 19
; На предыдущей вкладке включался Bold для заголовков/карточек; сбрасываем, чтобы словарь не был жирным.
Gui, Font, s9 Normal, Segoe UI
Gui, Add, GroupBox, x200 y40 w260 h520, 📚 Словарь (локально в AutoTyper)
Gui, Add, Checkbox, vDictEnabled gDictGuiChanged x210 y60, Включить словарь (запоминает отправленное/введенное в AutoTyper)
Gui, Add, Checkbox, vDictCaptureSentMessages gDictGuiChanged x210 y85, Запоминать отправленные сообщения
Gui, Add, Checkbox, vDictCaptureOnStart gDictGuiChanged x210 y110, Запоминать TypeText при старте
Gui, Add, Checkbox, vDictCaptureTypeTextEdits gDictGuiChanged x210 y135, Запоминать ввод в TypeText (изменения)
Gui, Add, Text, x210 y160, Пауза фиксации (мс):
Gui, Add, Edit, vDictTypeTextDebounceMs gDictGuiChanged x335 y157 w60 Number, 800
Gui, Add, Text, x210 y185, Мин. длина (симв):
Gui, Add, Edit, vDictTypeTextMinChars gDictGuiChanged x325 y182 w70 Number, 1
Gui, Add, Checkbox, vDictCaptureGenerator gDictGuiChanged x210 y210, Запоминать генератор
Gui, Add, Checkbox, vDictStoreJsonl gDictGuiChanged x210 y235, Писать JSONL датасет (events.jsonl)
Gui, Add, Text, x210 y260, Лимит JSONL (МБ):
Gui, Add, Edit, vDictJsonlMaxMB gDictGuiChanged x325 y257 w70 Number, 50
Gui, Add, Checkbox, vDictAutosaveEnabled gDictGuiChanged x210 y285, Автосохранение summary JSON
Gui, Add, Text, x210 y307, Интервал (сек):
Gui, Add, Edit, vDictAutosaveIntervalSec gDictGuiChanged x300 y304 w60 Number, 10

Gui, Add, GroupBox, x200 y330 w260 h230, 🌲 Файлы словаря (TreeView)
Gui, Add, TreeView, vDictTree x210 y350 w240 h140 gDictTreeSelect
Gui, Add, Button, x210 y495 w115 h25 gDictRefreshTree, 🔄 Обновить
Gui, Add, Button, x335 y495 w115 h25 gDictSaveSnapshot, 💾 Снимок
Gui, Add, Button, x210 y525 w240 h25 gDictDeleteSelected, ❌ Удалить выбранное

Gui, Add, GroupBox, x470 y40 w270 h220, 👁️ Предпросмотр
Gui, Add, Edit, vDictPreview x480 y60 w250 h190 ReadOnly -Wrap VScroll

Gui, Add, GroupBox, x470 y270 w270 h290, ⚙️ Настройки словаря (50+)
Gui, Add, ListView, vDictSettingsTable gDictSettingsTableClick x480 y290 w250 h210 Grid, Настройка|Вкл|Значение
LV_ModifyCol(1, 140)
LV_ModifyCol(2, 35)
LV_ModifyCol(3, 70)
Gui, Add, Button, x480 y505 w80 h25 gDictSettingsRefresh, 🔄
Gui, Add, Button, x565 y505 w80 h25 gDictSettingsToggle, 🔁
Gui, Add, Button, x650 y505 w80 h25 gDictSettingsEdit, ✏️
Gui, Add, Button, x480 y535 w250 h25 gDictCreateTemplateFromDict, 📝 Создать шаблон из словаря

Gui, Add, GroupBox, x200 y570 w540 h170, 📦 Импорт/Экспорт (для датасета)
Gui, Add, Edit, vDictManualInput x210 y592 w520 h85 Multi VScroll
Gui, Add, Button, x210 y685 w130 h25 gDictManualAdd, ➕ Добавить
Gui, Add, Button, x345 y685 w130 h25 gDictAddFromClipboard, 📋 Из буфера
Gui, Add, Button, x480 y685 w130 h25 gDictImportFiles, 📂 Импорт файлов
Gui, Add, Button, x615 y685 w115 h25 gDictOpenFolder, 📁 Папка
Gui, Add, Checkbox, vDictClipboardSplitLines gDictGuiChanged x210 y715, Буфер: по строкам
Gui, Add, Checkbox, vDictImportSplitLines gDictGuiChanged x360 y715, Импорт: по строкам
	Gui, Add, Text, x510 y717, Макс. строк:
	Gui, Add, Edit, vDictImportMaxLines gDictGuiChanged x590 y714 w60 Number, 100000
	
	; === ВКЛАДКА ИНФОРМАЦИЯ ===
	Gui, Tab, 20
	Gui, Font, s9 Normal, Segoe UI
	Gui, Add, GroupBox, x200 y40 w540 h220, ℹ️ Информация
	Gui, Font, s10 Bold, Segoe UI
	Gui, Add, Text, x210 y70 w520 h25, Auto-Typer написан личностью: Кумаширо
	Gui, Font, s9 Normal, Segoe UI
	Gui, Add, Text, x210 y100 w520 h40 cGray, Канал Telegram: %TelegramChannelUrl%
	Gui, Add, Button, x210 y145 w200 h25 gOpenTelegramNow, 🔗 Открыть канал сейчас
	Gui, Add, Checkbox, vOpenTelegramOnStart x210 y180, Открывать канал при запуске (можно выключить)
	Gui, Add, Text, x210 y205 w520 h35 cGray, Если галочка включена, при запуске AutoTyper откроет вкладку браузера с каналом.
	
	; === ВКЛАДКА БАЗА ЗНАНИЙ ===
	Gui, Tab, 21
	Gui, Font, s9 Normal, Segoe UI
	Gui, Add, GroupBox, x200 y40 w190 h380, 📖 База знаний
	Gui, Add, Button, x210 y70 w170 h25 gKB_ShowTags, Метки
	Gui, Add, Button, x210 y105 w170 h25 gKB_ShowUsage, Использование
	Gui, Add, Button, x210 y140 w170 h25 gKB_ShowSpeed, Скорость печати
	Gui, Add, Button, x210 y175 w170 h25 gKB_ShowTemplates, Шаблоны
	Gui, Add, Button, x210 y210 w170 h25 gKB_ShowLimits, Ограничения
	Gui, Add, Button, x210 y245 w170 h25 gKB_ShowCycles, Циклы
	Gui, Add, Button, x210 y280 w170 h25 gKB_ShowBinds, Бинды
	
	Gui, Add, GroupBox, x400 y40 w340 h700, 📝 Статья
	Gui, Add, Edit, vKB_Content x410 y60 w320 h675 ReadOnly -Wrap VScroll

	; === ВКЛАДКА НЕЙРОСЕТЬ ===
	Gui, Tab, 22
	Gui, Font, s9 Normal, Segoe UI
	Gui, Add, GroupBox, x200 y40 w540 h120, 🤖 Нейросеть (OpenRouter)
	Gui, Add, Text, x210 y65, Модель:
	Gui, Add, Edit, vNeuroModelDisplay x260 y62 w470 h22 ReadOnly
	Gui, Add, Text, x210 y92, API ключ:
	Gui, Add, Text, x270 y92 w460 cGray, (встроен)
	Gui, Add, Text, x210 y115 w520 h30 cGray, Alt+Z: меню нейросети. Здесь нейросеть работает как чат (без автопечати).

	Gui, Add, GroupBox, x200 y170 w540 h200, 🧠 System Prompt
	Gui, Add, Edit, vNeuroSystemPrompt gNeuroSystemPromptChanged x210 y190 w520 h110 Multi VScroll
	Gui, Add, ListView, vNeuroSystemPresetsLV x210 y305 w390 h60 gNeuroSystemPresetsLVEvent AltSubmit -Multi, Preset
	LV_ModifyCol(1, 360)
	Gui, Add, Button, x610 y305 w120 h20 gNeuroSystemPresetSave, 💾 Сохранить
	Gui, Add, Button, x610 y330 w120 h20 gNeuroSystemPresetLoad, 📂 Загрузить
	Gui, Add, Button, x610 y355 w120 h20 gNeuroSystemPresetDelete, ❌ Удалить

	Gui, Add, GroupBox, x200 y380 w260 h300, 🌲 Presets (/presets)
	Gui, Add, TreeView, vNeuroPresetsTree x210 y400 w240 h240 gNeuroPresetsTreeSelect
	Gui, Add, Button, x210 y645 w110 h22 gNeuroPresetsRefresh, 🔄 Обновить
	Gui, Add, Button, x325 y645 w125 h22 gNeuroPresetInsertToSystem, ➕ В System

	Gui, Add, GroupBox, x470 y380 w270 h300, 👁️ Превью пресета
	Gui, Add, Edit, vNeuroPresetPreview x480 y400 w250 h240 ReadOnly -Wrap VScroll
	Gui, Add, Text, vNeuroPresetPath x480 y645 w250 h30 cGray, Путь: /

	Gui, Add, Checkbox, vNeuroUseTemplatesContext x210 y690 Checked, Контекст: использовать выбранные шаблоны (/presets)
	Gui, Add, Checkbox, vNeuroAllowEmptyPrompt x210 y712 Checked, Разрешить пустой запрос (генерация по контексту)
	Gui, Add, Text, x520 y692, Слов:
	Gui, Add, Edit, vNeuroGenWordCount x560 y689 w50 h20 Number Center, 0
	Gui, Add, Text, x615 y692 cGray, 0 = без лимита

	Gui, Add, GroupBox, x200 y725 w540 h130, 💬 Запрос
	Gui, Add, Edit, vNeuroUserPrompt x210 y745 w520 h75 Multi VScroll
	Gui, Add, Button, x210 y825 w110 h25 gNeuroSend, ▶ Отправить
	Gui, Add, Button, x325 y825 w120 h25 gNeuroGenerate, 🎲 Генерировать
	Gui, Add, Button, x450 y825 w90 h25 gNeuroClear, 🗑 Очистить
	Gui, Add, Button, x545 y825 w185 h25 gNeuroCopyLast, 📋 Копия ответа

	Gui, Add, GroupBox, x200 y865 w540 h140, 🧾 Ответ (превью)
	Gui, Add, Edit, vNeuroOutput x210 y885 w520 h110 ReadOnly -Wrap VScroll
 
	Gui, Tab
 
Gui, Font, s9 Normal, Segoe UI

; Скрытая переменная для хранения режима (для совместимости)
global TypingMode := "Обычный текст"
global CurrentModeIndex := 1

Gui, Add, StatusBar,, Готов к работе
SB_SetParts(200, 200, 200)

; Загрузка сохраненных настроек
IniRead, savedText, %appDataDir%\AutoTyper.ini, Data, Text
IniRead, savedSpeed, %appDataDir%\AutoTyper.ini, Data, Speed, 10
IniRead, savedSpeedType, %appDataDir%\AutoTyper.ini, Data, SpeedType, Букв в секунду
IniRead, savedSpeedMultiplier, %appDataDir%\AutoTyper.ini, Data, SpeedMultiplier, 1x
IniRead, savedRepeat, %appDataDir%\AutoTyper.ini, Data, Repeat, 1
IniRead, savedPrefix, %appDataDir%\AutoTyper.ini, Data, Prefix, [Bot]
IniRead, savedMidfix, %appDataDir%\AutoTyper.ini, Data, Midfix
IniRead, savedPostfix, %appDataDir%\AutoTyper.ini, Data, Postfix
IniRead, savedMaxWords, %appDataDir%\AutoTyper.ini, Data, MaxWords, 0
IniRead, savedGenLength, %appDataDir%\AutoTyper.ini, Data, GenLength, 30
IniRead, savedGenMode, %appDataDir%\AutoTyper.ini, Data, GenMode, Обычный текст
IniRead, savedTemplate, %appDataDir%\AutoTyper.ini, Generator, Template,
IniRead, savedGenMode2, %appDataDir%\AutoTyper.ini, Generator, Mode, Случайная строка
IniRead, savedGenLineCount, %appDataDir%\AutoTyper.ini, Generator, LineCount, 1
IniRead, savedGenByLines, %appDataDir%\AutoTyper.ini, Generator, ByLines, 0
IniRead, savedGenByWords, %appDataDir%\AutoTyper.ini, Generator, ByWords, 1
IniRead, savedGenWordCount, %appDataDir%\AutoTyper.ini, Generator, WordCount, 10
IniRead, savedGenCapitalize, %appDataDir%\AutoTyper.ini, Generator, Capitalize, 0
IniRead, savedGenPunctuation, %appDataDir%\AutoTyper.ini, Generator, Punctuation, 0
IniRead, savedGenTranslit, %appDataDir%\AutoTyper.ini, Generator, Translit, 0
IniRead, savedIgnoredWords, %appDataDir%\AutoTyper.ini, Generator, IgnoredWords,
IniRead, savedModelCapitalize, %appDataDir%\AutoTyper.ini, Model, Capitalize, 1
IniRead, savedModelPunctuation, %appDataDir%\AutoTyper.ini, Model, Punctuation, 1
IniRead, savedModelCommas, %appDataDir%\AutoTyper.ini, Model, Commas, 1
IniRead, savedErrorLevel, %appDataDir%\AutoTyper.ini, Settings, ErrorLevel, Нет
IniRead, savedReadability, %appDataDir%\AutoTyper.ini, Settings, Readability, Обычная читаемость
IniRead, savedTextCase, %appDataDir%\AutoTyper.ini, Settings, TextCase, Обычный
IniRead, savedCreativity, %appDataDir%\AutoTyper.ini, AI, Creativity, 50
IniRead, savedContextWindow, %appDataDir%\AutoTyper.ini, AI, ContextWindow, 10
IniRead, savedNeuroSystemPrompt, %appDataDir%\AutoTyper.ini, Neuro, SystemPrompt,
IniRead, savedNeuroUseTemplatesContext, %appDataDir%\AutoTyper.ini, Neuro, UseTemplatesContext, 1
IniRead, savedNeuroAllowEmptyPrompt, %appDataDir%\AutoTyper.ini, Neuro, AllowEmptyPrompt, 1
IniRead, savedNeuroGenWordCount, %appDataDir%\AutoTyper.ini, Neuro, GenWordCount, 0
IniRead, savedMessageDelay, %appDataDir%\AutoTyper.ini, Settings, MessageDelay, 1000
IniRead, savedAutoCorrect, %appDataDir%\AutoTyper.ini, Settings, AutoCorrect, Нет
IniRead, savedPrintTranslit, %appDataDir%\AutoTyper.ini, Settings, PrintTranslit, Выключено
IniRead, savedAutoSave, %appDataDir%\AutoTyper.ini, Settings, AutoSave, 1
IniRead, savedAutoBackup, %appDataDir%\AutoTyper.ini, Settings, AutoBackup, 0
IniRead, savedAutoEnterMode, %appDataDir%\AutoTyper.ini, AutoEnter, Mode, 1
IniRead, savedTimeInput, %appDataDir%\AutoTyper.ini, AutoEnter, TimeInput, 1000
IniRead, savedTimeUnit, %appDataDir%\AutoTyper.ini, AutoEnter, TimeUnit, мс
IniRead, savedAutoEnterInsertPerChunk, %appDataDir%\AutoTyper.ini, AutoEnter, InsertPerChunk, 0
IniRead, savedErrorGenLevel, %appDataDir%\AutoTyper.ini, ErrorGenerator, Level, 1
IniRead, savedCustomErrorCount, %appDataDir%\AutoTyper.ini, ErrorGenerator, CustomCount, 10
IniRead, savedErrorLocation, %appDataDir%\AutoTyper.ini, ErrorGenerator, Location, 1
IniRead, savedErrorWordsCount, %appDataDir%\AutoTyper.ini, ErrorGenerator, WordsCount, 1
IniRead, savedErrorWordsCustom, %appDataDir%\AutoTyper.ini, ErrorGenerator, WordsCustom, 1
; savedErrorShuffleLevel removed — shuffler settings moved to main shuffler tab
IniRead, savedTextShuffle, %appDataDir%\AutoTyper.ini, Settings, TextShuffle, Отключено
IniRead, savedShuffleRandom, %appDataDir%\AutoTyper.ini, Settings, ShuffleRandom, Выключено
IniRead, savedShuffleLowProb, %appDataDir%\AutoTyper.ini, Settings, ShuffleLowProb, Обычно
IniRead, savedShuffleMediumBehavior, %appDataDir%\AutoTyper.ini, Settings, ShuffleMediumBehavior, Влево
IniRead, savedShuffleHighSuffixProb, %appDataDir%\AutoTyper.ini, Settings, ShuffleHighSuffixProb, Обычно
IniRead, savedShuffleHighSuffixCount, %appDataDir%\AutoTyper.ini, Settings, ShuffleHighSuffixCount, 1
IniRead, savedShuffleExtremeMode, %appDataDir%\AutoTyper.ini, Settings, ShuffleExtremeMode, Реверс
IniRead, savedSplitCustomList, %appDataDir%\AutoTyper.ini, Split, CustomList,
IniRead, savedSplitSize, %appDataDir%\AutoTyper.ini, Split, Size, 1
IniRead, savedSplitSource, %appDataDir%\AutoTyper.ini, Split, Source, Основной текст
IniRead, savedSplitManualInput, %appDataDir%\AutoTyper.ini, Split, Manual, 
IniRead, savedRecordFileName, %appDataDir%\AutoTyper.ini, Recording, FileName, recorded_text
IniRead, savedRecordFolder, %appDataDir%\AutoTyper.ini, Recording, Folder, %appDataDir%\records
IniRead, savedRecordIncludeTimestamps, %appDataDir%\AutoTyper.ini, Recording, IncludeTimestamps, 0
IniRead, savedRecordAutoSave, %appDataDir%\AutoTyper.ini, Recording, AutoSave, 0
IniRead, savedRecordRemoveDuplicates, %appDataDir%\AutoTyper.ini, Recording, RemoveDuplicates, 0
IniRead, savedRecordMaxChars, %appDataDir%\AutoTyper.ini, Recording, MaxChars, 10000
; Загрузка сохраненных настроек задержек
IniRead, savedMainDelayMode, %appDataDir%\AutoTyper.ini, Delays, MainDelayMode, Отсутствует
IniRead, savedMainDelayValue, %appDataDir%\AutoTyper.ini, Delays, MainDelayValue, 0
IniRead, savedPlaybackDelayMode, %appDataDir%\AutoTyper.ini, Delays, PlaybackDelayMode, Отсутствует
IniRead, savedPlaybackDelayValue, %appDataDir%\AutoTyper.ini, Delays, PlaybackDelayValue, 0
IniRead, savedPlaybackRepeats, %appDataDir%\AutoTyper.ini, Playback, Repeats, 1
IniRead, savedNoRepeatText, %appDataDir%\AutoTyper.ini, Data, NoRepeatText, 0
IniRead, savedStartPosition, %appDataDir%\AutoTyper.ini, Data, StartPosition, С начала
IniRead, savedPrintLimitType, %appDataDir%\AutoTyper.ini, Data, PrintLimitType, 1
IniRead, savedPrintWordLimit, %appDataDir%\AutoTyper.ini, Data, PrintWordLimit, 150
IniRead, savedPrintLineLimit, %appDataDir%\AutoTyper.ini, Data, PrintLineLimit, 5
IniRead, savedPrintTimeLimit, %appDataDir%\AutoTyper.ini, Data, PrintTimeLimit, 1
IniRead, savedPrintTimeUnit, %appDataDir%\AutoTyper.ini, Data, PrintTimeUnit, Секунда
IniRead, savedPrintLimitCyclesEnabled, %appDataDir%\AutoTyper.ini, Data, PrintLimitCyclesEnabled, 0
IniRead, savedRandomLineBiasEnabled, %appDataDir%\AutoTyper.ini, Data, RandomLineBiasEnabled, 0
IniRead, savedRandomLineChanceTop, %appDataDir%\AutoTyper.ini, Data, RandomLineChanceTop, 25
IniRead, savedRandomLineChanceMiddle, %appDataDir%\AutoTyper.ini, Data, RandomLineChanceMiddle, 25
IniRead, savedRandomLineChanceBottom, %appDataDir%\AutoTyper.ini, Data, RandomLineChanceBottom, 25
IniRead, savedRandomLineChanceRandom, %appDataDir%\AutoTyper.ini, Data, RandomLineChanceRandom, 25
IniRead, savedOpenTelegramOnStart, %appDataDir%\AutoTyper.ini, Help, OpenTelegramOnStart, 1
IniRead, savedControlStartHotkey, %appDataDir%\AutoTyper.ini, ControlHotkeys, Start, F8
IniRead, savedControlStopHotkey, %appDataDir%\AutoTyper.ini, ControlHotkeys, Stop, F9
IniRead, savedControlPauseHotkey, %appDataDir%\AutoTyper.ini, ControlHotkeys, Pause, F10
IniRead, savedControlEmergencyHotkey, %appDataDir%\AutoTyper.ini, ControlHotkeys, Emergency, F12
IniRead, savedSlotsRepeatCount, %appDataDir%\AutoTyper.ini, Slots, RepeatCount, 1
IniRead, savedSlotsErrorLevel, %appDataDir%\AutoTyper.ini, Slots, ErrorLevel, Нет
IniRead, savedSlotsCapitalizeFirst, %appDataDir%\AutoTyper.ini, Slots, CapitalizeFirst, 0
IniRead, savedSlotsPrintTranslit, %appDataDir%\AutoTyper.ini, Slots, PrintTranslit, Выключено
IniRead, savedSlotsStartPosition, %appDataDir%\AutoTyper.ini, Slots, StartPosition, С начала
IniRead, savedClipboardDelayValue, %appDataDir%\AutoTyper.ini, Clipboard, DelayValue, 0
IniRead, savedClipboardDelayUnit, %appDataDir%\AutoTyper.ini, Clipboard, DelayUnit, мс

; === Speed engine / acceleration (реальная логика) ===
IniRead, savedSpeedSendEngine, %appDataDir%\AutoTyper.ini, SpeedEngine, SendEngine, SendInput
IniRead, savedSpeedClipboardEngine, %appDataDir%\AutoTyper.ini, SpeedEngine, ClipboardEngine, SendInput
IniRead, savedBurstWordsStr, %appDataDir%\AutoTyper.ini, SpeedSettings, BurstWords,
IniRead, savedArrhythmiaEnabled, %appDataDir%\AutoTyper.ini, SpeedSettings, ArrhythmiaEnabled, 0
IniRead, savedArrhythmiaIntensity, %appDataDir%\AutoTyper.ini, SpeedSettings, ArrhythmiaIntensity, 30
IniRead, savedSmoothnessEnabled, %appDataDir%\AutoTyper.ini, SpeedSettings, SmoothnessEnabled, 0
IniRead, savedSmoothnessLevel, %appDataDir%\AutoTyper.ini, SpeedSettings, SmoothnessLevel, 50
IniRead, savedAccuracyLevel, %appDataDir%\AutoTyper.ini, SpeedSettings, AccuracyLevel, 95
IniRead, savedErrorPercent, %appDataDir%\AutoTyper.ini, SpeedSettings, ErrorPercent, 5
IniRead, savedConsistencyLevel, %appDataDir%\AutoTyper.ini, SpeedSettings, ConsistencyLevel, 80

; === Словарь (Dictionary) ===
IniRead, savedDictEnabled, %appDataDir%\AutoTyper.ini, Dictionary, Enabled, 1
IniRead, savedDictCaptureOnStart, %appDataDir%\AutoTyper.ini, Dictionary, CaptureOnStart, 1
IniRead, savedDictCaptureTypeTextEdits, %appDataDir%\AutoTyper.ini, Dictionary, CaptureTypeTextEdits, 1
IniRead, savedDictTypeTextDebounceMs, %appDataDir%\AutoTyper.ini, Dictionary, TypeTextDebounceMs, 800
IniRead, savedDictTypeTextMinChars, %appDataDir%\AutoTyper.ini, Dictionary, TypeTextMinChars, 1
IniRead, savedDictCaptureSentMessages, %appDataDir%\AutoTyper.ini, Dictionary, CaptureSentMessages, 1
IniRead, savedDictCaptureGenerator, %appDataDir%\AutoTyper.ini, Dictionary, CaptureGenerator, 1
IniRead, savedDictStoreJsonl, %appDataDir%\AutoTyper.ini, Dictionary, StoreJsonl, 1
IniRead, savedDictJsonlMaxMB, %appDataDir%\AutoTyper.ini, Dictionary, JsonlMaxMB, 50
IniRead, savedDictClipboardSplitLines, %appDataDir%\AutoTyper.ini, Dictionary, ClipboardSplitLines, 1
IniRead, savedDictImportMaxLines, %appDataDir%\AutoTyper.ini, Dictionary, ImportMaxLines, 100000
IniRead, savedDictImportSplitLines, %appDataDir%\AutoTyper.ini, Dictionary, ImportSplitLines, 1
IniRead, savedDictAutosaveEnabled, %appDataDir%\AutoTyper.ini, Dictionary, AutosaveEnabled, 1
IniRead, savedDictAutosaveIntervalSec, %appDataDir%\AutoTyper.ini, Dictionary, AutosaveIntervalSec, 10
dictEnabled := savedDictEnabled
dictCaptureOnStart := savedDictCaptureOnStart
dictCaptureTypeTextEdits := savedDictCaptureTypeTextEdits
dictTypeTextDebounceMs := savedDictTypeTextDebounceMs + 0
dictTypeTextMinChars := savedDictTypeTextMinChars + 0
dictCaptureSentMessages := savedDictCaptureSentMessages
dictCaptureGenerator := savedDictCaptureGenerator
dictStoreJsonl := savedDictStoreJsonl
dictJsonlMaxMB := savedDictJsonlMaxMB + 0
dictClipboardSplitLines := savedDictClipboardSplitLines
dictImportMaxLines := savedDictImportMaxLines + 0
dictImportSplitLines := savedDictImportSplitLines
dictAutosaveEnabled := savedDictAutosaveEnabled
dictAutosaveIntervalSec := savedDictAutosaveIntervalSec + 0

; Миграция (1 раз): по запросу включаем локальное запоминание всего ввода TypeText (минимум 1 символ).
; Не является кейлоггером: фиксирует только текст, который пользователь вводит в поле TypeText внутри AutoTyper.
iniPath := appDataDir . "\AutoTyper.ini"
IniRead, dictMigratedCaptureAll, %iniPath%, Dictionary, MigratedCaptureAll, 0
if (!dictMigratedCaptureAll) {
    dictCaptureTypeTextEdits := 1
    if (dictTypeTextMinChars < 1)
        dictTypeTextMinChars := 1
    IniWrite, 1, %iniPath%, Dictionary, MigratedCaptureAll
    IniWrite, %dictCaptureTypeTextEdits%, %iniPath%, Dictionary, CaptureTypeTextEdits
    IniWrite, %dictTypeTextMinChars%, %iniPath%, Dictionary, TypeTextMinChars
}

; === Загрузка сохранённого ключа лицензии ===
IniRead, savedLicenseKey, %appDataDir%\AutoTyper.ini, %LicenseIniSection%, Key

if (savedLicenseKey != "") {
    LicenseKeyLocal := savedLicenseKey
    Gosub, ValidateLicense
}


GuiControl,, MainDelayMode, %savedMainDelayMode%
GuiControl,, MainDelayValue, %savedMainDelayValue%
GuiControl,, MainDelayMode, %savedMainDelayMode%
GuiControl,, MainDelayValue, %savedMainDelayValue%
GuiControl,, MainDelayMin, %savedMainDelayMin%
GuiControl,, MainDelayMax, %savedMainDelayMax%
GuiControl,, PlaybackDelayMode, %savedPlaybackDelayMode%
GuiControl,, PlaybackDelayValue, %savedPlaybackDelayValue%
GuiControl,, PlaybackDelayMin, %savedPlaybackDelayMin%
GuiControl,, PlaybackDelayMax, %savedPlaybackDelayMax%
GuiControl,, TypeText, %savedText%
GuiControl,, SpeedInput, %savedSpeed%
GuiControl, ChooseString, SpeedType, %savedSpeedType%
GuiControl, ChooseString, SpeedMultiplier, %savedSpeedMultiplier%
clipboardDelayValue := savedClipboardDelayValue
clipboardDelayUnit := savedClipboardDelayUnit
GuiControl,, ClipboardDelayInput, %clipboardDelayValue%
GuiControl, ChooseString, ClipboardDelayUnit, %clipboardDelayUnit%
Gosub, UpdateSpeedType

; Apply speed engine settings + load 150+ advanced params
SpeedSendEngine := savedSpeedSendEngine
SpeedClipboardEngine := savedSpeedClipboardEngine
SpeedCfgInit()

; Burst/arrhythmia/smoothness (used by typing engine)
global speedBurstWords, arrhythmiaEnabled, arrhythmiaIntensity, smoothnessEnabled, smoothnessLevel
global accuracyLevel, errorPercent, consistencyLevel
speedBurstWords := []
if (savedBurstWordsStr != "" && savedBurstWordsStr != "ERROR") {
    tmpArr := StrSplit(savedBurstWordsStr, "|")
    for i, w in tmpArr {
        w := Trim(w)
        if (w != "")
            speedBurstWords.Push(w)
    }
}
arrhythmiaEnabled := savedArrhythmiaEnabled ? true : false
arrhythmiaIntensity := savedArrhythmiaIntensity + 0
smoothnessEnabled := savedSmoothnessEnabled ? true : false
smoothnessLevel := savedSmoothnessLevel + 0
accuracyLevel := savedAccuracyLevel + 0
errorPercent := savedErrorPercent + 0
consistencyLevel := savedConsistencyLevel + 0
GuiControl,, RepeatInput, %savedRepeat%
GuiControl,, PrefixInput, %savedPrefix%
GuiControl,, MidfixInput, %savedMidfix%
GuiControl,, PostfixInput, %savedPostfix%
GuiControl,, MaxWordsInput, %savedMaxWords%
GuiControl,, GenerateLength, %savedGenLength%
GuiControl,, ModelCapitalize, %savedModelCapitalize%
GuiControl,, ModelPunctuation, %savedModelPunctuation%
GuiControl,, ModelCommas, %savedModelCommas%
GuiControl,, ErrorLevelSetting, %savedErrorLevel%
GuiControl, ChooseString, Readability, %savedReadability%
GuiControl,, TextCase, %savedTextCase%
GuiControl,, CreativityLevel, %savedCreativity%
GuiControl,, ContextWindow, %savedContextWindow%
; Нейросеть (модель/ключ фиксированы)
GuiControl,, NeuroModelDisplay, %NeuroModel%
GuiControl,, NeuroSystemPrompt, %savedNeuroSystemPrompt%
GuiControl,, NeuroUseTemplatesContext, %savedNeuroUseTemplatesContext%
GuiControl,, NeuroAllowEmptyPrompt, %savedNeuroAllowEmptyPrompt%
GuiControl,, NeuroGenWordCount, %savedNeuroGenWordCount%
GuiControl,, MessageDelay, %savedMessageDelay%
; LineSeparator control removed — no GUI control to set
GuiControl,, LicenseURL, %LicenseURL%
if (LicenseValidated)
    GuiControl,, LicenseStatus, Активирована
else if (LicenseKeyLocal != "")
    GuiControl,, LicenseStatus, Проверка... (offline cached)
else
    GuiControl,, LicenseStatus, Не активирована

; Убрана отложенная проверка лицензии — проверка выполняется при старте до создания GUI
GuiControl,, AutoCorrect, %savedAutoCorrect%
GuiControl, ChooseString, PrintTranslit, %savedPrintTranslit%
GuiControl,, AutoSave, %savedAutoSave%
GuiControl,, AutoBackup, %savedAutoBackup%
GuiControl,, TimeInput, %savedTimeInput%
GuiControl, ChooseString, TimeUnit, %savedTimeUnit%
GuiControl,, AutoEnterMode, %savedAutoEnterMode%
GuiControl,, ErrorGenLevel, %savedErrorGenLevel%
GuiControl,, CustomErrorCount, %savedCustomErrorCount%
GuiControl,, ErrorLocation, %savedErrorLocation%
GuiControl, ChooseString, ErrorWordsCount, %savedErrorWordsCount%
GuiControl,, ErrorWordsCustom, %savedErrorWordsCustom%
GuiControl,, AutoEnterInsertPerChunk, %savedAutoEnterInsertPerChunk%
; ErrorShuffleLevel GUI control removed
GuiControl,, TextShuffleLevel, %savedTextShuffle%
GuiControl, ChooseString, ShuffleRandomMode, %savedShuffleRandom%
GuiControl, ChooseString, ShuffleLowProb, %savedShuffleLowProb%
GuiControl, ChooseString, ShuffleMediumBehavior, %savedShuffleMediumBehavior%
GuiControl, ChooseString, ShuffleHighSuffixProb, %savedShuffleHighSuffixProb%
GuiControl, ChooseString, ShuffleHighSuffixCount, %savedShuffleHighSuffixCount%
GuiControl, ChooseString, ShuffleExtremeMode, %savedShuffleExtremeMode%
GuiControl, ChooseString, SplitSize, %savedSplitSize%
GuiControl, ChooseString, SplitSource, %savedSplitSource%
GuiControl,, SplitManualInput, %savedSplitManualInput%
; Загружаем настройки разделителя текста
if (savedTextSplitterMethod = 1) {
    GuiControl,, SplitMethodChars, 1
} else if (savedTextSplitterMethod = 2) {
    GuiControl,, SplitMethodParagraphs, 1
} else if (savedTextSplitterMethod = 3) {
    GuiControl,, SplitMethodCustom, 1
    GuiControl, Show, SplitCustomDelimiter
}
GuiControl,, SplitCharLimitSlider, %savedTextSplitterCharLimit%
GuiControl,, SplitCharLimitInput, %savedTextSplitterCharLimit%
GuiControl,, SplitCharLimit, %savedTextSplitterCharLimit%
GuiControl,, SplitCustomDelimiter, %savedTextSplitterDelimiter%
GuiControl,, RecordFileName, %savedRecordFileName%
GuiControl,, RecordFolder, %savedRecordFolder%
GuiControl,, RecordIncludeTimestamps, %savedRecordIncludeTimestamps%
GuiControl,, RecordAutoSave, %savedRecordAutoSave%
GuiControl,, RecordRemoveDuplicates, %savedRecordRemoveDuplicates%
GuiControl,, RecordMaxChars, %savedRecordMaxChars%
GuiControl, ChooseString, TypingMode, %savedGenMode%
; Загружаем выбранные шаблоны в ListView
Gui, 1:Default
Gui, ListView, TemplateList
Loop, Parse, savedTemplate, |
{
    tName := A_LoopField
    Loop % LV_GetCount()
    {
        LV_GetText(name, A_Index)
        if (name = tName) {
            LV_Modify(A_Index, "Check")
            break
        }
    }
}
GuiControl, ChooseString, GenerationMode, %savedGenMode2%
GuiControl,, GenLineCount, %savedGenLineCount%
GenByLines := savedGenByLines
GenByWords := savedGenByWords
if (savedGenByWords) {
    GuiControl, ChooseString, GenGenerationMode, По словам
    GuiControl,, GenCountValue, %savedGenWordCount%
} else {
    GuiControl, ChooseString, GenGenerationMode, По строкам
    GuiControl,, GenCountValue, %savedGenLineCount%
}
GuiControl,, GenWordCount, %savedGenWordCount%
GuiControl,, GenCapitalize, %savedGenCapitalize%
GuiControl,, GenPunctuation, %savedGenPunctuation%
GuiControl,, GenTranslit, %savedGenTranslit%
; Загружаем игнорируемые слова
ignoredWords := []
if (savedIgnoredWords != "") {
    Loop, Parse, savedIgnoredWords, `,
    {
        word := Trim(A_LoopField)
        if (word != "")
            ignoredWords.Push(word)
    }
}
UpdateIgnoredWordsList()

; Загружаем собственные слова
IniRead, savedCustomWords, %appDataDir%\AutoTyper.ini, Generator, CustomWords,
customWords := []
if (savedCustomWords != "") {
    Loop, Parse, savedCustomWords, |
    {
        item := Trim(A_LoopField)
        if (item != "") {
            ; Разделяем слово и статус
            parts := StrSplit(item, ":")
            if (parts.Length() = 2) {
                word := parts[1]
                enabled := (parts[2] = "1") ? true : false
                customWords.Push({word: word, enabled: enabled})
            }
        }
    }
}
UpdateCustomWordsList()

LoadSlots()
LoadSlotsTemplates()
LoadBinds()
LoadContextActions()

; Регистрируем системные горячие клавиши
try {
    Hotkey, !c, ShowContextMenu, On
} catch e {
    ; Если не удалось зарегистрировать, значит клавиша занята биндом
}

; Горячая клавиша Alt+X уже определена в коде напрямую (не нужно регистрировать через Hotkey)

; Загружаем настройки слотов
slotsRepeatCount := savedSlotsRepeatCount
slotsErrorLevel := savedSlotsErrorLevel
slotsCapitalizeFirst := savedSlotsCapitalizeFirst
slotsPrintTranslit := savedSlotsPrintTranslit
slotsStartPosition := savedSlotsStartPosition
; Обновляем видимость полей в зависимости от выбранного режима
Gosub, UpdateGenType
GuiControl, ChooseString, PlaybackRepeats, %savedPlaybackRepeats%
GuiControl,, NoRepeatText, %savedNoRepeatText%
GuiControl, ChooseString, StartPosition, %savedStartPosition%
PrintLimitType := savedPrintLimitType
PrintWordLimit := savedPrintWordLimit
PrintLineLimit := savedPrintLineLimit
PrintTimeLimit := savedPrintTimeLimit
PrintTimeUnit := savedPrintTimeUnit
PrintLimitCyclesEnabled := savedPrintLimitCyclesEnabled

RandomLineBiasEnabled := savedRandomLineBiasEnabled
RandomLineChanceTop := savedRandomLineChanceTop + 0
	RandomLineChanceMiddle := savedRandomLineChanceMiddle + 0
	RandomLineChanceBottom := savedRandomLineChanceBottom + 0
	RandomLineChanceRandom := savedRandomLineChanceRandom + 0

	; Справка / автозапуск Telegram
	OpenTelegramOnStart := savedOpenTelegramOnStart ? 1 : 0
	GuiControl,, OpenTelegramOnStart, %OpenTelegramOnStart%

	; Бинды управления (настраиваемые)
	ControlStartHotkey := savedControlStartHotkey
	ControlStopHotkey := savedControlStopHotkey
	ControlPauseHotkey := savedControlPauseHotkey
	ControlEmergencyHotkey := savedControlEmergencyHotkey
	if (!HotkeysAreValidUnique(ControlStartHotkey, ControlStopHotkey, ControlPauseHotkey, ControlEmergencyHotkey)) {
	    ControlStartHotkey := "F8"
	    ControlStopHotkey := "F9"
	    ControlPauseHotkey := "F10"
	    ControlEmergencyHotkey := "F12"
	}
	GuiControl,, ControlStartHotkey, %ControlStartHotkey%
	GuiControl,, ControlStopHotkey, %ControlStopHotkey%
	GuiControl,, ControlPauseHotkey, %ControlPauseHotkey%
	GuiControl,, ControlEmergencyHotkey, %ControlEmergencyHotkey%
	RegisterControlHotkeys()

	; База знаний: по умолчанию открываем "Использование"
	KB_SetSection("usage")

	GuiControl,, PrintWordLimit, %savedPrintWordLimit%
GuiControl,, PrintLineLimit, %savedPrintLineLimit%
GuiControl,, PrintTimeLimit, %savedPrintTimeLimit%
GuiControl, ChooseString, PrintTimeUnit, %savedPrintTimeUnit%
GuiControl,, PrintLimitCyclesEnabled, %savedPrintLimitCyclesEnabled%
; Применяем состояние чекбоксов
if (savedPrintLimitType = 1) {
    GuiControl,, PrintLimitNone, 1
    GuiControl,, PrintLimitWords, 0
    GuiControl,, PrintLimitLines, 0
    GuiControl,, PrintLimitTime, 0
    GuiControl, Disable, PrintWordLimit
    GuiControl, Disable, PrintLineLimit
} else if (savedPrintLimitType = 2) {
    GuiControl,, PrintLimitNone, 0
    GuiControl,, PrintLimitWords, 1
    GuiControl,, PrintLimitLines, 0
    GuiControl,, PrintLimitTime, 0
    GuiControl, Enable, PrintWordLimit
    GuiControl, Disable, PrintLineLimit
} else if (savedPrintLimitType = 3) {
    GuiControl,, PrintLimitNone, 0
    GuiControl,, PrintLimitWords, 0
    GuiControl,, PrintLimitLines, 1
    GuiControl,, PrintLimitTime, 0
    GuiControl, Disable, PrintWordLimit
    GuiControl, Enable, PrintLineLimit
} else if (savedPrintLimitType = 4) {
    GuiControl,, PrintLimitNone, 0
    GuiControl,, PrintLimitWords, 0
    GuiControl,, PrintLimitLines, 0
    GuiControl,, PrintLimitTime, 1
    GuiControl, Disable, PrintWordLimit
    GuiControl, Disable, PrintLineLimit
    GuiControl, Enable, PrintTimeLimit
    GuiControl, Enable, PrintTimeUnit
}
UpdatePrintLimitControlsState()
UpdatePrintLimitCyclesInfo()

; Multi-window feature removed — no target windows to load

; Создаем папку для записей если не существует
if (!FileExist(savedRecordFolder))
    FileCreateDir, %savedRecordFolder%

; Инициализация системы категорий
InitializeCategorySystem()
LoadCategories()
LoadTemplates()
LoadGenCategories()  ; Инициализация категорий генератора
LoadLetterReplacements()  ; Загружаем настройки замены букв
LoadLetterRestrictions()  ; Загружаем ограничения букв
; Загружаем настройки ошибок
LoadErrorSettings()
LoadAdvancedErrorSettingsFromIni()  ; Загружаем дополнительные настройки ошибок
LoadInserts()
; Загружаем новые данные
Gosub, LoadSettingsPresetsOnStart
Gosub, LoadLetterInsertsOnStart
Gosub, LoadBindTemplatesOnStart
Gosub, LoadPrintLimitCyclesOnStart
Gosub, LoadAutoEnterCyclesOnStart
Gosub, LoadAutoEnterBindsOnStart
Gosub, LoadInsertRulesOnStart
RefreshBindPresetsList()
Gosub, UpdateAutoEnterMode
Gosub, UpdateErrorGenLevel
Gosub, UpdateMainDelayMode
Gosub, UpdatePlaybackDelayMode

; Инициализация TreeView для основного текста и генератора
LoadMainTextTree()
LoadGenTextTree()
LoadOnlineTemplatesList()
LoadNeuroPresetsTree()
RefreshNeuroSystemPresetsList()

	; Инициализация кнопок режимов
	UpdateModeButtons()

	; === Инициализация словаря ===
	GuiControl,, DictEnabled, %dictEnabled%
	GuiControl,, DictCaptureOnStart, %dictCaptureOnStart%
	GuiControl,, DictCaptureTypeTextEdits, %dictCaptureTypeTextEdits%
	GuiControl,, DictTypeTextDebounceMs, %dictTypeTextDebounceMs%
	GuiControl,, DictTypeTextMinChars, %dictTypeTextMinChars%
	GuiControl,, DictCaptureSentMessages, %dictCaptureSentMessages%
	GuiControl,, DictCaptureGenerator, %dictCaptureGenerator%
	GuiControl,, DictStoreJsonl, %dictStoreJsonl%
	GuiControl,, DictJsonlMaxMB, %dictJsonlMaxMB%
	GuiControl,, DictAutosaveEnabled, %dictAutosaveEnabled%
	GuiControl,, DictAutosaveIntervalSec, %dictAutosaveIntervalSec%
	GuiControl,, DictClipboardSplitLines, %dictClipboardSplitLines%
	GuiControl,, DictImportSplitLines, %dictImportSplitLines%
	GuiControl,, DictImportMaxLines, %dictImportMaxLines%
	RefreshDictTree()
	RefreshDictSettingsTable()
	DictUpdateTimer()
	
		Gui, Show, w800 h1000, AutoTyper Pro v2.0
		; Открываем канал в браузере (если включено)
		SetTimer, OpenTelegramOnStartTimer, -750
		return

; === ОБРАБОТЧИКИ БОКОВОГО МЕНЮ ===
MenuText:
    GuiControl, Choose, MainTabs, 1
    UpdateMenuHighlight("MenuText")
return

MenuSlots:
    GuiControl, Choose, MainTabs, 2
    UpdateMenuHighlight("MenuSlots")
return

MenuRecord:
    GuiControl, Choose, MainTabs, 3
    UpdateMenuHighlight("MenuRecord")
return

MenuLegit:
    GuiControl, Choose, MainTabs, 4
    UpdateMenuHighlight("MenuLegit")
return

MenuLegitAdv:
    GuiControl, Choose, MainTabs, 5
    UpdateMenuHighlight("MenuLegitAdv")
return

MenuGenerator:
    GuiControl, Choose, MainTabs, 6
    UpdateMenuHighlight("MenuGenerator")
return

MenuGenSettings:
    GuiControl, Choose, MainTabs, 7
    UpdateMenuHighlight("MenuGenSettings")
return

MenuAutoEnter:
    GuiControl, Choose, MainTabs, 8
    UpdateMenuHighlight("MenuAutoEnter")
return

MenuErrors:
    GuiControl, Choose, MainTabs, 9
    UpdateMenuHighlight("MenuErrors")
return

MenuShuffle:
    GuiControl, Choose, MainTabs, 10
    UpdateMenuHighlight("MenuShuffle")
return

MenuSplitter:
    GuiControl, Choose, MainTabs, 11
    UpdateMenuHighlight("MenuSplitter")
return

MenuSettings:
    GuiControl, Choose, MainTabs, 13
    UpdateMenuHighlight("MenuSettings")
return

MenuConstructor:
    GuiControl, Choose, MainTabs, 14
    UpdateMenuHighlight("MenuConstructor")
return

MenuContextMenu:
    GuiControl, Choose, MainTabs, 15
    UpdateMenuHighlight("MenuContextMenu")
return

MenuRage:
    GuiControl, Choose, MainTabs, 16
    UpdateMenuHighlight("MenuRage")
return

MenuBinds:
    GuiControl, Choose, MainTabs, 17
    UpdateMenuHighlight("MenuBinds")
return

MenuModeSelect:
    GuiControl, Choose, MainTabs, 18
    UpdateMenuHighlight("MenuModeSelect")
return

MenuDictionary:
    GuiControl, Choose, MainTabs, 19
    UpdateMenuHighlight("MenuDictionary")
return

; ============================================
; === НЕЙРОСЕТЬ (OpenRouter) ===
; ============================================

NeuroPresetsRefresh:
    LoadNeuroPresetsTree()
    SB_SetText("Дерево нейросети обновлено", 1)
return

NeuroPresetsTreeSelect:
    global NeuroSelectedPresetText, NeuroSelectedPresetPath, neuroTreeItemData

    Gui, 1:Default
    Gui, 1:TreeView, NeuroPresetsTree

    if (A_GuiEvent != "DoubleClick" && A_GuiEvent != "Normal")
        return

    selectedItem := TV_GetSelection()
    if (!selectedItem)
        return

    meta := neuroTreeItemData[selectedItem]
    if (!IsObject(meta)) {
        if (A_GuiEvent = "DoubleClick")
            TV_Modify(selectedItem, "Expand")
        return
    }

    p := meta.path
    if (!FileExist(p))
        return

    if (meta.type = "dir") {
        content := NeuroBuildTemplatesContextFromDir(p, 12000)
        NeuroSelectedPresetText := content
        NeuroSelectedPresetPath := p
        GuiControl,, NeuroPresetPreview, %content%
        GuiControl,, NeuroPresetPath, Путь: %p% (папка)
    } else {
        FileRead, content, %p%
        NeuroSelectedPresetText := content
        NeuroSelectedPresetPath := p
        GuiControl,, NeuroPresetPreview, %content%
        GuiControl,, NeuroPresetPath, Путь: %p%
    }
return

NeuroPresetInsertToSystem:
    global NeuroSelectedPresetText, NeuroSelectedPresetPath
    Gui, 1:Submit, NoHide
    if (NeuroSelectedPresetText = "") {
        MsgBox, 48, Ошибка, Сначала выберите шаблон в TreeView (двойной клик).
        return
    }
    sp := NeuroSystemPrompt
    if (sp != "")
        sp .= "`n`n"
    sp .= "### Preset (" . NeuroSelectedPresetPath . ")`n" . NeuroSelectedPresetText
    GuiControl,, NeuroSystemPrompt, %sp%
    SB_SetText("Пресет добавлен в System Prompt", 1)
return

NeuroEffectiveSystemPrompt(baseSystemPrompt) {
    global NeuroUseTemplatesContext, NeuroSelectedPresetText, NeuroSelectedPresetPath
    sp := Trim(baseSystemPrompt, "`r`n`t ")
    if (NeuroUseTemplatesContext && NeuroSelectedPresetText != "") {
        if (sp != "")
            sp .= "`n`n"
        sp .= "## Контекст шаблонов (/presets)`n"
        sp .= "Источник: " . NeuroSelectedPresetPath . "`n`n"
        sp .= NeuroSelectedPresetText
    }
    return sp
}

NeuroEffectiveUserPrompt(userPrompt, forceGenerate := false) {
    global NeuroAllowEmptyPrompt, NeuroUseTemplatesContext, NeuroSelectedPresetText, NeuroSystemPrompt, NeuroGenWordCount
    up := Trim(userPrompt, "`r`n`t ")
    if (up != "")
        base := up
    if (!forceGenerate && !NeuroAllowEmptyPrompt)
        return ""
    hasTemplatesCtx := NeuroUseTemplatesContext && (NeuroSelectedPresetText != "")
    hasSystemCtx := Trim(NeuroSystemPrompt, "`r`n`t ") != ""
    if (!hasTemplatesCtx && !hasSystemCtx)
        return ""
    if (base = "")
        base := "Сгенерируй текст, используя доступный контекст (system prompt/шаблоны). Верни только готовый текст без пояснений."
    wc := NeuroGenWordCount + 0
    if (wc > 0) {
        base .= "`n`nВЫВОД: ровно " . wc . " слов. Никаких лишних слов, списков, кавычек, пояснений."
    }
    return base
}

NeuroClear:
    GuiControl,, NeuroUserPrompt,
    GuiControl,, NeuroOutput,
    SB_SetText("Поле запроса очищено", 1)
return

NeuroGenerate:
    ; Генерация без пользовательского промпта (по контексту).
    NeuroRunQuery("", true)
return

NeuroSystemPromptChanged:
    global neuroSystemPromptAutosaveMs
    ; Всегда сохраняем system prompt (независимо от AutoSave), с небольшим debounce.
    Gui, 1:Submit, NoHide
    SetTimer, NeuroSystemPromptAutosaveTimer, % "-" . neuroSystemPromptAutosaveMs
return

NeuroSystemPromptAutosaveTimer:
    global appDataDir, NeuroSystemPrompt
    iniPath := appDataDir . "\AutoTyper.ini"
    IniWrite, %NeuroSystemPrompt%, %iniPath%, Neuro, SystemPrompt
return

RefreshNeuroSystemPresetsList() {
    global NeuroSystemPresetsDir
    Gui, 1:Default
    Gui, ListView, NeuroSystemPresetsLV
    LV_Delete()
    if (!FileExist(NeuroSystemPresetsDir))
        FileCreateDir, %NeuroSystemPresetsDir%
    Loop, Files, %NeuroSystemPresetsDir%\*.txt
    {
        name := RegExReplace(A_LoopFileName, "\.txt$")
        LV_Add("", name)
    }
}

NeuroSystemPresetsLVEvent:
    if (A_GuiEvent = "DoubleClick")
        Gosub, NeuroSystemPresetLoad
return

NeuroSystemPresetSave:
    global NeuroSystemPresetsDir, NeuroSystemPrompt
    Gui, 1:Submit, NoHide
    InputBox, presetName, System Prompt Preset, Имя пресета:, , 360, 140
    if (ErrorLevel || presetName = "")
        return
    presetName := SanitizeFilename(presetName)
    if (presetName = "") {
        MsgBox, 48, Ошибка, Некорректное имя пресета.
        return
    }
    filePath := NeuroSystemPresetsDir . "\" . presetName . ".txt"
    FileDelete, %filePath%
    FileAppend, %NeuroSystemPrompt%, %filePath%, UTF-8
    RefreshNeuroSystemPresetsList()
    SB_SetText("System Prompt preset сохранен: " . presetName, 1)
return

NeuroSystemPresetLoad:
    global NeuroSystemPresetsDir
    Gui, 1:Default
    Gui, ListView, NeuroSystemPresetsLV
    row := LV_GetNext()
    if (!row) {
        MsgBox, 48, Ошибка, Выберите пресет в списке.
        return
    }
    LV_GetText(presetName, row, 1)
    filePath := NeuroSystemPresetsDir . "\" . presetName . ".txt"
    if (!FileExist(filePath)) {
        MsgBox, 48, Ошибка, Файл пресета не найден.
        return
    }
    FileRead, content, %filePath%
    GuiControl,, NeuroSystemPrompt, %content%
    SB_SetText("System Prompt preset загружен: " . presetName, 1)
return

NeuroSystemPresetDelete:
    global NeuroSystemPresetsDir
    Gui, 1:Default
    Gui, ListView, NeuroSystemPresetsLV
    row := LV_GetNext()
    if (!row) {
        MsgBox, 48, Ошибка, Выберите пресет в списке.
        return
    }
    LV_GetText(presetName, row, 1)
    MsgBox, 36, Подтверждение, Удалить пресет "%presetName%"?
    IfMsgBox, No
        return
    filePath := NeuroSystemPresetsDir . "\" . presetName . ".txt"
    FileDelete, %filePath%
    RefreshNeuroSystemPresetsList()
    SB_SetText("System Prompt preset удален: " . presetName, 1)
return

SanitizeFilename(name) {
    n := Trim(name, "`r`n`t ")
    ; Windows forbidden: \ / : * ? " < > |
    n := RegExReplace(n, "[\\/:\\*\\?\""<>\|]", "_")
    n := RegExReplace(n, "\s+", " ")
    n := Trim(n)
    return n
}

NeuroCopyLast:
    global NeuroLastResponse
    if (NeuroLastResponse = "") {
        GuiControlGet, tmp, , NeuroOutput
        if (tmp = "") {
            MsgBox, 48, Ошибка, Нет ответа для копирования.
            return
        }
        NeuroLastResponse := tmp
    }
    Clipboard := NeuroLastResponse
    SB_SetText("Ответ скопирован в буфер", 1)
return

NeuroSend:
    Gui, 1:Submit, NoHide

    if (NeuroUserPrompt = "") {
        MsgBox, 48, Ошибка, Введите запрос.
        return
    }

    NeuroRunQuery(NeuroUserPrompt, false)
return

LoadNeuroPresetsTree() {
    global presetDir, neuroTreeItemData

    Gui, 1:Default
    Gui, 1:TreeView, NeuroPresetsTree
    TV_Delete()

    neuroTreeItemData := {}

    Loop, Files, %presetDir%\*.*, D
    {
        categoryName := A_LoopFileName
        categoryItem := TV_Add(categoryName, 0, "Icon1")
        categoryPath := presetDir . "\" . categoryName
        neuroTreeItemData[categoryItem] := {type: "dir", name: categoryName, path: categoryPath}

        ; Шаблоны в корне категории
        Loop, Files, %categoryPath%\*.txt
        {
            templateName := StrReplace(A_LoopFileName, ".txt", "")
            filePath := categoryPath . "\" . A_LoopFileName
            itemID := TV_Add(templateName, categoryItem, "Icon3")
            neuroTreeItemData[itemID] := {type: "file", name: templateName, path: filePath}
        }

        ; Подкатегории
        Loop, Files, %categoryPath%\*.*, D
        {
            subcatName := A_LoopFileName
            subcatItem := TV_Add(subcatName, categoryItem, "Icon2")
            subcatPath := categoryPath . "\" . subcatName
            neuroTreeItemData[subcatItem] := {type: "dir", name: subcatName, path: subcatPath}

            Loop, Files, %subcatPath%\*.txt
            {
                templateName := StrReplace(A_LoopFileName, ".txt", "")
                filePath := subcatPath . "\" . A_LoopFileName
                itemID := TV_Add(templateName, subcatItem, "Icon3")
                neuroTreeItemData[itemID] := {type: "file", name: templateName, path: filePath}
            }
        }
    }
}

NeuroBuildTemplatesContextFromDir(dirPath, maxChars := 12000) {
    ; Собирает контекст из всех *.txt (рекурсивно), ограничивает общий размер.
    out := ""
    Loop, Files, %dirPath%\*.txt, R
    {
        filePath := A_LoopFileFullPath
        FileRead, content, %filePath%
        header := "### " . filePath . "`n"
        block := header . content . "`n`n"
        if (StrLen(out) + StrLen(block) > maxChars) {
            remain := maxChars - StrLen(out)
            if (remain > 0)
                out .= SubStr(block, 1, remain)
            break
        }
        out .= block
    }
    return out
}

NeuroRunQuery(userPrompt, forceGenerate := false) {
    global NeuroLastResponse, NeuroApiKey, NeuroModel, NeuroSystemPrompt, NeuroTabIndex, NeuroGenWordCount

    Gui, 1:Submit, NoHide

    if (NeuroApiKey = "") {
        MsgBox, 48, Ошибка, Укажите API ключ OpenRouter.
        return
    }

    SB_SetText("Нейросеть: запрос...", 1)
    effUser := NeuroEffectiveUserPrompt(userPrompt, forceGenerate)
    if (effUser = "") {
        MsgBox, 48, Ошибка, Введите запрос или включите "Разрешить пустой запрос" и выберите контекст в TreeView.
        return
    }
    effSys := NeuroEffectiveSystemPrompt(NeuroSystemPrompt)
    resp := NeuroOpenRouterChatCompletion(NeuroApiKey, NeuroModel, effSys, effUser)
    wc := NeuroGenWordCount + 0
    if (wc > 0) {
        if (NeuroCountWords(resp) < wc)
            resp := NeuroFixUpToWordCount(NeuroApiKey, NeuroModel, effSys, resp, wc)
        resp := NeuroTrimToWordCount(resp, wc)
    }
    NeuroLastResponse := resp

    GuiControl,, NeuroOutput, %NeuroLastResponse%
    SB_SetText(resp != "" ? "Нейросеть: готово" : "Нейросеть: ошибка", 1)

    ; Если вызвали из меню/в фоне — показываем окно без активации.
    Gui, 1:Show, NA
    GuiControl, Choose, MainTabs, %NeuroTabIndex%
    UpdateMenuHighlight("MenuNeuro")
}

NeuroOpenRouterChatCompletion(apiKey, model, systemPrompt, userPrompt) {
    global NeuroGenWordCount
    url := "https://openrouter.ai/api/v1/chat/completions"

    sys := Trim(systemPrompt, "`r`n`t ")
    usr := Trim(userPrompt, "`r`n`t ")

    if (sys != "") {
        msgs := "[{""role"":""system"",""content"":""" . JsonEscape(sys) . """},{""role"":""user"",""content"":""" . JsonEscape(usr) . """}]"
    } else {
        msgs := "[{""role"":""user"",""content"":""" . JsonEscape(usr) . """}]"
    }

    wc := NeuroGenWordCount + 0
    maxTokens := (wc > 0) ? (wc * 4) : 512
    if (maxTokens < 128)
        maxTokens := 128
    if (maxTokens > 2048)
        maxTokens := 2048
    json := "{""model"":""" . JsonEscape(model) . """,""stream"":false,""max_tokens"":" . maxTokens . ",""messages"":" . msgs . "}"

    try {
        http := ComObjCreate("WinHttp.WinHttpRequest.5.1")
        http.Open("POST", url, false)
        http.SetRequestHeader("Authorization", "Bearer " . apiKey)
        http.SetRequestHeader("Content-Type", "application/json")
        http.SetRequestHeader("HTTP-Referer", "http://localhost")
        http.SetRequestHeader("X-Title", "AutoTyper")
        http.Send(json)
    } catch e {
        MsgBox, 48, Ошибка, Не удалось отправить запрос в OpenRouter.
        return ""
    }

    st := http.Status + 0
    if (st < 200 || st >= 300) {
        body := HttpResponseTextUtf8(http)
        MsgBox, 48, Ошибка, OpenRouter вернул HTTP %st%.`n`n%body%
        return ""
    }

    body := HttpResponseTextUtf8(http)

    ; Берём content ассистента: choices[0].message.content
    if (RegExMatch(body, "s)""role""\s*:\s*""assistant"".*?""content""\s*:\s*""((?:\\.|[^""])*)""", m)) {
        return JsonUnescape(m1)
    }
    ; Фоллбек: первый встретившийся content
    if (RegExMatch(body, "s)""content""\s*:\s*""((?:\\.|[^""])*)""", m2)) {
        return JsonUnescape(m21)
    }

    MsgBox, 48, Ошибка, Не удалось распарсить ответ OpenRouter (content не найден).
    return ""
}

NeuroTrimToWordCount(text, wc) {
    wc := wc + 0
    if (wc <= 0)
        return text
    t := Trim(RegExReplace(text, "\s+", " "), "`r`n`t ")
    if (t = "")
        return ""
    words := StrSplit(t, " ")
    if (words.Length() <= wc)
        return t
    out := ""
    Loop, %wc% {
        out .= (out = "" ? "" : " ") . words[A_Index]
    }
    return out
}

NeuroCountWords(text) {
    t := Trim(RegExReplace(text, "\s+", " "), "`r`n`t ")
    if (t = "")
        return 0
    words := StrSplit(t, " ")
    return words.Length()
}

NeuroFixUpToWordCount(apiKey, model, systemPrompt, text, wc) {
    ; Если модель вернула меньше слов, пытаемся "дописать" до нужного количества (несколько попыток).
    wc := wc + 0
    if (wc <= 0)
        return text
    t := text
    Loop, 3 {
        cur := NeuroCountWords(t)
        if (cur >= wc)
            break
        need := wc - cur
        prompt := "Дополни текст до ровно " . wc . " слов (сейчас " . cur . "). Добавь еще " . need . " слов. Верни полный текст целиком, без пояснений.`n`nТекст:`n" . t
        t2 := NeuroOpenRouterChatCompletion(apiKey, model, systemPrompt, prompt)
        if (t2 = "")
            break
        t := t2
    }
    return t
}

NeuroRunQueryAndType(userPrompt) {
    global NeuroApiKey, NeuroModel, NeuroSystemPrompt, NeuroGenWordCount

    if (NeuroApiKey = "") {
        MsgBox, 48, Ошибка, API ключ не задан.
        return
    }

    ; Быстрый режим: минимальная обработка UI, печатаем результат как можно быстрее.
    effUser := NeuroEffectiveUserPrompt(userPrompt, false)
    if (effUser = "") {
        MsgBox, 48, Ошибка, Пустой запрос.
        return
    }
    effSys := NeuroEffectiveSystemPrompt(NeuroSystemPrompt)

    resp := NeuroOpenRouterChatCompletion(NeuroApiKey, NeuroModel, effSys, effUser)
    if (resp = "")
        return
    wc := NeuroGenWordCount + 0
    if (wc > 0) {
        if (NeuroCountWords(resp) < wc)
            resp := NeuroFixUpToWordCount(NeuroApiKey, NeuroModel, effSys, resp, wc)
        resp := NeuroTrimToWordCount(resp, wc)
    }

    NeuroTypeTextToActive(resp)
}

NeuroTypeTextToActive(text) {
    ; "Реальная печать" без буфера: быстро печатаем чанками через SendInput {Text}.
    ; Остановка: удерживайте F12.
    chunkSize := 12
    pos := 1
    len := StrLen(text)
    while (pos <= len) {
        if (GetKeyState("F12", "P"))
            break
        chunk := SubStr(text, pos, chunkSize)
        pos += chunkSize
        SendInput, {Text}%chunk%
        Sleep, 5
    }
}

HttpResponseTextUtf8(http) {
    ; WinHttp иногда неверно декодирует JSON как ANSI, если charset не указан.
    ; Берем bytes из ResponseBody и декодируем строго как UTF-8.
    try bytes := http.ResponseBody
    catch e
        return http.ResponseText

    stream := ComObjCreate("ADODB.Stream")
    stream.Type := 1 ; binary
    stream.Open()
    stream.Write(bytes)
    stream.Position := 0
    stream.Type := 2 ; text
    stream.Charset := "utf-8"
    text := stream.ReadText()
    stream.Close()
    return text
}

JsonUnescape(s) {
    ; Минимальный JSON-unescape для контента (\\uXXXX, \\n, \\r, \\t, \\\\, \\")
    out := ""
    i := 1
    len := StrLen(s)
    while (i <= len) {
        ch := SubStr(s, i, 1)
        if (ch != "\") {
            out .= ch
            i += 1
            continue
        }
        i += 1
        if (i > len) {
            out .= "\"
            break
        }
        esc := SubStr(s, i, 1)
        if (esc = """") {
            out .= """"
            i += 1
        } else if (esc = "\") {
            out .= "\"
            i += 1
        } else if (esc = "n") {
            out .= "`n"
            i += 1
        } else if (esc = "r") {
            out .= "`r"
            i += 1
        } else if (esc = "t") {
            out .= "`t"
            i += 1
        } else if (esc = "u") {
            hex := SubStr(s, i + 1, 4)
            if (RegExMatch(hex, "i)^[0-9a-f]{4}$")) {
                code := "0x" . hex
                out .= Chr(code)
                i += 5
            } else {
                ; неизвестный escape
                out .= "\u"
                i += 1
            }
        } else {
            ; неизвестный escape
            out .= esc
            i += 1
        }
    }
    return out
}

MenuInfo:
    GuiControl, Choose, MainTabs, 20
    UpdateMenuHighlight("MenuInfo")
return

MenuKnowledge:
    GuiControl, Choose, MainTabs, 21
    UpdateMenuHighlight("MenuKnowledge")
return

MenuNeuro:
    GuiControl, Choose, MainTabs, %NeuroTabIndex%
    UpdateMenuHighlight("MenuNeuro")
return

MenuOnline:
    GuiControl, Choose, MainTabs, 18
    UpdateMenuHighlight("MenuOnline")
return

; Функция подсветки активного пункта меню
UpdateMenuHighlight(activeMenu) {
    ; Список всех пунктов меню
    menuItems := ["MenuText", "MenuSlots", "MenuRecord", "MenuLegit", "MenuLegitAdv", "MenuGenerator", "MenuGenSettings", "MenuAutoEnter", "MenuErrors", "MenuShuffle", "MenuSplitter", "MenuSettings", "MenuRage", "MenuBinds", "MenuModeSelect", "MenuDictionary", "MenuInfo", "MenuKnowledge", "MenuNeuro"]
    
    labels := GetMenuLabels()
    
    For index, item in menuItems {
        label := labels[item]
        if (item = activeMenu) {
            GuiControl, +c0066CC, %item%
            newText := "⬤  " . label
            GuiControl,, %item%, %newText%
        } else {
            GuiControl, +cBlack, %item%
            newText := "     " . label
            GuiControl,, %item%, %newText%
        }
    }
}

GetMenuLabels() {
    labels := {}
    labels["MenuText"] := "Основной текст"
    labels["MenuSlots"] := "По слотам"
    labels["MenuRecord"] := "Запись текста"
    labels["MenuLegit"] := "Legit-режим"
    labels["MenuLegitAdv"] := "Доп. Legit"
    labels["MenuGenerator"] := "Генератор текста"
    labels["MenuGenSettings"] := "Доп. генератора"
    labels["MenuAutoEnter"] := "Auto-Enter"
    labels["MenuErrors"] := "Генератор ошибок"
    labels["MenuShuffle"] := "Перемешивание"
    labels["MenuSplitter"] := "Разделитель"
    labels["MenuSettings"] := "Основные"
    ; labels["MenuConstructor"] := "Конструктор"
    ; labels["MenuContextMenu"] := "Контекстное меню"
    labels["MenuRage"] := "Rage-режим"
    labels["MenuBinds"] := "По биндам"
    labels["MenuModeSelect"] := "Режим Печати"
    labels["MenuDictionary"] := "Словарь"
    labels["MenuInfo"] := "Информация"
    labels["MenuKnowledge"] := "База знаний"
    labels["MenuNeuro"] := "Нейросеть"
    return labels
}

; === ОБРАБОТЧИКИ КНОПОК РЕЖИМОВ ===
SelectMode1:
    global CurrentModeIndex, TypingMode
    CurrentModeIndex := 1
    TypingMode := "Обычный текст"
    UpdateModeButtons()
    GuiControl,, ModeDescTitle, 📝 Обычный текст
    GuiControl,, ModeDescText, Печать обычного текста из основного поля.`n`nИспользуйте этот режим для простой печати`nзаранее подготовленного текста с настройками`nскорости, ошибок и других параметров.
    GuiControl,, CurrentModeLabel, Обычный текст
return

SelectMode2:
    global CurrentModeIndex, TypingMode
    CurrentModeIndex := 2
    TypingMode := "Генератор текста"
    UpdateModeButtons()
    GuiControl,, ModeDescTitle, 🎲 Генератор текста
    GuiControl,, ModeDescText, Генерация случайного текста на основе шаблонов.`n`nИспользуйте этот режим для создания уникального`nтекста с помощью встроенного генератора`nна основе корпуса или AI-модели.
    GuiControl,, CurrentModeLabel, Генератор текста
return

SelectMode3:
    global CurrentModeIndex, TypingMode
    CurrentModeIndex := 3
    TypingMode := "По слотам"
    UpdateModeButtons()
    GuiControl,, ModeDescTitle, 📦 По слотам
    GuiControl,, ModeDescText, Печать текста по заранее настроенным слотам.`n`nИспользуйте этот режим для печати текста`nс индивидуальными настройками задержки`nи скорости для каждого фрагмента.
    GuiControl,, CurrentModeLabel, По слотам
return

SelectMode4:
    global CurrentModeIndex, TypingMode
    CurrentModeIndex := 4
    TypingMode := "Legit-режим"
    UpdateModeButtons()
    GuiControl,, ModeDescTitle, 🎯 Legit-режим
    GuiControl,, ModeDescText, Реалистичная человеческая печать с паузами.`n`nИспользуйте этот режим для имитации`nнатуральной печати с вариациями скорости,`nпаузами раздумья и естественными ошибками.
    GuiControl,, CurrentModeLabel, Legit-режим
return

SelectMode5:
    global CurrentModeIndex, TypingMode
    CurrentModeIndex := 5
    TypingMode := "Rage-режим"
    UpdateModeButtons()
    GuiControl,, ModeDescTitle, 🔥 Rage-режим
    GuiControl,, ModeDescText, Максимальная скорость печати без задержек.`n`nИспользуйте этот режим для мгновенной`nпечати текста с максимальной скоростью`nи минимальными задержками.
    GuiControl,, CurrentModeLabel, Rage-режим
return

SelectMode6:
    global CurrentModeIndex, TypingMode
    CurrentModeIndex := 6
    TypingMode := "По биндам"
    UpdateModeButtons()
    GuiControl,, ModeDescTitle, ⌨️ По биндам
    GuiControl,, ModeDescText, Печать текста по настроенным горячим клавишам.`n`nИспользуйте этот режим для быстрой печати`nзаранее подготовленных шаблонов текста`nпо нажатию определённых комбинаций клавиш.
    GuiControl,, CurrentModeLabel, По биндам
return

SelectMode7:
    global CurrentModeIndex, TypingMode
    CurrentModeIndex := 7
    TypingMode := "Печать через нейросеть"
    UpdateModeButtons()
    GuiControl,, ModeDescTitle, 🤖 Печать через нейросеть
    GuiControl,, ModeDescText, Генерация текста через OpenRouter и печать результата.`n`nИспользуйте вкладку "Нейросеть" для System Prompt и запроса.`n`nГорячие клавиши:`nF8 - Старт | F9 - Стоп | F10 - Пауза
    GuiControl,, CurrentModeLabel, Нейросеть
return

UpdateModeButtons() {
    global CurrentModeIndex
    
    ; Сбрасываем все кнопки на стандартный вид
    Loop, 7 {
        GuiControl, +Default, ModeBtn%A_Index%
    }
    
    ; Выделяем активную кнопку
    GuiControl, +Default, ModeBtn%CurrentModeIndex%
    
    return
}

; === ОБРАБОТЧИКИ КНОПОК ВКЛАДКИ "РЕЖИМ ПЕЧАТИ" ===
OpenModeSettings:
    global CurrentModeIndex
    ; Переключаемся на соответствующую вкладку настроек
    if (CurrentModeIndex = 1) {
        GuiControl, Choose, MainTabs, 1  ; Основной текст
        UpdateMenuHighlight("MenuText")
    } else if (CurrentModeIndex = 2) {
        GuiControl, Choose, MainTabs, 6  ; Генератор
        UpdateMenuHighlight("MenuGenerator")
    } else if (CurrentModeIndex = 3) {
        GuiControl, Choose, MainTabs, 2  ; Слоты
        UpdateMenuHighlight("MenuSlots")
    } else if (CurrentModeIndex = 4) {
        GuiControl, Choose, MainTabs, 4  ; Legit
        UpdateMenuHighlight("MenuLegit")
    } else if (CurrentModeIndex = 5) {
        GuiControl, Choose, MainTabs, 16  ; Rage
        UpdateMenuHighlight("MenuRage")
    } else if (CurrentModeIndex = 6) {
        GuiControl, Choose, MainTabs, 17  ; Бинды
        UpdateMenuHighlight("MenuBinds")
    } else if (CurrentModeIndex = 7) {
        GuiControl, Choose, MainTabs, %NeuroTabIndex%  ; Нейросеть
        UpdateMenuHighlight("MenuNeuro")
    }
return

; Обработчик изменения начальной позиции
StartPositionChanged:
    Gui, 1:Submit, NoHide
    if (StartPosition = "Начать со строки")
        Gosub, OpenStartLineDialog
return

; Обработчик изменения типа ограничения печати
; ═══════════════════════════════════════════════════════════════════════════════
; ОБРАБОТЧИК ИЗМЕНЕНИЯ ОГРАНИЧЕНИЯ ПЕЧАТИ (ЧЕКБОКСЫ)
; ═══════════════════════════════════════════════════════════════════════════════
PrintLimitChanged:
    Gui, 1:Submit, NoHide
    global PrintLimitType, PrintLimitNone, PrintLimitWords, PrintLimitLines, PrintLimitTime
    
    ; Определяем какой чекбокс был нажат и снимаем остальные
    if (A_GuiControl = "PrintLimitNone" && PrintLimitNone = 1) {
        ; Включен "Без ограничений" - снимаем остальные
        GuiControl, 1:, PrintLimitWords, 0
        GuiControl, 1:, PrintLimitLines, 0
        GuiControl, 1:, PrintLimitTime, 0
        PrintLimitType := 1
        GuiControl, 1:Disable, PrintWordLimit
        GuiControl, 1:Disable, PrintLineLimit
        GuiControl, 1:Disable, PrintTimeLimit
        GuiControl, 1:Disable, PrintTimeUnit
    }
    else if (A_GuiControl = "PrintLimitWords" && PrintLimitWords = 1) {
        ; Включен "По словам" - снимаем остальные
        GuiControl, 1:, PrintLimitNone, 0
        GuiControl, 1:, PrintLimitLines, 0
        GuiControl, 1:, PrintLimitTime, 0
        PrintLimitType := 2
        GuiControl, 1:Enable, PrintWordLimit
        GuiControl, 1:Disable, PrintLineLimit
        GuiControl, 1:Disable, PrintTimeLimit
        GuiControl, 1:Disable, PrintTimeUnit
    }
    else if (A_GuiControl = "PrintLimitLines" && PrintLimitLines = 1) {
        ; Включен "По строкам" - снимаем остальные
        GuiControl, 1:, PrintLimitNone, 0
        GuiControl, 1:, PrintLimitWords, 0
        GuiControl, 1:, PrintLimitTime, 0
        PrintLimitType := 3
        GuiControl, 1:Disable, PrintWordLimit
        GuiControl, 1:Enable, PrintLineLimit
        GuiControl, 1:Disable, PrintTimeLimit
        GuiControl, 1:Disable, PrintTimeUnit
    }
    else if (A_GuiControl = "PrintLimitTime" && PrintLimitTime = 1) {
        ; Включен "По времени" - снимаем остальные
        GuiControl, 1:, PrintLimitNone, 0
        GuiControl, 1:, PrintLimitWords, 0
        GuiControl, 1:, PrintLimitLines, 0
        PrintLimitType := 4
        GuiControl, 1:Disable, PrintWordLimit
        GuiControl, 1:Disable, PrintLineLimit
        GuiControl, 1:Enable, PrintTimeLimit
        GuiControl, 1:Enable, PrintTimeUnit
    }
    else {
        ; Если пытаются снять активный чекбокс - возвращаем его обратно
        if (PrintLimitType = 1)
            GuiControl, 1:, PrintLimitNone, 1
        else if (PrintLimitType = 2)
            GuiControl, 1:, PrintLimitWords, 1
        else if (PrintLimitType = 3)
            GuiControl, 1:, PrintLimitLines, 1
        else if (PrintLimitType = 4)
            GuiControl, 1:, PrintLimitTime, 1
    }
return


; ==============================================================================
; === Ограничение печати: время + циклы
; ==============================================================================

PrintLimitTimeToMs(value, unit) {
    v := value + 0
    if (v <= 0)
        return 0
    if (unit = "Миллисекунда" || unit = "мс" || unit = "ms")
        return v
    if (unit = "Секунда" || unit = "сек" || unit = "s")
        return v * 1000
    if (unit = "Минута" || unit = "мин" || unit = "m")
        return v * 60000
    ; неизвестная единица: считаем миллисекундами
    return v
}

PrintLimitCycleLimitText(item) {
    if (!IsObject(item))
        return ""
    t := item.type
    v := item.value + 0
    if (t = "words")
        return v . " слов"
    if (t = "lines")
        return v . " строк"
    if (t = "time") {
        u := item.unit
        if (u = "")
            u := "Секунда"
        short := (u = "Миллисекунда") ? "мс" : (u = "Секунда") ? "сек" : (u = "Минута") ? "мин" : u
        return v . " " . short
    }
    return v
}

PrintLimitCycles_RebuildListView(selectRow := 0) {
    global printLimitCycles
    
    Gui, 1:Default
    Gui, 1:ListView, PrintLimitCyclesList
    LV_Delete()
    
    if (!IsObject(printLimitCycles))
        printLimitCycles := []
    
    for i, item in printLimitCycles {
        tRu := (item.type = "words") ? "Слова" : (item.type = "lines") ? "Строки" : (item.type = "time") ? "Время" : "?"
        lim := PrintLimitCycleLimitText(item)
        LV_Add("", i, tRu, lim)
    }
    
    if (selectRow > 0)
        LV_Modify(selectRow, "Select Focus Vis")
}

UpdatePrintLimitCyclesInfo() {
    global PrintLimitCyclesEnabled, printLimitCycles
    
    cnt := (IsObject(printLimitCycles)) ? printLimitCycles.Length() : 0
    state := PrintLimitCyclesEnabled ? "вкл" : "выкл"
    
    if (cnt = 0) {
        GuiControl, 1:, PrintLimitCyclesInfo, % "Циклы: " . state . " | нет циклов"
        return
    }
    
    info := "Циклы: " . state . " | " . cnt . " шт.: "
    maxShow := Min(6, cnt)
    Loop, %maxShow% {
        item := printLimitCycles[A_Index]
        info .= A_Index . ") " . PrintLimitCycleLimitText(item)
        if (A_Index < maxShow)
            info .= "  |  "
    }
    if (cnt > maxShow)
        info .= "  |  ..."
    
    GuiControl, 1:, PrintLimitCyclesInfo, %info%
}

UpdatePrintLimitControlsState() {
    global PrintLimitCyclesEnabled, PrintLimitType
    
    if (PrintLimitCyclesEnabled) {
        GuiControl, 1:Disable, PrintLimitNone
        GuiControl, 1:Disable, PrintLimitWords
        GuiControl, 1:Disable, PrintLimitLines
        GuiControl, 1:Disable, PrintLimitTime
        GuiControl, 1:Disable, PrintWordLimit
        GuiControl, 1:Disable, PrintLineLimit
        GuiControl, 1:Disable, PrintTimeLimit
        GuiControl, 1:Disable, PrintTimeUnit
        return
    }
    
    GuiControl, 1:Enable, PrintLimitNone
    GuiControl, 1:Enable, PrintLimitWords
    GuiControl, 1:Enable, PrintLimitLines
    GuiControl, 1:Enable, PrintLimitTime
    
    GuiControl, 1:Disable, PrintWordLimit
    GuiControl, 1:Disable, PrintLineLimit
    GuiControl, 1:Disable, PrintTimeLimit
    GuiControl, 1:Disable, PrintTimeUnit
    
    if (PrintLimitType = 2) {
        GuiControl, 1:Enable, PrintWordLimit
    } else if (PrintLimitType = 3) {
        GuiControl, 1:Enable, PrintLineLimit
    } else if (PrintLimitType = 4) {
        GuiControl, 1:Enable, PrintTimeLimit
        GuiControl, 1:Enable, PrintTimeUnit
    }
}

OpenPrintLimitCycleDialog(row) {
    global printLimitCycles, plcd_editRow
    if (!IsObject(printLimitCycles) || row < 1 || row > printLimitCycles.Length())
        return
    
    plcd_editRow := row
    item := printLimitCycles[row]
    
    Gui, PrintLimitCycleDialog:Destroy
    Gui, PrintLimitCycleDialog:New, +Owner1 +AlwaysOnTop, Цикл ограничения печати
    Gui, PrintLimitCycleDialog:Add, Text, x10 y12, Тип:
    Gui, PrintLimitCycleDialog:Add, DropDownList, vPLCD_Type x95 y10 w210 gPLCD_TypeChanged, Слова|Строки|Время
    Gui, PrintLimitCycleDialog:Add, Text, x10 y42, Значение:
    Gui, PrintLimitCycleDialog:Add, Edit, vPLCD_Value x95 y40 w110 Number, % item.value
    Gui, PrintLimitCycleDialog:Add, Text, x10 y72, Единицы:
    Gui, PrintLimitCycleDialog:Add, DropDownList, vPLCD_Unit x95 y70 w210, Миллисекунда|Секунда|Минута
    Gui, PrintLimitCycleDialog:Add, Button, x95 y105 w100 gPLCD_Save, Сохранить
    Gui, PrintLimitCycleDialog:Add, Button, x205 y105 w100 gPLCD_Cancel, Отмена
    
    tRu := (item.type = "words") ? "Слова" : (item.type = "lines") ? "Строки" : (item.type = "time") ? "Время" : "Слова"
    GuiControl, PrintLimitCycleDialog:ChooseString, PLCD_Type, %tRu%
    u := item.unit
    if (u = "")
        u := "Секунда"
    GuiControl, PrintLimitCycleDialog:ChooseString, PLCD_Unit, %u%
    
    if (tRu = "Время")
        GuiControl, PrintLimitCycleDialog:Enable, PLCD_Unit
    else
        GuiControl, PrintLimitCycleDialog:Disable, PLCD_Unit
    
    Gui, PrintLimitCycleDialog:Show, w330 h150
}

PLCD_TypeChanged:
    Gui, PrintLimitCycleDialog:Submit, NoHide
    if (PLCD_Type = "Время")
        GuiControl, PrintLimitCycleDialog:Enable, PLCD_Unit
    else
        GuiControl, PrintLimitCycleDialog:Disable, PLCD_Unit
return

PLCD_Save:
    global plcd_editRow, printLimitCycles
    Gui, PrintLimitCycleDialog:Submit, NoHide
    
    v := PLCD_Value + 0
    if (v <= 0) {
        MsgBox, 48, Ошибка, Значение должно быть больше 0!
        return
    }
    
    typeKey := (PLCD_Type = "Слова") ? "words" : (PLCD_Type = "Строки") ? "lines" : (PLCD_Type = "Время") ? "time" : ""
    if (typeKey = "") {
        MsgBox, 48, Ошибка, Некорректный тип!
        return
    }
    
    unit := (typeKey = "time") ? PLCD_Unit : ""
    printLimitCycles[plcd_editRow] := {type: typeKey, value: v, unit: unit}
    
    Gui, PrintLimitCycleDialog:Destroy
    PrintLimitCycles_RebuildListView(plcd_editRow)
    UpdatePrintLimitCyclesInfo()
return

PLCD_Cancel:
PrintLimitCycleDialogGuiClose:
    Gui, PrintLimitCycleDialog:Destroy
return


; ==============================================================================
; === Настройки случайного выбора строки (шестеренка)
; ==============================================================================

OpenRandomLineSettings:
    global RandomLineBiasEnabled, RandomLineChanceTop, RandomLineChanceMiddle, RandomLineChanceBottom, RandomLineChanceRandom
    
    Gui, RandomLineSettings:Destroy
    Gui, RandomLineSettings:New, +Owner1 +AlwaysOnTop, Настройки случайного выбора строки
    Gui, RandomLineSettings:Add, Checkbox, vRLS_Enabled x10 y10, Включить веса выбора (верх/середина/низ/случайно)
    
    Gui, RandomLineSettings:Add, Text, x10 y45, Верхние строки (`%):
    Gui, RandomLineSettings:Add, Edit, vRLS_Top x200 y42 w60 Number, %RandomLineChanceTop%
    Gui, RandomLineSettings:Add, Text, x10 y75, Средние строки (`%):
    Gui, RandomLineSettings:Add, Edit, vRLS_Middle x200 y72 w60 Number, %RandomLineChanceMiddle%
    Gui, RandomLineSettings:Add, Text, x10 y105, Нижние строки (`%):
    Gui, RandomLineSettings:Add, Edit, vRLS_Bottom x200 y102 w60 Number, %RandomLineChanceBottom%
    Gui, RandomLineSettings:Add, Text, x10 y135, Случайные строки (`%):
    Gui, RandomLineSettings:Add, Edit, vRLS_Random x200 y132 w60 Number, %RandomLineChanceRandom%
    
    Gui, RandomLineSettings:Add, Text, vRLS_Hint x10 y160 w360 cGray, Сумма может быть не 100: значения нормализуются как веса.
    Gui, RandomLineSettings:Add, Button, x200 y185 w90 gRLS_Save, Сохранить
    Gui, RandomLineSettings:Add, Button, x295 y185 w90 gRLS_Cancel, Отмена
    
    GuiControl, RandomLineSettings:, RLS_Enabled, % RandomLineBiasEnabled ? 1 : 0
    Gui, RandomLineSettings:Show, w410 h225
return

RLS_Save:
    global RandomLineBiasEnabled, RandomLineChanceTop, RandomLineChanceMiddle, RandomLineChanceBottom, RandomLineChanceRandom
    Gui, RandomLineSettings:Submit, NoHide
    
    RandomLineBiasEnabled := RLS_Enabled ? 1 : 0
    RandomLineChanceTop := RLS_Top + 0
    RandomLineChanceMiddle := RLS_Middle + 0
    RandomLineChanceBottom := RLS_Bottom + 0
    RandomLineChanceRandom := RLS_Random + 0
    
    if (RandomLineChanceTop < 0 || RandomLineChanceMiddle < 0 || RandomLineChanceBottom < 0 || RandomLineChanceRandom < 0) {
        MsgBox, 48, Ошибка, Шансы не могут быть отрицательными!
        return
    }
    
    Gui, RandomLineSettings:Destroy
    SB_SetText("Настройки случайного выбора строки сохранены", 1)
return

RLS_Cancel:
RandomLineSettingsGuiClose:
    Gui, RandomLineSettings:Destroy
return


; ==============================================================================
; === Логика выбора строки по весам (верх/середина/низ/случайно)
; ==============================================================================

PickRandomLineIndex(messages, ByRef usedLines, noRepeat) {
    global RandomLineBiasEnabled, RandomLineChanceTop, RandomLineChanceMiddle, RandomLineChanceBottom, RandomLineChanceRandom
    
    if (!IsObject(messages))
        return 0
    n := messages.Length()
    if (n <= 0)
        return 0
    
    available := []
    if (noRepeat) {
        Loop %n% {
            idx := A_Index
            isUsed := false
            for i, u in usedLines {
                if (u = idx) {
                    isUsed := true
                    break
                }
            }
            if (!isUsed)
                available.Push(idx)
        }
        if (available.Length() = 0) {
            usedLines := []
            Loop %n%
                available.Push(A_Index)
        }
    } else {
        Loop %n%
            available.Push(A_Index)
    }
    
    picked := 0
    if (!RandomLineBiasEnabled) {
        Random, r, 1, % available.Length()
        picked := available[r]
    } else {
        wTop := RandomLineChanceTop + 0
        wMid := RandomLineChanceMiddle + 0
        wBot := RandomLineChanceBottom + 0
        wRnd := RandomLineChanceRandom + 0
        sum := wTop + wMid + wBot + wRnd
        
        if (sum <= 0) {
            Random, r, 1, % available.Length()
            picked := available[r]
        } else {
            Random, roll, 1, %sum%
            mode := "random"
            if (roll <= wTop)
                mode := "top"
            else if (roll <= wTop + wMid)
                mode := "mid"
            else if (roll <= wTop + wMid + wBot)
                mode := "bot"
            else
                mode := "random"
            
            topEnd := Ceil(n / 3.0)
            midEnd := Ceil((2 * n) / 3.0)
            
            subset := []
            for i, idx in available {
                if (mode = "top" && idx <= topEnd)
                    subset.Push(idx)
                else if (mode = "mid" && idx > topEnd && idx <= midEnd)
                    subset.Push(idx)
                else if (mode = "bot" && idx > midEnd)
                    subset.Push(idx)
            }
            
            if (mode = "random" || subset.Length() = 0)
                subset := available
            
            Random, r, 1, % subset.Length()
            picked := subset[r]
        }
    }
    
    if (noRepeat && picked)
        usedLines.Push(picked)
    return picked
}

; ==============================================================================
; === Бинды управления (старт/стоп/пауза/экстренно)
; ==============================================================================

RegisterControlHotkeys() {
    global ControlStartHotkey, ControlStopHotkey, ControlPauseHotkey, ControlEmergencyHotkey
    global controlHotkeysPrev
    
    ; Disable previously registered hotkeys
    if (IsObject(controlHotkeysPrev)) {
        for k, prev in controlHotkeysPrev {
            if (prev != "") {
                try Hotkey, %prev%, Off
            }
        }
    }
    controlHotkeysPrev := {}
    
    if (ControlStartHotkey != "") {
        try Hotkey, %ControlStartHotkey%, ContextStartTyping, On
        controlHotkeysPrev["start"] := ControlStartHotkey
    }
    if (ControlStopHotkey != "") {
        try Hotkey, %ControlStopHotkey%, ContextStopTyping, On
        controlHotkeysPrev["stop"] := ControlStopHotkey
    }
    if (ControlPauseHotkey != "") {
        try Hotkey, %ControlPauseHotkey%, ContextPauseTyping, On
        controlHotkeysPrev["pause"] := ControlPauseHotkey
    }
    if (ControlEmergencyHotkey != "") {
        try Hotkey, %ControlEmergencyHotkey%, ContextEmergencyStopTyping, On
        controlHotkeysPrev["emergency"] := ControlEmergencyHotkey
    }
    
    UpdateControlHotkeysHint()
}

UpdateControlHotkeysHint() {
    global ControlStartHotkey, ControlStopHotkey, ControlPauseHotkey, ControlEmergencyHotkey
    
    hint := ControlEmergencyHotkey != "" ? (ControlEmergencyHotkey . " = экстренная остановка") : "Экстренная остановка: не задано"
    GuiControl, 1:, ControlHotkeysHint, %hint%
    
    ; Обновляем подсказку на вкладке "Режим Печати" (если контрол существует)
    hot := "Горячие клавиши:`n"
    hot .= (ControlStartHotkey != "" ? (ControlStartHotkey . " - Старт") : "Старт: нет") . " | "
    hot .= (ControlStopHotkey != "" ? (ControlStopHotkey . " - Стоп") : "Стоп: нет") . " | "
    hot .= (ControlPauseHotkey != "" ? (ControlPauseHotkey . " - Пауза") : "Пауза: нет") . " | "
    hot .= (ControlEmergencyHotkey != "" ? (ControlEmergencyHotkey . " - Экстренно") : "Экстренно: нет")
    
    base := "Печать обычного текста из основного поля.`n`nИспользуйте этот режим для простой печати`nзаранее подготовленного текста с настройками`nскорости, ошибок и других параметров.`n`n"
    GuiControl, 1:, ModeDescText, % (base . hot)
}

HotkeysAreValidUnique(a, b, c, d) {
    set := {}
    for _, hk in [a, b, c, d] {
        hk := Trim(hk)
        if (hk = "")
            continue
        if (set.HasKey(hk))
            return false
        set[hk] := 1
    }
    return true
}

ApplyControlHotkeys:
    Gui, 1:Submit, NoHide
    global ControlStartHotkey, ControlStopHotkey, ControlPauseHotkey, ControlEmergencyHotkey
    
    if (!HotkeysAreValidUnique(ControlStartHotkey, ControlStopHotkey, ControlPauseHotkey, ControlEmergencyHotkey)) {
        MsgBox, 48, Ошибка, Горячие клавиши не должны повторяться (Старт/Стоп/Пауза/Экстренно)!
        return
    }
    
    RegisterControlHotkeys()
    try SB_SetText("Бинды управления применены", 1)
return

ResetControlHotkeys:
    global ControlStartHotkey, ControlStopHotkey, ControlPauseHotkey, ControlEmergencyHotkey
    ControlStartHotkey := "F8"
    ControlStopHotkey := "F9"
    ControlPauseHotkey := "F10"
    ControlEmergencyHotkey := "F12"
    
    GuiControl, 1:, ControlStartHotkey, %ControlStartHotkey%
    GuiControl, 1:, ControlStopHotkey, %ControlStopHotkey%
    GuiControl, 1:, ControlPauseHotkey, %ControlPauseHotkey%
    GuiControl, 1:, ControlEmergencyHotkey, %ControlEmergencyHotkey%
    
    RegisterControlHotkeys()
    try SB_SetText("Бинды управления сброшены", 1)
return

OpenTelegramNow:
    global TelegramChannelUrl
    if (TelegramChannelUrl != "")
        Run, %TelegramChannelUrl%
return

OpenTelegramOnStartTimer:
    global OpenTelegramOnStart, TelegramChannelUrl, telegramOpenedThisRun
    if (telegramOpenedThisRun)
        return
    if (OpenTelegramOnStart && TelegramChannelUrl != "") {
        telegramOpenedThisRun := 1
        Run, %TelegramChannelUrl%
    }
return

KB_ShowTags:
    KB_SetSection("tags")
return
KB_ShowUsage:
    KB_SetSection("usage")
return
KB_ShowSpeed:
    KB_SetSection("speed")
return
KB_ShowTemplates:
    KB_SetSection("templates")
return
KB_ShowLimits:
    KB_SetSection("limits")
return
KB_ShowCycles:
    KB_SetSection("cycles")
return
KB_ShowBinds:
    KB_SetSection("binds")
return

KB_SetSection(section) {
    txt := KB_GetText(section)
    GuiControl, 1:, KB_Content, %txt%
}

KB_GetText(section) {
    global ControlStartHotkey, ControlStopHotkey, ControlPauseHotkey, ControlEmergencyHotkey
    global TelegramChannelUrl
    
    if (section = "tags") {
        return "МЕТКИ (Special Tags)`n"
            . "`n"
            . "Поддерживаются метки в фигурных скобках, например:`n"
            . "  {TIME} / {TIME:second} / {TIME:full}`n"
            . "  {DATE} / {DATE:iso}`n"
            . "  {DATETIME} / {DATETIME:second} / {DATETIME:iso}`n"
            . "  {PAUSE: 500ms} / {PAUSE: 1s} / {PAUSE: 2min}`n"
            . "  {RAND 1-10}`n"
            . "  {UUID}`n"
            . "  {COUNTER}`n"
            . "`n"
            . "Пример:`n"
            . "  Привет {TIME}{PAUSE: 500ms} мир`n"
    }
    if (section = "usage") {
        return "ИСПОЛЬЗОВАНИЕ`n"
            . "`n"
            . "1) Выберите режим в меню слева (например: Основной текст).`n"
            . "2) Выберите шаблон или вставьте текст в поле редактора.`n"
            . "3) Настройте скорость/задержки/ошибки/Auto-Enter по необходимости.`n"
            . "4) Нажмите горячую клавишу Старт или кнопку старта (если есть).`n"
            . "`n"
            . "Канал: " . TelegramChannelUrl . "`n"
    }
    if (section = "speed") {
        return "КАК ПОМЕНЯТЬ СКОРОСТЬ`n"
            . "`n"
            . "На вкладке текста есть параметры скорости:`n"
            . "- Тип скорости: 'Букв в секунду', 'Слов в минуту', 'Интервал/Задержка', 'Вставка через буфер'.`n"
            . "- Значение скорости и множитель ускорения (например 10x).`n"
            . "`n"
            . "Если печатает слишком быстро, уменьшайте скорость или множитель.`n"
    }
    if (section = "templates") {
        return "ШАБЛОНЫ`n"
            . "`n"
            . "Слева (TreeView) находятся категории/подкатегории/шаблоны.`n"
            . "Выберите шаблон, отредактируйте текст справа и сохраните.`n"
            . "`n"
            . "Можно использовать режимы: Основной текст / Генератор / Слоты / По биндам.`n"
    }
    if (section = "limits") {
        return "ОГРАНИЧЕНИЯ ПЕЧАТИ`n"
            . "`n"
            . "В 'Ограничение печати' можно ограничить:`n"
            . "- по словам`n"
            . "- по строкам`n"
            . "- по времени (печать до истечения времени)`n"
            . "`n"
            . "Включите нужный вариант, задайте значение и запускайте печать.`n"
    }
    if (section = "cycles") {
        return "ЦИКЛЫ ОГРАНИЧЕНИЯ ПЕЧАТИ`n"
            . "`n"
            . "Можно включить 'Циклы ограничения печати' и добавить N циклов.`n"
            . "Каждый цикл может быть: Слова / Строки / Время.`n"
            . "На каждом повторе AutoTyper будет применять следующий цикл по кругу.`n"
            . "`n"
            . "Пример: 2 слова -> 5 слов -> 10 строк -> 5 сек -> ...`n"
    }
    if (section = "binds") {
        return "БИНДЫ УПРАВЛЕНИЯ`n"
            . "`n"
            . "Во вкладке 'Бинды' внизу можно изменить горячие клавиши управления:`n"
            . "- Старт: " . ControlStartHotkey . "`n"
            . "- Стоп: " . ControlStopHotkey . "`n"
            . "- Пауза: " . ControlPauseHotkey . "`n"
            . "- Экстренно: " . ControlEmergencyHotkey . "`n"
            . "`n"
            . "Экстренная остановка мгновенно прерывает печать и выключает таймеры.`n"
    }
    
    return "Выберите раздел слева."
}

PrintLimitCyclesToggle:
    Gui, 1:Submit, NoHide
    UpdatePrintLimitControlsState()
    UpdatePrintLimitCyclesInfo()
return

PrintLimitCycleTypeChanged:
    Gui, 1:Submit, NoHide
    if (PrintLimitCycleType = "Время") {
        GuiControl, 1:Enable, PrintLimitCycleUnit
    } else {
        GuiControl, 1:Disable, PrintLimitCycleUnit
    }
return

AddPrintLimitCycle:
    Gui, 1:Submit, NoHide
    global printLimitCycles
    if (!IsObject(printLimitCycles))
        printLimitCycles := []
    
    v := PrintLimitCycleValue + 0
    if (v <= 0) {
        MsgBox, 48, Ошибка, Значение цикла должно быть больше 0!
        return
    }
    
    typeKey := ""
    if (PrintLimitCycleType = "Слова")
        typeKey := "words"
    else if (PrintLimitCycleType = "Строки")
        typeKey := "lines"
    else if (PrintLimitCycleType = "Время")
        typeKey := "time"
    else {
        MsgBox, 48, Ошибка, Некорректный тип цикла!
        return
    }
    
    unit := ""
    if (typeKey = "time")
        unit := PrintLimitCycleUnit
    
    printLimitCycles.Push({type: typeKey, value: v, unit: unit})
    PrintLimitCycles_RebuildListView()
    UpdatePrintLimitCyclesInfo()
    SB_SetText("Цикл ограничения добавлен", 1)
return

EditPrintLimitCycle:
    Gui, 1:Default
    Gui, 1:ListView, PrintLimitCyclesList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите цикл для редактирования!
        return
    }
    OpenPrintLimitCycleDialog(row)
return

DeletePrintLimitCycle:
    Gui, 1:Default
    Gui, 1:ListView, PrintLimitCyclesList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите цикл для удаления!
        return
    }
    global printLimitCycles
    if (IsObject(printLimitCycles) && row <= printLimitCycles.Length()) {
        printLimitCycles.RemoveAt(row)
        PrintLimitCycles_RebuildListView()
        UpdatePrintLimitCyclesInfo()
    }
return

MovePrintLimitCycleUp:
    Gui, 1:Default
    Gui, 1:ListView, PrintLimitCyclesList
    row := LV_GetNext()
    if (row <= 1)
        return
    global printLimitCycles
    if (!IsObject(printLimitCycles) || row > printLimitCycles.Length())
        return
    tmp := printLimitCycles[row-1]
    printLimitCycles[row-1] := printLimitCycles[row]
    printLimitCycles[row] := tmp
    PrintLimitCycles_RebuildListView(row-1)
return

MovePrintLimitCycleDown:
    Gui, 1:Default
    Gui, 1:ListView, PrintLimitCyclesList
    row := LV_GetNext()
    global printLimitCycles
    if (!IsObject(printLimitCycles) || row = 0 || row >= printLimitCycles.Length())
        return
    tmp := printLimitCycles[row+1]
    printLimitCycles[row+1] := printLimitCycles[row]
    printLimitCycles[row] := tmp
    PrintLimitCycles_RebuildListView(row+1)
return

ClearPrintLimitCycles:
    MsgBox, 36, Подтверждение, Удалить все циклы ограничения печати?
    IfMsgBox, No
        return
    global printLimitCycles
    printLimitCycles := []
    PrintLimitCycles_RebuildListView()
    UpdatePrintLimitCyclesInfo()
return

ErrorWordsCountChanged:
    Gui, 1:Submit, NoHide
    if (ErrorWordsCount = "N" || ErrorWordsCount = "n") {
        GuiControl, Show, ErrorWordsCustom
    } else {
        GuiControl, Hide, ErrorWordsCustom
    }
return

; Открыть диалог выбора стартовой строки
OpenStartLineDialog:
    Gui, StartLineDialog:Destroy
    Gui, StartLineDialog:New, +Owner1 +AlwaysOnTop, Начать со строки
    Gui, StartLineDialog:Add, Text, x10 y10, Номер строки:
    Gui, StartLineDialog:Add, Edit, vStartLineInput x100 y8 w80, % StartLineNumber
    Gui, StartLineDialog:Add, Button, x190 y6 w110 gDoInitStartLine, Инициализировать
    Gui, StartLineDialog:Add, Text, x10 y38, Всего строк:
    Gui, StartLineDialog:Add, Text, vFileTotalLines x100 y38 w120, 0 строк
    Gui, StartLineDialog:Add, Text, x10 y58, Всего слов:
    Gui, StartLineDialog:Add, Text, vFileTotalWords x100 y58 w120, 0 слов
    Gui, StartLineDialog:Add, Text, x10 y78, Всего букв:
    Gui, StartLineDialog:Add, Text, vFileTotalChars x100 y78 w120, 0 букв
    Gui, StartLineDialog:Add, Text, x10 y98, Слов в строке:
    Gui, StartLineDialog:Add, Text, vLineWords x100 y98 w120, 0 слов
    Gui, StartLineDialog:Add, Text, x10 y118, Букв в строке:
    Gui, StartLineDialog:Add, Text, vLineChars x100 y118 w120, 0 букв
    Gui, StartLineDialog:Add, Text, x10 y158, Оценка времени (строка):
    Gui, StartLineDialog:Add, Text, vEstimateLine x180 y158 w160, 0 s
    Gui, StartLineDialog:Add, Text, x10 y178, Оценка времени (всего):
    Gui, StartLineDialog:Add, Text, vEstimateTotal x180 y178 w160, 0 s
    Gui, StartLineDialog:Add, Button, x100 y200 w90 gStartLineOK, OK
    Gui, StartLineDialog:Add, Button, x210 y200 w90 gStartLineCancel, Отмена
    Gui, StartLineDialog:Show, w460 h240
    Gosub, DoInitStartLine
return

; Инициализация подсчёта строк/слов по основному тексту
DoInitStartLine:
    Gui, 1:Submit, NoHide
    text := TypeText
    if (text = "") {
        totalLines := 0
        totalWords := 0
        totalChars := 0
    } else {
        lines := StrSplit(text, "`n")
        totalLines := lines.Length()
        totalWords := 0
        totalChars := 0
        for index, ln in lines {
            cleaned := RegExReplace(ln, "[^[:alnum:]]+", " ")
            cleaned := Trim(cleaned)
            if (cleaned != "") {
                parts := StrSplit(cleaned, " ")
                totalWords += parts.Length()
            }
            ; Count characters (letters) in the line (exclude line breaks)
            totalChars += StrLen(ln)
        }
    }

    ; Determine which line to analyze
    lineIdx := StartLineNumber
    if (StartLineInput != "")
        lineIdx := StartLineInput + 0
    if (lineIdx < 1)
        lineIdx := 1
    if (lineIdx > totalLines)
        lineIdx := totalLines

    lineText := (totalLines > 0) ? lines[lineIdx] : ""
    ; Words/chars in the specific line
    cleanedLine := RegExReplace(lineText, "[^[:alnum:]]+", " ")
    cleanedLine := Trim(cleanedLine)
    if (cleanedLine != "") {
        partsLine := StrSplit(cleanedLine, " ")
        lineWords := partsLine.Length()
    } else
        lineWords := 0
    lineChars := StrLen(lineText)

    ; Get speed and message delay from main GUI
    Gui, 1:Default
    GuiControlGet, guiSpeed,, SpeedInput
    GuiControlGet, guiMsgDelay,, MessageDelay
    if (!RegExMatch(guiSpeed, "^\d+$") || guiSpeed <= 0)
        guiSpeed := 10
    if (!RegExMatch(guiMsgDelay, "^\d+$"))
        guiMsgDelay := 1000

    ; Estimate times (seconds)
    estimateLine := Round((lineChars / guiSpeed) + (guiMsgDelay / 1000), 2)
    estimateTotal := Round((totalChars / guiSpeed) + (guiMsgDelay / 1000) * totalLines, 2)

    Gui, StartLineDialog:Default
    GuiControl,, FileTotalLines, % totalLines " строк"
    GuiControl,, FileTotalWords, % totalWords " слов"
    GuiControl,, FileTotalChars, % totalChars " букв"
    GuiControl,, LineWords, % lineWords " слов"
    GuiControl,, LineChars, % lineChars " букв"
    GuiControl,, EstimateLine, % estimateLine " сек"
    GuiControl,, EstimateTotal, % estimateTotal " сек"
return

StartLineOK:
    Gui, StartLineDialog:Submit, NoHide
    if (StartLineInput = "") {
        MsgBox, 48, Ошибка, Укажите номер строки!
        return
    }
    if (!RegExMatch(StartLineInput, "^\d+$")) {
        MsgBox, 48, Ошибка, Неверный номер строки!
        return
    }
    StartLineNumber := StartLineInput + 0
    Gui, StartLineDialog:Destroy
return

StartLineCancel:
    Gui, StartLineDialog:Destroy
    GuiControl,, StartPosition, С начала
return

; === Обновление интерфейса задержек основного текста ===
UpdateMainDelayMode:
    Gui, 1:Submit, NoHide

    ; Получаем режим/вариант/параметры из GUI
    method := GenerationMethod ? GenerationMethod : "Corpus"
    variant := ModelVariant ? ModelVariant : "Default"
    ; температура как множитель (slider 1..200 -> 0.01..2.00)
    ; использовать корпус
    useCorpusSetting := UseCorpus

    ; Применение пресетов вариантов (простые модификации)
    if (variant = "Creative") {
        creativity := creativity * 1.5
        ModelPunctuation := 1
        ModelCommas := 1
    } else if (variant = "Conservative") {
        creativity := creativity * 0.6
        ModelPunctuation := 1
        ModelCommas := 0
    } else if (variant = "HighPunct") {
        ModelPunctuation := 1
        ModelCommas := 1
    } else if (variant = "NoPunct") {
        ModelPunctuation := 0
        ModelCommas := 0
    } else if (variant = "Short") {
        ; Ограничиваем длину генерации, если выбран вариант Short
        if (RegExMatch(GenerateLength, "^\d+$") && GenerateLength > 10) {
            GenerateLength := 10
            GuiControl,, GenerateLength, %GenerateLength%
        }
    } else if (variant = "Long") {
        ; При Long — увеличиваем минимум
        if (RegExMatch(GenerateLength, "^\d+$") && GenerateLength < 50) {
            GenerateLength := 50
            GuiControl,, GenerateLength, %GenerateLength%
        }
    }
    
    ; Скрываем все поля сначала
    GuiControl, Hide, MainDelayLabel
    GuiControl, Hide, MainDelayValue
    GuiControl, Hide, MainDelayUnit
    
    ; Показываем нужные поля в зависимости от режима
    if (MainDelayMode != "Отсутствует") {
        GuiControl, Show, MainDelayLabel
        GuiControl, Show, MainDelayValue
        
        ; Устанавливаем правильную единицу измерения
        if (MainDelayMode = "Миллисекунды") {
            GuiControl,, MainDelayUnit, мс
        }
        else if (MainDelayMode = "Секунды") {
            GuiControl,, MainDelayUnit, сек
        }
        else if (MainDelayMode = "Минуты") {
            GuiControl,, MainDelayUnit, мин
        }
        
        GuiControl, Show, MainDelayUnit
    }
return

; === Обновление интерфейса задержек воспроизведения ===
UpdatePlaybackDelayMode:
    Gui, 1:Submit, NoHide
    
    ; Скрываем все поля сначала
    GuiControl, Hide, PlaybackDelayLabel
    GuiControl, Hide, PlaybackDelayValue
    GuiControl, Hide, PlaybackDelayUnit
    
    ; Показываем нужные поля в зависимости от режима
    if (PlaybackDelayMode != "Отсутствует") {
        GuiControl, Show, PlaybackDelayLabel
        GuiControl, Show, PlaybackDelayValue
        
        ; Устанавливаем правильную единицу измерения
        if (PlaybackDelayMode = "Миллисекунды") {
            GuiControl,, PlaybackDelayUnit, мс
        }
        else if (PlaybackDelayMode = "Секунды") {
            GuiControl,, PlaybackDelayUnit, сек
        }
        else if (PlaybackDelayMode = "Минуты") {
            GuiControl,, PlaybackDelayUnit, мин
        }
        
        GuiControl, Show, PlaybackDelayUnit
    }
return

; === Функция расчета задержки ===
CalculateDelay(delayMode, delayValue) {
    if (delayMode = "Отсутствует") {
        return 0
    }
    else if (delayMode = "Миллисекунды") {
        return delayValue
    }
    else if (delayMode = "Секунды") {
        return delayValue * 1000
    }
    else if (delayMode = "Минуты") {
        return delayValue * 60000
    }
    return 0
}

; === ФУНКЦИИ ЗАПИСИ ТЕКСТА ===

global isRecording := false
global recordedText := ""
global recordStartTime := 0

; === Тестовое воспроизведение ===
TestPlayback:
    if (recordedText = "") {
        MsgBox, 48, Нет текста, Нет записанного текста для теста!
        return
    }
    
    ; Тестовое воспроизведение в окне сообщения
    testText := SubStr(recordedText, 1, 500)
    if (StrLen(recordedText) > 500)
        testText .= "`n`n[... текст обрезан ...]"
    
    MsgBox, 64, Тест воспроизведения, Тестовый просмотр текста:`n`n%testText%
return

; === Экспорт записи ===
ExportRecording:
    if (recordedText = "") {
        MsgBox, 48, Нет текста, Нет записанного текста для экспорта!
        return
    }
    
    ; Диалог выбора файла
    FileSelectFile, exportPath, S16, %RecordFolder%\recorded_text.txt, Сохранить запись как, Текстовые файлы (*.txt)
    if (exportPath = "")
        return
    
    ; Добавляем расширение если нужно
    if (!RegExMatch(exportPath, "\.txt$"))
        exportPath .= ".txt"
    
    FileDelete, %exportPath%
    FileAppend, %recordedText%, %exportPath%, UTF-8
    
    if (FileExist(exportPath)) {
        MsgBox, 64, Успех, Запись экспортирована в файл!`n`n%exportPath%
        SB_SetText("Запись экспортирована", 1)
    } else {
        MsgBox, 16, Ошибка, Не удалось экспортировать файл!
    }
return

; === Быстрое сохранение ===
QuickSave:
    if (recordedText = "") {
        MsgBox, 48, Нет текста, Нет записанного текста для сохранения!
        return
    }
    
    Gui, 1:Submit, NoHide
    
    ; Автоматическое имя файла с временем
    FormatTime, fileTime,, yyyy-MM-dd_HH-mm-ss
    quickFileName := "quick_record_" . fileTime . ".txt"
    quickPath := RecordFolder . "\" . quickFileName
    
    if (!FileExist(RecordFolder))
        FileCreateDir, %RecordFolder%
    
    FileDelete, %quickPath%
    FileAppend, %recordedText%, %quickPath%, UTF-8
    
    if (FileExist(quickPath)) {
        MsgBox, 64, Успех, Быстрое сохранение!`n`nФайл: %quickFileName%
        SB_SetText("Быстрое сохранение: " . quickFileName, 1)
    }
return

; === Сохранить как... ===
SaveWithDialog:
    if (recordedText = "") {
        MsgBox, 48, Нет текста, Нет записанного текста для сохранения!
        return
    }
    
    ; Диалог выбора файла
    FileSelectFile, savePath, S16, %RecordFolder%\recorded_text.txt, Сохранить запись, Текстовые файлы (*.txt)
    if (savePath = "")
        return
    
    ; Добавляем расширение если нужно
    if (!RegExMatch(savePath, "\.txt$"))
        savePath .= ".txt"
    
    FileDelete, %savePath%
    FileAppend, %recordedText%, %savePath%, UTF-8
    
    if (FileExist(savePath)) {
        MsgBox, 64, Успех, Запись сохранена!`n`n%savePath%
        SB_SetText("Запись сохранена в: " . savePath, 1)
    } else {
        MsgBox, 16, Ошибка, Не удалось сохранить файл!
    }
return

; === Воспроизвести запись ===
PlayRecording:
    if (recordedText = "") {
        MsgBox, 48, Нет текста, Нет записанного текста для воспроизведения!
        return
    }
    
    if (isPlaying) {
        MsgBox, 48, Уже воспроизводится, Воспроизведение уже запущено!
        return
    }
    
    Gui, 1:Submit, NoHide
    
    ; Multi-window removed: воспроизведение будет выполняться в текущем активном окне
    
    isPlaying := true
    playbackSpeed := PlaybackSpeed
    playbackRepeats := PlaybackRepeats
    playbackMaxWords := PlaybackMaxWords
    playbackRandomize := PlaybackRandomize
    playbackErrorLevel := PlaybackErrorLevel
    
    SB_SetText("Воспроизведение начато (скорость: x" . playbackSpeed . ")", 1)
    
    ; Запускаем воспроизведение в отдельном потоке
    SetTimer, PlaybackText, -10
return

; === Воспроизведение текста ===
PlaybackText:
    Gui, 1:Submit, NoHide
    global TextShuffleLevel
    
    ; Базовая скорость (миллисекунды между символами)
    baseDelay := 50
    
    ; Корректируем скорость согласно настройке
    actualDelay := baseDelay / playbackSpeed
    
    ; Минимальная задержка для очень высоких скоростей
    if (actualDelay < 1)
        actualDelay := 1
    
    ; Рассчитываем задержку между сообщениями
    messageDelay := CalculateDelay(PlaybackDelayMode, PlaybackDelayValue)
    
    ; Обрабатываем текст перед воспроизведением
    processedText := recordedText
    
    ; Применяем ошибки к тексту
    if (playbackErrorLevel != "Нет") {
        processedText := ApplyPlaybackErrors(processedText, playbackErrorLevel)
    }

    ; Применяем перемешиватель текста (независимо от генератора ошибок)
    if (TextShuffleLevel != "" && TextShuffleLevel != "Отключено") {
        shuffleNum := 1
        if (TextShuffleLevel = "Низкий")
            shuffleNum := 2
        else if (TextShuffleLevel = "Средний")
            shuffleNum := 3
        else if (TextShuffleLevel = "Высокий")
            shuffleNum := 4
        else if (TextShuffleLevel = "Экстремальный")
            shuffleNum := 5

        if (shuffleNum > 1)
            processedText := ShuffleText(processedText, shuffleNum)
    }
    
    ; Применяем случайный порядок строк
    if (playbackRandomize) {
        lines := StrSplit(processedText, "`n")
        shuffledLines := []
        lineCount := lines.Length()
        
        ; Создаем массив индексов
        indices := []
        Loop % lineCount {
            indices.Push(A_Index)
        }
        
        ; Перемешиваем индексы
        Loop % lineCount * 2 {
            Random, idx1, 1, % lineCount
            Random, idx2, 1, % lineCount
            temp := indices[idx1]
            indices[idx1] := indices[idx2]
            indices[idx2] := temp
        }
        
        ; Собираем текст в случайном порядке
        processedText := ""
        for i, idx in indices {
            processedText .= lines[idx] . "`n"
        }
        processedText := Trim(processedText, "`n")
    }
    
    ; Применяем замену букв (Letter Changer)
    if (letterReplacementsEnabled) {
        processedText := ApplyLetterReplacements(processedText)
    }
    
    ; Применяем ограничения букв (удаляем запрещённые символы)
    processedText := ApplyLetterRestrictions(processedText)
    
    ; Определяем количество повторов
    repeatCount := 1  ; По умолчанию 1 повтор
    
    if (PlaybackRepeats = "∞") {
        repeatCount := 999999  ; Практически бесконечно
    }
    else if (PlaybackRepeats = "Нет") {
        repeatCount := 1  ; Только один раз, без повторов
    }
    else {
        repeatCount := PlaybackRepeats
    }
    
    currentRepeat := 0
    
    ; Цикл повторов
    while (currentRepeat < repeatCount && isPlaying) {
        currentRepeat++
        
        ; Показываем информацию о повторе только в статусе (кроме режима "Нет")
        if (PlaybackRepeats != "Нет" && repeatCount > 1) {
            SB_SetText("Воспроизведение: повтор " . currentRepeat . "/" . (repeatCount = 999999 ? "∞" : repeatCount) . " (скорость: x" . playbackSpeed . ")", 1)
        }
        else {
            SB_SetText("Воспроизведение (скорость: x" . playbackSpeed . ")", 1)
        }
        
        ; Обрабатываем текст с учетом максимума слов
        if (playbackMaxWords > 0) {
            ; Разбиваем на слова
            allWords := StrSplit(processedText, " ")
            totalWords := allWords.Length()
            currentWordIndex := 1
            
            ; Обрабатываем слова порциями
            while (currentWordIndex <= totalWords && isPlaying) {
                currentMessage := ""
                wordsInMessage := 0
                
                ; Собираем сообщение из N слов
                while (wordsInMessage < playbackMaxWords && currentWordIndex <= totalWords && isPlaying) {
                    currentMessage .= allWords[currentWordIndex] . " "
                    wordsInMessage++
                    currentWordIndex++
                }
                
                ; Убираем последний пробел
                currentMessage := Trim(currentMessage)
                
                ; Отправляем сообщение посимвольно
                if (currentMessage != "") {
                    Loop, Parse, currentMessage
                    {
                        if (!isPlaying)
                            break
                            
                        ; Применяем транслитерацию если нужно
                        charToSend := A_LoopField
                        if (PrintTranslit = "Включено")
                            charToSend := TranslitChar(A_LoopField)
                        
                        ; Отправляем символ
                        SendInput, %charToSend%
                        
                        ; Задержка между символами (регулируется скоростью)
                        Sleep, %actualDelay%
                        
                        ; Случайные микрозадержки для реалистичности (только на нормальных скоростях)
                        if (playbackSpeed <= 10 && Rand(1, 10) <= 3) {
                            Random, microDelay, 1, 20
                            Sleep, %microDelay%
                        }
                    }
                    
                    ; Отправляем Enter после каждого сообщения (кроме последнего)
                    if (isPlaying && currentWordIndex <= totalWords) {
                        SendInput, {Enter}
                        
                        ; Применяем задержку между сообщениями
                        if (messageDelay > 0) {
                            Sleep, %messageDelay%
                        }
                        else {
                            Sleep, 500  ; Стандартная пауза если задержка не задана
                        }
                    }
                    ; Если это последнее сообщение в повторе, применяем задержку после него
                    else if (isPlaying && messageDelay > 0) {
                        Sleep, %messageDelay%
                    }
                }
            }
        }
        else {
            ; Стандартное воспроизведение без ограничения слов
            Loop, Parse, processedText
            {
                if (!isPlaying)
                    break
                    
                ; Отправляем символ
                SendInput, %A_LoopField%
                
                ; Задержка между символами (регулируется скоростью)
                Sleep, %actualDelay%
                
                ; Случайные микрозадержки для реалистичности (только на нормальных скоростях)
                if (playbackSpeed <= 10 && Rand(1, 10) <= 3) {
                    Random, microDelay, 1, 20
                    Sleep, %microDelay%
                }
            }
            
            ; Применяем задержку после сообщения (только если есть задержка)
            if (isPlaying && messageDelay > 0) {
                Sleep, %messageDelay%
            }
        }
        
        ; Пауза между повторами (только если не режим "Нет" и не последний повтор)
        if (PlaybackRepeats != "Нет" && currentRepeat < repeatCount && isPlaying) {
            Sleep, 1000  ; 1 секунда между повторами
        }
    }
    
    isPlaying := false
    SB_SetText("Воспроизведение завершено", 1)
return

; === Функция применения ошибок при воспроизведении ===
ApplyPlaybackErrors(text, level) {
    if (level = "Нет")
        return text
    
    result := ""
    words := StrSplit(text, " ")
    
    for i, word in words {
        if (word = "") {
            result .= " "
            continue
        }
        
        ; Обрабатываем каждое слово
        processedWord := word
        
        if (level = "Низкий") {
            ; Низкий уровень: перестановка 1-2 букв
            if (StrLen(word) > 3 && Rand(1, 4) = 1) {
                pos := Rand(1, StrLen(word) - 1)
                processedWord := SubStr(word, 1, pos - 1) . SubStr(word, pos + 1, 1) . SubStr(word, pos, 1) . SubStr(word, pos + 2)
            }
        }
        else if (level = "Средний") {
            ; Средний уровень: больше перестановок и замен
            if (StrLen(word) > 2 && Rand(1, 3) = 1) {
                operations := Rand(1, 2)
                Loop % operations {
                    type := Rand(1, 3)
                    if (type = 1 && StrLen(processedWord) > 3) {
                        pos := Rand(1, StrLen(processedWord) - 1)
                        processedWord := SubStr(processedWord, 1, pos - 1) . SubStr(processedWord, pos + 1, 1) . SubStr(processedWord, pos, 1) . SubStr(processedWord, pos + 2)
                    }
                    else if (type = 2) {
                        ; Замена похожих букв
                        replacements := {"т":"п", "п":"т", "р":"р", "с":"ш", "ш":"с", "е":"и", "и":"е", "о":"а", "а":"о", "к":"х", "х":"к"}
                        pos := Rand(1, StrLen(processedWord))
                        char := SubStr(processedWord, pos, 1)
                        if (replacements.HasKey(char)) {
                            processedWord := SubStr(processedWord, 1, pos - 1) . replacements[char] . SubStr(processedWord, pos + 1)
                        }
                    }
                }
            }
        }
        else if (level = "Высокий") {
            ; Высокий уровень: множественные ошибки
            if (StrLen(word) > 2) {
                operations := Rand(1, 3)
                Loop % operations {
                    type := Rand(1, 4)
                    if (type = 1 && StrLen(processedWord) > 3) {
                        ; Перестановка
                        pos := Rand(1, StrLen(processedWord) - 1)
                        processedWord := SubStr(processedWord, 1, pos - 1) . SubStr(processedWord, pos + 1, 1) . SubStr(processedWord, pos, 1) . SubStr(processedWord, pos + 2)
                    }
                    else if (type = 2) {
                        ; Замена
                        replacements := {"т":"п", "п":"т", "р":"р", "с":"ш", "ш":"с", "е":"и", "и":"е", "о":"а", "а":"о", "к":"х", "х":"к", "й":"ы", "ы":"й", "ь":"ъ", "ъ":"ь", "г":"ж", "ж":"г"}
                        pos := Rand(1, StrLen(processedWord))
                        char := SubStr(processedWord, pos, 1)
                        if (replacements.HasKey(char)) {
                            processedWord := SubStr(processedWord, 1, pos - 1) . replacements[char] . SubStr(processedWord, pos + 1)
                        }
                    }
                    else if (type = 3) {
                        ; Добавление лишней буквы
                        pos := Rand(1, StrLen(processedWord))
                        extraChars := "аеиоуыэюяйь"
                        Random, charIdx, 1, % StrLen(extraChars)
                        extraChar := SubStr(extraChars, charIdx, 1)
                        processedWord := SubStr(processedWord, 1, pos) . extraChar . SubStr(processedWord, pos + 1)
                    }
                }
            }
        }
        else if (level = "Экстремальный") {
            ; Экстремальный уровень: максимальное искажение
            if (StrLen(word) > 1) {
                operations := Rand(2, 5)
                Loop % operations {
                    type := Rand(1, 5)
                    if (type = 1 && StrLen(processedWord) > 2) {
                        ; Перестановка
                        pos := Rand(1, StrLen(processedWord) - 1)
                        processedWord := SubStr(processedWord, 1, pos - 1) . SubStr(processedWord, pos + 1, 1) . SubStr(processedWord, pos, 1) . SubStr(processedWord, pos + 2)
                    }
                    else if (type = 2) {
                        ; Замена
                        allChars := "абвгдеёжзийклмнопрстуфхцчшщъыьэюя"
                        pos := Rand(1, StrLen(processedWord))
                        Random, charIdx, 1, % StrLen(allChars)
                        newChar := SubStr(allChars, charIdx, 1)
                        processedWord := SubStr(processedWord, 1, pos - 1) . newChar . SubStr(processedWord, pos + 1)
                    }
                    else if (type = 3) {
                        ; Удаление буквы
                        if (StrLen(processedWord) > 2) {
                            pos := Rand(1, StrLen(processedWord))
                            processedWord := SubStr(processedWord, 1, pos - 1) . SubStr(processedWord, pos + 1)
                        }
                    }
                    else if (type = 4) {
                        ; Добавление лишней буквы
                        pos := Rand(1, StrLen(processedWord))
                        allChars := "абвгдеёжзийклмнопрстуфхцчшщъыьэюя"
                        Random, charIdx, 1, % StrLen(allChars)
                        extraChar := SubStr(allChars, charIdx, 1)
                        processedWord := SubStr(processedWord, 1, pos) . extraChar . SubStr(processedWord, pos + 1)
                    }
                }
            }
        }
        
        result .= processedWord . " "
    }
    
    return Trim(result)
}

; === Остановить воспроизведение ===
StopPlayback:
    isPlaying := false
    SB_SetText("Воспроизведение остановлено", 1)
return

; === Горячие клавиши воспроизведения ===
F3::Gosub, PlayRecording
F4::Gosub, StopPlayback

; === Сохранить запись (отдельная функция для кнопки) ===
SaveRecording:
    if (recordedText = "") {
        MsgBox, 48, Нет текста, Нет записанного текста для сохранения!
        return
    }
    
    Gui, 1:Submit, NoHide
    
    finalText := recordedText
    
    ; Обрабатываем текст
    if (RecordRemoveDuplicates) {
        lines := StrSplit(finalText, "`n")
        uniqueLines := []
        for i, line in lines {
            line := Trim(line)
            if (line != "" && !Contains(uniqueLines, line)) {
                uniqueLines.Push(line)
            }
        }
        finalText := ""
        for i, line in uniqueLines {
            finalText .= line . "`n"
        }
        finalText := Trim(finalText, "`n")
    }
    
    if (RecordIncludeTimestamps) {
        FormatTime, currentTime,, dd.MM.yyyy HH:mm:ss
        finalText := "[Запись от " . currentTime . "]`n`n" . finalText . "`n`n[Конец записи]"
    }
    
    if (RecordMaxChars > 0 && StrLen(finalText) > RecordMaxChars) {
        finalText := SubStr(finalText, 1, RecordMaxChars)
        finalText .= "`n`n[Текст обрезан]"
    }
    
    ; Сохраняем в файл
    fileName := RecordFileName
    if (fileName = "") {
        fileName := "recorded_text"
    }
    
    FormatTime, fileDate,, yyyy-MM-dd_HH-mm-ss
    fullFileName := fileName . "_" . fileDate . ".txt"
    fullPath := RecordFolder . "\" . fullFileName
    
    ; Создаем папку если не существует
    if (!FileExist(RecordFolder))
        FileCreateDir, %RecordFolder%
    
    FileDelete, %fullPath%
    FileAppend, %finalText%, %fullPath%, UTF-8
    
    if (FileExist(fullPath)) {
        textLength := StrLen(finalText)
        linesCount := StrSplit(finalText, "`n").Length()
        
        MsgBox, 64, Успех, Текст сохранен в файл!`n`nФайл: %fullFileName%`nПапка: %RecordFolder%`n`nСимволов: %textLength%`nСтрок: %linesCount%
        SB_SetText("Текст сохранен в файл", 1)
    } else {
        MsgBox, 16, Ошибка, Не удалось сохранить файл!`nПроверьте путь: %RecordFolder%
    }
return

; === Начать запись ===
StartRecording:
    Gui, 1:Submit, NoHide
    isRecording := true
    recordedText := ""
    recordStartTime := A_TickCount
    ; Инициализируем/сбрасываем статистику
    Gosub, ResetStats
    stat_startTime := A_TickCount
    
    ; Обновляем статус
    GuiControl,, RecordStatus, 🎙 Запись...
    GuiControl, +cGreen, RecordStatus
    GuiControl,, RecordedTextDisplay, 
    GuiControl,, RecordDuration, 0 сек
    
    ; Запускаем таймер обновления времени
    SetTimer, UpdateRecordTime, 1000
    
    SB_SetText("Запись начата - печатайте в любом окне!", 1)
    TrayTip, Запись текста, Запись начата! Печатайте в любом окне., 3, 1
return

; === Остановить запись ===
StopRecording:
    if (!isRecording && !isPlaying) {
        MsgBox Запись не активна!
        return
    }
    
    if (isRecording) {
        isRecording := false
        SetTimer, UpdateRecordTime, Off
        
        ; Обновляем статус
        GuiControl,, RecordStatus, ⏹ Выключено
        GuiControl, +cRed, RecordStatus
        
        ; Сохраняем запись если есть текст
        if (recordedText != "") {
            SaveRecording()
        } else {
            MsgBox, 48, Нет текста, Не было записано ни одного символа!
        }
    }
    
    if (isPlaying) {
        isPlaying := false
    }
    
    SB_SetText("Остановлено", 1)
return

; === Перехват клавиш во время записи ===
#If isRecording

; Английские буквы
~a::RecordKey("a")
~b::RecordKey("b")
~c::RecordKey("c")
~d::RecordKey("d")
~e::RecordKey("e")
~f::RecordKey("f")
~g::RecordKey("g")
~h::RecordKey("h")
~i::RecordKey("i")
~j::RecordKey("j")
~k::RecordKey("k")
~l::RecordKey("l")
~m::RecordKey("m")
~n::RecordKey("n")
~o::RecordKey("o")
~p::RecordKey("p")
~q::RecordKey("q")
~r::RecordKey("r")
~s::RecordKey("s")
~t::RecordKey("t")
~u::RecordKey("u")
~v::RecordKey("v")
~w::RecordKey("w")
~x::RecordKey("x")
~y::RecordKey("y")
~z::RecordKey("z")

; Цифры
~1::RecordKey("1")
~2::RecordKey("2")
~3::RecordKey("3")
~4::RecordKey("4")
~5::RecordKey("5")
~6::RecordKey("6")
~7::RecordKey("7")
~8::RecordKey("8")
~9::RecordKey("9")
~0::RecordKey("0")

; Специальные клавиши
~Space::
    recordedText .= " "
    GuiControl,, RecordedTextDisplay, %recordedText%
return

~Enter::
    recordedText .= "`n"
    GuiControl,, RecordedTextDisplay, %recordedText%
return

~Tab::
    recordedText .= "    "
    GuiControl,, RecordedTextDisplay, %recordedText%
return

~Backspace::
    Gosub, RecordBackspace
return

; Русские буквы
~а::RecordKey("а")
~б::RecordKey("б")
~в::RecordKey("в")
~г::RecordKey("г")
~д::RecordKey("д")
~е::RecordKey("е")
~ё::RecordKey("ё")
~ж::RecordKey("ж")
~з::RecordKey("з")
~и::RecordKey("и")
~й::RecordKey("й")
~к::RecordKey("к")
~л::RecordKey("л")
~м::RecordKey("м")
~н::RecordKey("н")
~о::RecordKey("о")
~п::RecordKey("п")
~р::RecordKey("р")
~с::RecordKey("с")
~т::RecordKey("т")
~у::RecordKey("у")
~ф::RecordKey("ф")
~х::RecordKey("х")
~ц::RecordKey("ц")
~ч::RecordKey("ч")
~ш::RecordKey("ш")
~щ::RecordKey("щ")
~ъ::RecordKey("ъ")
~ы::RecordKey("ы")
~ь::RecordKey("ь")
~э::RecordKey("э")
~ю::RecordKey("ю")
~я::RecordKey("я")

#If

; === Функция записи клавиш ===
RecordKey(key) {
    global recordedText, stat_totalChars, stat_startTime, stat_lastKeyTime, stat_pauses, stat_minPause, stat_maxPause, stat_sumPauses, stat_currentCorrectionSeries, stat_correctionSeriesCount, stat_correctionSeriesLengths
    global recordingKeyTimes, recordingLastKeyTime, RecordRememberTiming

    recordedText .= key
    GuiControl,, RecordedTextDisplay, %recordedText%
    
    ; Обновляем счётчик символов
    charCount := StrLen(recordedText)
    wordCount := 0
    Loop, Parse, recordedText, %A_Space%
        if (A_LoopField != "")
            wordCount++
    lineCount := StrSplit(recordedText, "`n").Length()
    GuiControl,, RecordCharCount, %charCount%

    now := A_TickCount
    if (stat_startTime = 0)
        stat_startTime := now

    ; Вычисляем задержку с предыдущей клавишей
    delay := 0
    if (stat_lastKeyTime > 0) {
        delay := now - stat_lastKeyTime
        stat_pauses.Push(delay)
        stat_sumPauses += delay
        if (stat_minPause = 0 || delay < stat_minPause)
            stat_minPause := delay
        if (delay > stat_maxPause)
            stat_maxPause := delay
    }
    stat_lastKeyTime := now

    ; Запоминаем тайминги если включено
    Gui, Submit, NoHide
    if (RecordRememberTiming) {
        if (!recordingKeyTimes)
            recordingKeyTimes := []
        recordingKeyTimes.Push({char: key, delay: delay, timestamp: now})
    }

    stat_totalChars += 1

    ; If we were in a correction series, finalize it now
    if (stat_currentCorrectionSeries > 0) {
        stat_correctionSeriesLengths.Push(stat_currentCorrectionSeries)
        stat_correctionSeriesCount += 1
        stat_currentCorrectionSeries := 0
    }
}

; === Очистить запись ===
ClearRecording:
    global recordingKeyTimes
    recordedText := ""
    recordingKeyTimes := []
    GuiControl,, RecordedTextDisplay, 
    GuiControl,, RecordDuration, 0 сек
    GuiControl,, RecordCharCount, 0
    Gosub, ResetStats
    SB_SetText("Запись очищена", 1)
return

; === Добавить текст из буфера обмена ===
AddFromClipboard:
    if (!isRecording) {
        MsgBox Сначала начните запись (F5)!
        return
    }
    
    savedClipboard := ClipboardAll
    Clipboard := ""
    Send, ^c
    ClipWait, 1
    
    if (!ErrorLevel && Clipboard != "") {
        recordedText .= Clipboard . "`n"
        GuiControl,, RecordedTextDisplay, %recordedText%
        SB_SetText("Текст добавлен из буфера", 2)
    }
    
    Clipboard := savedClipboard
    savedClipboard := ""
return

; === Добавить текст вручную ===
AddManualText:
    if (!isRecording) {
        MsgBox Сначала начните запись (F5)!
        return
    }
    
    InputBox, userText, Ручной ввод текста, Введите текст для добавления в запись:,, 500, 300
    if (!ErrorLevel && userText != "") {
        recordedText .= userText . "`n"
        GuiControl,, RecordedTextDisplay, %recordedText%
        SB_SetText("Текст добавлен вручную", 2)
    }
return

; === Сохранить запись ===
SaveRecording() {
    global recordedText
    Gui, 1:Submit, NoHide
    
    if (recordedText = "") {
        MsgBox Нет записанного текста для сохранения!
        return
    }
    
    finalText := recordedText
    
    ; Обрабатываем текст
    if (RecordRemoveDuplicates) {
        lines := StrSplit(finalText, "`n")
        uniqueLines := []
        for i, line in lines {
            line := Trim(line)
            if (line != "" && !Contains(uniqueLines, line)) {
                uniqueLines.Push(line)
            }
        }
        finalText := ""
        for i, line in uniqueLines {
            finalText .= line . "`n"
        }
        finalText := Trim(finalText, "`n")
    }
    
    if (RecordIncludeTimestamps) {
        FormatTime, currentTime,, dd.MM.yyyy HH:mm:ss
        finalText := "[Запись от " . currentTime . "]`n`n" . finalText . "`n`n[Конец записи]"
    }
    
    if (RecordMaxChars > 0 && StrLen(finalText) > RecordMaxChars) {
        finalText := SubStr(finalText, 1, RecordMaxChars)
        finalText .= "`n`n[Текст обрезан]"
    }
    
    ; Сохраняем в файл
    fileName := RecordFileName
    if (fileName = "") {
        fileName := "recorded_text"
    }
    
    FormatTime, fileDate,, yyyy-MM-dd_HH-mm-ss
    fullFileName := fileName . "_" . fileDate . ".txt"
    fullPath := RecordFolder . "\" . fullFileName
    
    if (!FileExist(RecordFolder))
        FileCreateDir, %RecordFolder%
    
    FileDelete, %fullPath%
    FileAppend, %finalText%, %fullPath%, UTF-8
    
    if (FileExist(fullPath)) {
        textLength := StrLen(finalText)
        linesCount := StrSplit(finalText, "`n").Length()
        
        MsgBox, 64, Успех, Запись сохранена!`n`nФайл: %fullFileName%`nСимволов: %textLength%`nСтрок: %linesCount%
        SB_SetText("Запись сохранена", 1)
    } else {
        MsgBox, 16, Ошибка, Не удалось сохранить файл!
    }
}

; === Загрузить запись в основной текст ===
LoadRecordedText:
    if (recordedText = "") {
        MsgBox Нет записанного текста!
        return
    }
    
    GuiControl,, TypeText, %recordedText%
    textLength := StrLen(recordedText)
    SB_SetText("Запись загружена в основной текст", 1)
    MsgBox, 64, Успех, Текст загружен! Символов: %textLength%
return

; === Открыть папку с записями ===
OpenRecordsFolder:
    Gui, 1:Submit, NoHide
    if (!FileExist(RecordFolder))
        FileCreateDir, %RecordFolder%
    Run, %RecordFolder%
return

; === Обновление времени записи ===
UpdateRecordTime:
    if (isRecording) {
        duration := (A_TickCount - recordStartTime) // 1000
        GuiControl,, RecordDuration, %duration% сек
    }
    ; Обновляем панель статистики
    Gosub, UpdateStatsDisplay
return

; === Обработка нажатия Backspace (статистика) ===
RecordBackspace:
    global recordedText, stat_corrections, stat_currentCorrectionSeries, stat_lastKeyTime, stat_startTime, stat_pauses, stat_sumPauses, stat_minPause, stat_maxPause

    if (StrLen(recordedText) > 0) {
        recordedText := SubStr(recordedText, 1, -1)
        GuiControl,, RecordedTextDisplay, %recordedText%
    }

    stat_corrections += 1
    stat_currentCorrectionSeries += 1

    now := A_TickCount
    if (stat_startTime = 0)
        stat_startTime := now
    if (stat_lastKeyTime > 0) {
        pause := now - stat_lastKeyTime
        stat_pauses.Push(pause)
        stat_sumPauses += pause
        if (stat_minPause = 0 || pause < stat_minPause)
            stat_minPause := pause
        if (pause > stat_maxPause)
            stat_maxPause := pause
    }
    stat_lastKeyTime := now
return

; === Сброс статистики ===
ResetStats:
    global stat_totalChars, stat_startTime, stat_lastKeyTime, stat_pauses, stat_minPause, stat_maxPause, stat_sumPauses, stat_corrections, stat_currentCorrectionSeries, stat_correctionSeriesCount, stat_correctionSeriesLengths, stat_arrhythmia

    stat_totalChars := 0
    stat_startTime := 0
    stat_lastKeyTime := 0
    stat_pauses := []
    stat_minPause := 0
    stat_maxPause := 0
    stat_sumPauses := 0
    stat_corrections := 0
    stat_currentCorrectionSeries := 0
    stat_correctionSeriesCount := 0
    stat_correctionSeriesLengths := []
    stat_arrhythmia := 0

    ; Очистить отображение
    GuiControl,, StatTotalChars, 0
    GuiControl,, StatTotalTime, 0
    GuiControl,, StatMinPause, -
    GuiControl,, StatMaxPause, -
    GuiControl,, StatAvgPause, -
    GuiControl,, StatAvgHold, N/A
    GuiControl,, StatCPM, 0
    GuiControl,, StatWPM, 0
    GuiControl,, StatGross, 0
    GuiControl,, StatNet, 0
    GuiControl,, StatLoss, 0
    GuiControl,, StatArrhythmia, 0
    GuiControl,, StatCorrections, 0
    GuiControl,, StatCorrectionSeries, 0
return

; === Обновление/компиляция статистики для отображения ===
UpdateStatsDisplay:
    global stat_totalChars, stat_startTime, stat_lastKeyTime, stat_pauses, stat_minPause, stat_maxPause, stat_sumPauses, stat_corrections, stat_correctionSeriesCount, stat_correctionSeriesLengths, stat_arrhythmia

    if (stat_startTime = 0) {
        ; Нет данных
        return
    }

    ; Общее время в секундах
    now := A_TickCount
    duration_s := (now - stat_startTime) / 1000.0

    ; Паузы
    pausesCount := stat_pauses.Length()
    if (pausesCount > 0) {
        avgPause := stat_sumPauses / pausesCount
        ; вычисляем стандартное отклонение (аритмия)
        sumSq := 0
        for i, p in stat_pauses
            sumSq += (p - avgPause) * (p - avgPause)
        stddev := Sqrt(sumSq / pausesCount)
    } else {
        avgPause := 0
        stddev := 0
    }

    ; Скорости
    minutes := duration_s / 60.0
    if (minutes > 0) {
        cpm := Round(stat_totalChars / minutes)
        wpm_gross := Round((stat_totalChars / 5.0) / minutes)
        wpm_net := Round(((stat_totalChars - stat_corrections) / 5.0) / minutes)
    } else {
        cpm := 0
        wpm_gross := 0
        wpm_net := 0
    }

    ; Потери от исправлений — можно считать как количество удалённых символов (stat_corrections)
    loss := stat_corrections

    ; Обновляем GUI
    displayDuration := Round(duration_s)
    displayMinPause := (stat_minPause ? stat_minPause : "-")
    displayMaxPause := (stat_maxPause ? stat_maxPause : "-")
    displayAvgPause := (pausesCount ? Round(avgPause, 0) : "-")
    displayArr := Round(stddev, 1)

    GuiControl,, StatTotalChars, %stat_totalChars%
    GuiControl,, StatTotalTime, %displayDuration%
    GuiControl,, StatMinPause, %displayMinPause%
    GuiControl,, StatMaxPause, %displayMaxPause%
    GuiControl,, StatAvgPause, %displayAvgPause%
    GuiControl,, StatAvgHold, % "N/A"
    GuiControl,, StatCPM, %cpm%
    GuiControl,, StatWPM, %wpm_gross%
    GuiControl,, StatGross, %wpm_gross%
    GuiControl,, StatNet, %wpm_net%
    GuiControl,, StatLoss, %loss%
    GuiControl,, StatArrhythmia, %displayArr%
    GuiControl,, StatCorrections, %stat_corrections%
    GuiControl,, StatCorrectionSeries, %stat_correctionSeriesCount%
return

; === Экспорт статистики в CSV ===
ExportStats:
    global stat_totalChars, stat_startTime, stat_pauses, stat_minPause, stat_maxPause, stat_sumPauses, stat_corrections

    if (stat_startTime = 0) {
        MsgBox, 48, Нет данных, Нет статистики для экспорта.
        return
    }

    now := A_TickCount
    duration_s := (now - stat_startTime) / 1000.0
    pausesCount := stat_pauses.Length()
    avgPause := (pausesCount ? stat_sumPauses / pausesCount : 0)

    csv := "Metric,Value`n"
    csv .= "TotalChars," . stat_totalChars . "`n"
    csv .= "DurationSec," . Round(duration_s) . "`n"
    csv .= "MinPauseMs," . stat_minPause . "`n"
    csv .= "MaxPauseMs," . stat_maxPause . "`n"
    csv .= "AvgPauseMs," . Round(avgPause,0) . "`n"
    csv .= "Corrections," . stat_corrections . "`n"

    if (!FileExist(appDataDir . "\records"))
        FileCreateDir, % appDataDir . "\records"
    FormatTime, fileDate,, yyyy-MM-dd_HH-mm-ss
    filePath := appDataDir . "\records\typing_stats_" . fileDate . ".csv"
    FileDelete, %filePath%
    FileAppend, %csv%, %filePath%, UTF-8

    if (FileExist(filePath))
        MsgBox, 64, Экспорт, Статистика экспортирована в:`n%filePath%
    else
        MsgBox, 16, Ошибка, Не удалось сохранить файл.
return

; === Отложенный запрос лицензии (вызов после создания GUI) ===
DeferredLicensePrompt:
    ; Если уже валидирована — ничего не делаем
    if (LicenseValidated)
        return
    ; Попробуем автоматическую проверку (если есть сохранённый ключ)
    if (LicenseKeyLocal != "") {
        Gosub, ValidateLicense
        if (LicenseValidated)
            return
    }

    ; Запросим ключ у пользователя
    MsgBox, 64, Лицензия, Эта копия скрипта защищена лицензией. Нажмите OK чтобы ввести ключ или Cancel чтобы выйти.
    InputBox, userKey, Введите лицензионный ключ, Введите ключ лицензии:, , 400, 140
    if ErrorLevel
    {
        MsgBox, 48, Не введён ключ, Скрипт будет закрыт.
        ExitApp
    }
    LicenseKeyLocal := userKey
    Gosub, ValidateLicense
    if (!LicenseValidated) {
        MsgBox, 16, Неверный ключ, Ключ не прошёл проверку. Скрипт будет закрыт.
        ExitApp
    }
return

; === Сохранить URL лицензии из GUI ===
SaveLicenseURL:
    MsgBox, 48, Недоступно, URL лицензии фиксирован и не может быть изменён.
return

; === Ввести ключ вручную через GUI ===
EnterLicenseKey:
    InputBox, userKey, Введите лицензионный ключ, Введите ключ лицензии:, , 400, 140
    if ErrorLevel
        return
    LicenseKeyLocal := userKey
    Gosub, ValidateLicense
    if (LicenseValidated) {
        IniWrite, %LicenseKeyLocal%, %appDataDir%\AutoTyper.ini, %LicenseIniSection%, Key
        GuiControl,, LicenseStatus, Активирована
        MsgBox, 64, Активировано, Лицензия успешно активирована.
    } else {
        GuiControl,, LicenseStatus, Не активирована
        MsgBox, 16, Ошибка, Ключ не найден или сервер недоступен.
    }
return

; === Проверка лицензии (скачивает список ключей с LicenseURL и ищет введённый ключ) ===
ValidateLicense:
    global LicenseURL, LicenseKeyLocal, LicenseValidated

    if (LicenseKeyLocal = "")
        return

    ; Попытка скачать файл лицензий (INI)
    tempFile := A_Temp . "\autotyper_licenses_tmp.ini"
    cacheFile := appDataDir . "\licenses_cache.ini"
    FileDelete, %tempFile%
    url := LicenseURL
    ; Нормализуем некоторые варианты URL (github.com/.../blob/... и /refs/heads/)
    if InStr(url, "github.com") and InStr(url, "/blob/") {
        tmp := url
        StringReplace, tmp, tmp, https://github.com/, https://raw.githubusercontent.com/, All
        StringReplace, tmp, tmp, http://github.com/, http://raw.githubusercontent.com/, All
        StringReplace, tmp, tmp, "/blob/", "/", All
        url := tmp
    }
    if InStr(url, "/refs/heads/") {
        StringReplace, url, url, "/refs/heads/", "/", All
    }

    UrlDownloadToFile, %url%, %tempFile%
    if (ErrorLevel) {
        ; Фоллбек на локальный кэш (если хоть раз скачали).
        if (FileExist(cacheFile)) {
            tempFile := cacheFile
        } else {
            ToolTip, Не удалось проверить ключ онлайн. Попробуйте позже., 5, 5
            Sleep, 1000
            ToolTip
            LicenseValidated := false
            return
        }
    } else {
        FileCopy, %tempFile%, %cacheFile%, 1
    }

    hwid := StrLower(GetHWID())
    hwSec := "HWID_" . SanitizeIniSection(hwid)
    keySec := "Key_" . SanitizeIniSection(Trim(LicenseKeyLocal))

    IniRead, hwStatus, %tempFile%, %hwSec%, Status, allowed
    if (StrLower(Trim(hwStatus)) = "blocked") {
        LicenseValidated := false
        GuiControl,, LicenseStatus, HWID заблокирован
        return
    }

    IniRead, keyStatus, %tempFile%, %keySec%, Status,
    keyStatus := StrLower(Trim(keyStatus))
    if (keyStatus = "") {
        LicenseValidated := false
        GuiControl,, LicenseStatus, Не активирована
        return
    }
    if (keyStatus = "deleted" || keyStatus = "blocked") {
        LicenseValidated := false
        GuiControl,, LicenseStatus, Ключ заблокирован
        return
    }
    if (keyStatus = "frozen") {
        LicenseValidated := false
        GuiControl,, LicenseStatus, Ключ заморожен
        return
    }

    IniRead, keyExpires, %tempFile%, %keySec%, Expires,
    keyExpires := Trim(keyExpires)
    if (keyExpires != "" && LicenseIsExpired(keyExpires)) {
        LicenseValidated := false
        GuiControl,, LicenseStatus, Ключ истёк
        return
    }

    IniRead, allowedHwids, %tempFile%, %keySec%, HWIDs, *
    allowedHwids := Trim(allowedHwids)
    ok := false
    if (allowedHwids = "*" || allowedHwids = "")
        ok := true
    else {
        Loop, Parse, allowedHwids, |
        {
            one := StrLower(Trim(A_LoopField))
            if (one = "")
                continue
            if (one = hwid) {
                ok := true
                break
            }
        }
    }

    if (!ok) {
        LicenseValidated := false
        GuiControl,, LicenseStatus, HWID не привязан
        return
    }

    LicenseValidated := true
    IniWrite, %LicenseKeyLocal%, %appDataDir%\AutoTyper.ini, %LicenseIniSection%, Key
    GuiControl,, LicenseStatus, Активирована
    ToolTip, Лицензия подтверждена., 5, 5
    Sleep, 800
    ToolTip
return

; === AUTO-UPDATE ===
AutoUpdateCheck:
    global AppVersion, UpdateManifestURL

    tmpIni := A_Temp . "\autotyper_update_tmp.ini"
    FileDelete, %tmpIni%
    UrlDownloadToFile, %UpdateManifestURL%, %tmpIni%
    if (ErrorLevel)
        return

    IniRead, remoteVer, %tmpIni%, Update, Version,
    IniRead, remoteUrl, %tmpIni%, Update, Url,
    IniRead, remoteSha, %tmpIni%, Update, Sha256,
    remoteVer := Trim(remoteVer)
    remoteUrl := Trim(remoteUrl)
    remoteSha := Trim(remoteSha)
    if (remoteVer = "" || remoteUrl = "")
        return

    if (CompareVersions(remoteVer, AppVersion) <= 0)
        return

    newPath := A_ScriptFullPath . ".new"
    FileDelete, %newPath%
    UrlDownloadToFile, %remoteUrl%, %newPath%
    if (ErrorLevel) {
        FileDelete, %newPath%
        return
    }

    if (remoteSha != "") {
        if (!VerifyFileSha256(newPath, remoteSha)) {
            FileDelete, %newPath%
            return
        }
    }

    ; Применяем обновление через .cmd (нельзя перезаписать запущенный .ahk напрямую).
    cmdPath := A_Temp . "\autotyper_apply_update.cmd"
    bakPath := A_ScriptFullPath . ".bak"
    exe := A_AhkPath
    script := A_ScriptFullPath
    pid := DllCall("GetCurrentProcessId")

    cmd := "@echo off`r`n"
        . "setlocal`r`n"
        . ":wait`r`n"
        . "tasklist /FI ""PID eq " . pid . """ 2>NUL | find """ . pid . """ >NUL`r`n"
        . "if not errorlevel 1 (`r`n"
        . "  ping 127.0.0.1 -n 2 >NUL`r`n"
        . "  goto wait`r`n"
        . ")`r`n"
        . "copy /Y """ . script . """ """ . bakPath . """ >NUL`r`n"
        . "move /Y """ . newPath . """ """ . script . """ >NUL`r`n"
        . "start """" """ . exe . """ """ . script . """`r`n"
        . "endlocal`r`n"

    FileDelete, %cmdPath%
    FileAppend, %cmd%, %cmdPath%
    Run, %ComSpec% /c ""%cmdPath%"",, Hide
    ExitApp
return

GetHWID() {
    ; Стабильный идентификатор машины (не криптозащита).
    RegRead, guid, HKEY_LOCAL_MACHINE, SOFTWARE\Microsoft\Cryptography, MachineGuid
    if (guid != "")
        return Trim(guid)
    ; Фоллбек: WMI UUID
    try {
        wmi := ComObjGet("winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\cimv2")
        col := wmi.ExecQuery("Select UUID from Win32_ComputerSystemProduct")
        for item in col {
            if (item.UUID != "")
                return Trim(item.UUID)
        }
    } catch e {
    }
    return A_ComputerName
}

SanitizeIniSection(s) {
    s := Trim(s)
    if (s = "")
        return "EMPTY"
    s := RegExReplace(s, "[^0-9A-Za-z_-]", "_")
    s := RegExReplace(s, "_{2,}", "_")
    s := Trim(s, "_")
    if (StrLen(s) > 120)
        s := SubStr(s, 1, 120)
    return s
}

StrLower(s) {
    StringLower, out, s
    return out
}

CompareVersions(a, b) {
    ; Returns: 1 if a>b, 0 if a=b, -1 if a<b
    a := Trim(a), b := Trim(b)
    a := RegExReplace(a, "[^0-9.]", ".")
    b := RegExReplace(b, "[^0-9.]", ".")
    aa := StrSplit(a, ".")
    bb := StrSplit(b, ".")
    max := (aa.Length() > bb.Length()) ? aa.Length() : bb.Length()
    Loop, %max% {
        av := (A_Index <= aa.Length() && aa[A_Index] != "") ? (aa[A_Index] + 0) : 0
        bv := (A_Index <= bb.Length() && bb[A_Index] != "") ? (bb[A_Index] + 0) : 0
        if (av > bv)
            return 1
        if (av < bv)
            return -1
    }
    return 0
}

VerifyFileSha256(path, expectedHex) {
    expectedHex := StrLower(RegExReplace(expectedHex, "[^0-9a-f]", ""))
    if (expectedHex = "")
        return true

    tmpOut := A_Temp . "\autotyper_sha256.txt"
    FileDelete, %tmpOut%
    RunWait, %ComSpec% /c certutil -hashfile "%path%" SHA256 ^> "%tmpOut%",, Hide
    if (!FileExist(tmpOut))
        return false
    FileRead, out, %tmpOut%
    RegExMatch(out, "i)([0-9a-f]{64})", m)
    got := StrLower(m1)
    return (got != "" && got = expectedHex)
}

LicenseIsExpired(expires) {
    ; expires formats supported:
    ; - YYYY-MM-DD
    ; - YYYYMMDD
    ; - YYYYMMDDHH24MISS
    s := RegExReplace(Trim(expires), "[^0-9]", "")
    if (StrLen(s) < 8)
        return false
    expDate := SubStr(s, 1, 8)
    today := SubStr(A_Now, 1, 8)
    return (expDate < today)
}

; === Функция проверки наличия строки в массиве ===
Contains(arr, value) {
    for i, item in arr {
        if (item = value) {
            return true
        }
    }
    return false
}

; === Функция нормализации слова (удаление знаков препинания и приведение к нижнему регистру) ===
NormalizeWord(word) {
    ; Удаляем знаки препинания в начале и конце слова (точки, запятые, восклицательные и вопросительные знаки, скобки и т.д.)
    word := RegExReplace(word, "^[.,!?;:()\[\]{}""'«»…—–\-]+|[.,!?;:()\[\]{}""'«»…—–\-]+$", "")
    ; Приводим к нижнему регистру для сравнения (без учета регистра)
    StringLower, word, word
    return word
}

; === Функция проверки, является ли слово игнорируемым ===
IsIgnoredWord(word, ignoredWordsList) {
    normalizedWord := NormalizeWord(word)
    for i, ignoredWord in ignoredWordsList {
        normalizedIgnored := NormalizeWord(ignoredWord)
        if (normalizedWord = normalizedIgnored) {
            return true
        }
    }
    return false
}

; === Функция фильтрации игнорируемых слов из строки ===
FilterIgnoredWordsFromLine(line, ignoredWordsList) {
    if (ignoredWordsList.Length() = 0)
        return line
    
    words := StrSplit(line, " ")
    filteredWords := []
    for i, word in words {
        if (word != "" && !IsIgnoredWord(word, ignoredWordsList)) {
            filteredWords.Push(word)
        }
    }
    
    ; Собираем строку обратно
    result := ""
    for i, word in filteredWords {
        result .= (result ? " " : "") . word
    }
    return result
}

; === Горячие клавиши записи ===
F5::Gosub, StartRecording
F6::Gosub, StopRecording

; === Открыть настройки ошибок ===
OpenErrorSettings:
    Gui, ErrorSettings:New, +Owner1
    Gui, ErrorSettings:Font, s10, Segoe UI
    Gui, ErrorSettings:Color, White
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; 📝 ЗАГОЛОВОК
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, ErrorSettings:Add, Text, x15 y10 w570 h30 c0066CC Center, ⚠️ НАСТРОЙКИ ГЕНЕРАТОРА ОШИБОК
    Gui, ErrorSettings:Font, s9, Segoe UI
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; 🧠 УМНЫЙ РЕЖИМ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, ErrorSettings:Add, GroupBox, x10 y45 w580 h50, 🧠 Режим генерации
    Gui, ErrorSettings:Add, Checkbox, vSmartErrorMode x20 y65, Умный режим (автоматическая генерация вариаций на основе клавиатуры)
    GuiControl,, SmartErrorMode, %smartErrorMode%
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; 📝 СЛОВА
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, ErrorSettings:Add, GroupBox, x10 y100 w280 h220, 📝 Слова для ошибок
    Gui, ErrorSettings:Add, Text, x20 y120, Добавить слово:
    Gui, ErrorSettings:Add, Edit, vErrorWordInput x20 y140 w180 h24
    Gui, ErrorSettings:Add, Button, x210 y139 w70 h26 gAddErrorWord, ➕ Добав.
    Gui, ErrorSettings:Add, ListBox, vErrorWordsList x20 y175 w260 h115 gErrorWordSelected
    Gui, ErrorSettings:Add, Button, x20 y295 w125 h22 gRemoveErrorWord, ❌ Удалить слово
    Gui, ErrorSettings:Add, Button, x155 y295 w125 h22 gClearErrorWords, 🗑️ Очистить
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; 🔄 ВАРИАЦИИ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, ErrorSettings:Add, GroupBox, x300 y100 w290 h220, 🔄 Вариации ошибок
    Gui, ErrorSettings:Add, Text, x310 y120, Добавить вариацию:
    Gui, ErrorSettings:Add, Edit, vErrorVariationInput x310 y140 w120 h24
    Gui, ErrorSettings:Add, Button, x440 y139 w65 h26 gAddErrorVariation, ➕ Добав.
    Gui, ErrorSettings:Add, Button, x510 y139 w70 h26 gGenerateErrorVariations, 🔄 Генер.
    Gui, ErrorSettings:Add, ListBox, vErrorVariationsList x310 y175 w270 h115
    Gui, ErrorSettings:Add, Button, x310 y295 w130 h22 gRemoveErrorVariation, ❌ Удалить вариацию
    Gui, ErrorSettings:Add, Button, x450 y295 w130 h22 gAutoGenerateAll, 🤖 Авто-все
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ⚙️ НАСТРОЙКИ ПРИМЕНЕНИЯ ОШИБОК
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, ErrorSettings:Add, GroupBox, x10 y325 w580 h320, ⚙️ Настройки применения ошибок
    
    ; Строка 1: Количество слов и Позиция ошибок
    Gui, ErrorSettings:Add, Text, x25 y350 w150 h20, Количество слов:
    Gui, ErrorSettings:Add, Edit, vErrorWordCount x180 y347 w70 h22 Number
    Gui, ErrorSettings:Add, UpDown, vErrorWordCountUpDown Range1-1000, 5
    
    Gui, ErrorSettings:Add, Text, x300 y350 w100 h20, Позиция:
    Gui, ErrorSettings:Add, DropDownList, vErrorPosition x400 y347 w175, Каждое N-слово|Поочерёдно|Случайно N-слов
    
    ; Строка 2: Частота и Шанс
    Gui, ErrorSettings:Add, Text, x25 y380 w150 h20, Частота (каждое N):
    Gui, ErrorSettings:Add, Edit, vErrorFrequency x180 y377 w70 h22 Number
    Gui, ErrorSettings:Add, UpDown, vErrorFrequencyUpDown Range1-100, 3
    
    Gui, ErrorSettings:Add, Text, x300 y380 w100 h20, Шанс (`%):
    Gui, ErrorSettings:Add, Edit, vErrorChance x400 y377 w70 h22 Number
    Gui, ErrorSettings:Add, UpDown, vErrorChanceUpDown Range0-100, 50
    
    ; Строка 3: Тип ошибок (на всю ширину)
    Gui, ErrorSettings:Add, Text, x25 y415 w150 h20, Тип ошибок:
    Gui, ErrorSettings:Add, DropDownList, vErrorType x180 y412 w395 gErrorTypeChanged, Обычный|Перемешивание букв|Двойной-ввод букв|Ввод случайных русских букв|Ввод случайных английских букв|Ввод случайных символов
    
    ; Строка 4: Динамические поля (скрытые по умолчанию)
    Gui, ErrorSettings:Add, Text, vErrorCountLabel x25 y450 w200 h20 Hidden, Количество перемешиваний:
    Gui, ErrorSettings:Add, Edit, vErrorCount x230 y447 w70 h22 Number Hidden
    Gui, ErrorSettings:Add, UpDown, vErrorCountUpDown Range1-10 Hidden, 2
    
    Gui, ErrorSettings:Add, Text, vRandomCharsLabel x25 y450 w200 h20 Hidden, Кол-во случайных символов:
    Gui, ErrorSettings:Add, Edit, vRandomCharsCount x230 y447 w70 h22 Number Hidden
    Gui, ErrorSettings:Add, UpDown, vRandomCharsCountUpDown Range1-20 Hidden, 1
    
    Gui, ErrorSettings:Add, Checkbox, vRandomCharsInComplexWords x320 y450 w250 Hidden, Только в сложных словах
    
    Gui, ErrorSettings:Add, Text, vRandomCharsPerWordLabel x25 y480 w200 h20 Hidden, Символов на слово:
    Gui, ErrorSettings:Add, Edit, vRandomCharsPerWord x230 y477 w70 h22 Number Hidden
    Gui, ErrorSettings:Add, UpDown, vRandomCharsPerWordUpDown Range1-10 Hidden, 1
    
    ; Разделитель
    Gui, ErrorSettings:Add, Text, x25 y515 w550 h1 0x10
    
    ; Дополнительные настройки (чекбоксы в ряд)
    Gui, ErrorSettings:Add, Text, x25 y525 w150 h20 c666666, Дополнительно:
    Gui, ErrorSettings:Add, Checkbox, vErrorCapitalize x25 y545 w180, Сохранять заглавные
    Gui, ErrorSettings:Add, Checkbox, vErrorPreserveLength x210 y545 w150, Сохранять длину
    Gui, ErrorSettings:Add, Checkbox, vErrorSmartMode x365 y545 w200, Умный режим
    
    ; Превью с рамкой
    Gui, ErrorSettings:Add, GroupBox, x25 y575 w550 h55, 👁️ Предпросмотр
    Gui, ErrorSettings:Add, Text, x40 y595 w80 h20, Исходное:
    Gui, ErrorSettings:Add, Text, x120 y595 w150 h20 c0066CC, "привет"
    Gui, ErrorSettings:Add, Text, x280 y595 w80 h20, Результат:
    Gui, ErrorSettings:Add, Text, vErrorPreview x360 y595 w200 h20 cCC0000, "првиет"
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; 🔘 КНОПКИ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, ErrorSettings:Add, Button, x10 y655 w115 h35 gErrorSettingsOK, ✓ Сохранить
    Gui, ErrorSettings:Add, Button, x135 y655 w115 h35 gErrorSettingsCancel, ✗ Отмена
    Gui, ErrorSettings:Add, Button, x260 y655 w115 h35 gOpenAdvancedErrorSettings, 🔧 Дополнительные
    Gui, ErrorSettings:Add, Button, x385 y655 w100 h35 gOpenPercentSettings, Проценты
    Gui, ErrorSettings:Add, Button, x495 y655 w95 h35 gExportErrorSettings, 📤 Экспорт
    
    ; Загружаем данные
    UpdateErrorWordsList()
    LoadErrorApplicationSettings()
    
    Gui, ErrorSettings:Show, w600 h700, ⚠️ Настройки ошибок
return

; === Обновить список слов в окне настроек ===
UpdateErrorWordsList() {
    global errorWordVariations
    GuiControl,, ErrorWordsList, |
    for word, variations in errorWordVariations {
        GuiControl,, ErrorWordsList, %word%
    }
    GuiControl, Choose, ErrorWordsList, 0
    GuiControl,, ErrorVariationsList, |
}

; === Выбрано слово из списка ===
ErrorWordSelected:
    Gui, ErrorSettings:Submit, NoHide
    global errorWordVariations
    
    selectedWord := ""
    GuiControlGet, selectedWord,, ErrorWordsList
    
    if (selectedWord != "") {
        ; Загружаем вариации для выбранного слова
        variations := errorWordVariations[selectedWord]
        GuiControl,, ErrorVariationsList, |
        if (IsObject(variations)) {
            for i, variation in variations {
                GuiControl,, ErrorVariationsList, %variation%
            }
        }
    }
return

; === Добавить слово ===
AddErrorWord:
    Gui, ErrorSettings:Submit, NoHide
    global errorWordVariations
    
    word := Trim(ErrorWordInput)
    if (word = "") {
        MsgBox, 48, Ошибка, Введите слово!
        return
    }
    
    StringLower, word, word
    if (!errorWordVariations.HasKey(word)) {
        errorWordVariations[word] := []
        UpdateErrorWordsList()
        GuiControl,, ErrorWordInput,
        GuiControl, ChooseString, ErrorWordsList, %word%
        Gosub, ErrorWordSelected
    } else {
        MsgBox, 48, Ошибка, Слово "%word%" уже добавлено!
    }
return

; === Удалить слово ===
RemoveErrorWord:
    Gui, ErrorSettings:Submit, NoHide
    global errorWordVariations
    
    selectedWord := ""
    GuiControlGet, selectedWord,, ErrorWordsList
    
    if (selectedWord != "") {
        errorWordVariations.Delete(selectedWord)
        UpdateErrorWordsList()
        GuiControl,, ErrorVariationsList, |
    } else {
        MsgBox, 48, Ошибка, Выберите слово для удаления!
    }
return

; === Добавить вариацию ===
AddErrorVariation:
    Gui, ErrorSettings:Submit, NoHide
    global errorWordVariations
    
    selectedWord := ""
    GuiControlGet, selectedWord,, ErrorWordsList
    
    if (selectedWord = "") {
        MsgBox, 48, Ошибка, Выберите слово!
        return
    }
    
    variation := Trim(ErrorVariationInput)
    if (variation = "") {
        MsgBox, 48, Ошибка, Введите вариацию!
        return
    }
    
    StringLower, variation, variation
    if (!Contains(errorWordVariations[selectedWord], variation)) {
        errorWordVariations[selectedWord].Push(variation)
        GuiControl,, ErrorVariationInput,
        Gosub, ErrorWordSelected
    } else {
        MsgBox, 48, Ошибка, Вариация "%variation%" уже добавлена!
    }
return

; === Генерировать вариации для слова ===
GenerateErrorVariations:
    Gui, ErrorSettings:Submit, NoHide
    global errorWordVariations
    
    selectedWord := ""
    GuiControlGet, selectedWord,, ErrorWordsList
    
    if (selectedWord = "") {
        MsgBox, 48, Ошибка, Выберите слово для генерации вариаций!
        return
    }
    
    ; Запрашиваем количество вариаций для генерации
    InputBox, variationCount, Количество вариаций, Введите количество вариаций для генерации:, , 300, 150, , , , , 5
    if (ErrorLevel) {
        return
    }
    
    if (!RegExMatch(variationCount, "^\d+$") || variationCount <= 0) {
        MsgBox, 48, Ошибка, Введите корректное число!
        return
    }
    
    ; Генерируем умные вариации
    smartVariations := GenerateSmartVariations(selectedWord, variationCount)
    
    if (smartVariations.Length() = 0) {
        MsgBox, 48, Ошибка, Не удалось сгенерировать вариации для слова "%selectedWord%"!
        return
    }
    
    ; Добавляем вариации к слову (если их еще нет)
    addedCount := 0
    for i, variation in smartVariations {
        if (!Contains(errorWordVariations[selectedWord], variation)) {
            errorWordVariations[selectedWord].Push(variation)
            addedCount++
        }
    }
    
    ; Обновляем список вариаций
    Gosub, ErrorWordSelected
    
    if (addedCount > 0) {
        MsgBox, 64, Успех, Добавлено %addedCount% новых вариаций для слова "%selectedWord%"!
    } else {
        MsgBox, 48, Информация, Все вариации для слова "%selectedWord%" уже добавлены!
    }
return

; === Удалить вариацию ===
RemoveErrorVariation:
    Gui, ErrorSettings:Submit, NoHide
    global errorWordVariations
    
    selectedWord := ""
    GuiControlGet, selectedWord,, ErrorWordsList
    
    if (selectedWord = "") {
        MsgBox, 48, Ошибка, Выберите слово!
        return
    }
    
    selectedVariation := ""
    GuiControlGet, selectedVariation,, ErrorVariationsList
    
    if (selectedVariation = "") {
        MsgBox, 48, Ошибка, Выберите вариацию для удаления!
        return
    }
    
    ; Удаляем вариацию из массива
    newVariations := []
    for i, variation in errorWordVariations[selectedWord] {
        if (variation != selectedVariation) {
            newVariations.Push(variation)
        }
    }
    errorWordVariations[selectedWord] := newVariations
    Gosub, ErrorWordSelected
return

; === Сохранить настройки ошибок ===
ErrorSettingsOK:
    Gui, ErrorSettings:Submit, NoHide
    global smartErrorMode, errorWordCount, errorPosition, errorFrequency, errorChance
    global errorType, errorCount, randomCharsCount, randomCharsInComplexWords, randomCharsPerWord
    global errorCapitalize, errorPreserveLength, errorSmartMode
    
    smartErrorMode := SmartErrorMode ? true : false
    errorWordCount := ErrorWordCount
    errorPosition := ErrorPosition
    errorFrequency := ErrorFrequency
    errorChance := ErrorChance
    errorType := ErrorType
    errorCount := ErrorCount
    randomCharsCount := RandomCharsCount
    randomCharsInComplexWords := RandomCharsInComplexWords ? true : false
    randomCharsPerWord := RandomCharsPerWord
    errorCapitalize := ErrorCapitalize ? true : false
    errorPreserveLength := ErrorPreserveLength ? true : false
    errorSmartMode := ErrorSmartMode ? true : false
    
    SaveErrorSettings()
    Gui, ErrorSettings:Destroy
    Gui, 1:Default
return

; === Отмена настроек ошибок ===
ErrorSettingsCancel:
    Gui, ErrorSettings:Destroy
    Gui, 1:Default
return

ErrorSettingsGuiClose:
    Gui, ErrorSettings:Destroy
    Gui, 1:Default
return

; ═══════════════════════════════════════════════════════════════════════════════
; 🔧 ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ ОШИБОК
; ═══════════════════════════════════════════════════════════════════════════════
OpenAdvancedErrorSettings:
    Gui, AdvErrorSettings:New, +Owner1
    Gui, AdvErrorSettings:Font, s10, Segoe UI
    Gui, AdvErrorSettings:Color, White
    
    ; Заголовок
    Gui, AdvErrorSettings:Add, Text, x15 y10 w770 h30 c0066CC Center, 🔧 ДОПОЛНИТЕЛЬНЫЕ НАСТРОЙКИ ОШИБОК
    Gui, AdvErrorSettings:Font, s9, Segoe UI
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ТИПЫ ОШИБОК (Левая колонка)
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, AdvErrorSettings:Add, GroupBox, x10 y45 w385 h320, 📝 Типы ошибок
    
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorSwapNeighbors x20 y65, Перестановка соседних букв
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorAddRandom x20 y90, Добавление случайного символа
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorDeleteRandom x20 y115, Удаление случайного символа
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorMoveCharBetweenWords x20 y140, Перенос символа между словами
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorDeleteSpace x20 y165, Удаление пробела между словами
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorMoveCharInWord x20 y190, Перенос буквы внутри слова
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorMoveCharToStart x20 y215, Перенос буквы в начало слова
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorSequenceError x20 y240, Ошибка последовательности нажатий
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorMoveCharToPrevWord x20 y265, Перенос буквы внутрь предыдущего слова
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorInsertSpaceInWord x20 y290, Вставка пробела внутри слова
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorInsertSpecialChars x20 y315, Вставка "=" или цифр (наху=й, х=уй)
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorExtendedSettings x20 y340, Расширенные настройки ошибок
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ОБРАБОТКА ТЕКСТА (Правая колонка)
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, AdvErrorSettings:Add, GroupBox, x405 y45 w385 h320, 🔀 Обработка текста
    
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorCustomSplit x415 y65, Кастомное разбиение строк
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorCombinedErrors x415 y90, Комбинированные ошибки в словах
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorShuffleWords x415 y115, Перемешивать слова
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorShuffleLines x415 y140, Перемешивать строки
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorRandomPhraseOrder x415 y165, Случайный порядок фраз
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorJoinPhrases x415 y190, Соединять фразы в одну строку
    
    ; Дополнительные параметры
    Gui, AdvErrorSettings:Add, Text, x415 y225, Частота применения (`%):
    Gui, AdvErrorSettings:Add, Edit, vAdvErrorFrequency x565 y222 w50 Number
    Gui, AdvErrorSettings:Add, UpDown, vAdvErrorFrequencyUpDown Range0-100, 30
    
    Gui, AdvErrorSettings:Add, Text, x415 y255, Интенсивность (1-10):
    Gui, AdvErrorSettings:Add, Edit, vAdvErrorIntensity x565 y252 w50 Number
    Gui, AdvErrorSettings:Add, UpDown, vAdvErrorIntensityUpDown Range1-10, 5
    
    Gui, AdvErrorSettings:Add, Text, x415 y285, Макс. ошибок на слово:
    Gui, AdvErrorSettings:Add, Edit, vAdvErrorMaxPerWord x565 y282 w50 Number
    Gui, AdvErrorSettings:Add, UpDown, vAdvErrorMaxPerWordUpDown Range1-5, 2
    
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorSmartCombine x415 y315, Умное комбинирование ошибок
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorPreserveReadability x415 y340, Сохранять читаемость
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; НАСТРОЙКИ СПЕЦИАЛЬНЫХ СИМВОЛОВ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, AdvErrorSettings:Add, GroupBox, x10 y370 w780 h120, ⚙️ Настройки специальных символов
    
    Gui, AdvErrorSettings:Add, Text, x20 y395, Символы для вставки:
    Gui, AdvErrorSettings:Add, Edit, vAdvErrorSpecialChars x160 y392 w200, =0123456789
    
    Gui, AdvErrorSettings:Add, Text, x380 y395, Буквы для замены:
    Gui, AdvErrorSettings:Add, Edit, vAdvErrorTargetLetters x520 y392 w260, ауеоиыэюя
    
    Gui, AdvErrorSettings:Add, Text, x20 y425, Позиция вставки:
    Gui, AdvErrorSettings:Add, DropDownList, vAdvErrorInsertPosition x160 y422 w200, После буквы|Перед буквой|Случайно
    
    Gui, AdvErrorSettings:Add, Text, x380 y425, Частота вставки (`%):
    Gui, AdvErrorSettings:Add, Edit, vAdvErrorInsertFrequency x520 y422 w50 Number
    Gui, AdvErrorSettings:Add, UpDown, vAdvErrorInsertFrequencyUpDown Range0-100, 20
    
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorMultipleInserts x20 y455, Множественные вставки в одно слово
    Gui, AdvErrorSettings:Add, Checkbox, vAdvErrorRandomSymbol x380 y455, Случайный выбор символа
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ПРЕДПРОСМОТР
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, AdvErrorSettings:Add, GroupBox, x10 y495 w780 h80, 👁️ Предпросмотр
    Gui, AdvErrorSettings:Add, Text, x20 y515, Исходный текст:
    Gui, AdvErrorSettings:Add, Edit, vAdvErrorPreviewInput x120 y512 w660 h20, привет мир это тест
    Gui, AdvErrorSettings:Add, Text, x20 y545, Результат:
    Gui, AdvErrorSettings:Add, Text, vAdvErrorPreviewOutput x120 y545 w660 h20 cCC0000, првиет м=ир эт0 тест
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; КНОПКИ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, AdvErrorSettings:Add, Button, x10 y585 w150 h35 gAdvErrorSettingsOK, ✓ Сохранить
    Gui, AdvErrorSettings:Add, Button, x170 y585 w150 h35 gAdvErrorSettingsCancel, ✗ Отмена
    Gui, AdvErrorSettings:Add, Button, x330 y585 w150 h35 gOpenVisualRuleEditor, 🎨 Редактор правил
    Gui, AdvErrorSettings:Add, Button, x490 y585 w150 h35 gAdvErrorPreview, 🔄 Превью
    Gui, AdvErrorSettings:Add, Button, x650 y585 w140 h35 gAdvErrorReset, 🔄 Сбросить
    
    ; Загружаем текущие настройки
    LoadAdvancedErrorSettings()
    
    Gui, AdvErrorSettings:Show, w800 h630, 🔧 Дополнительные настройки ошибок
return

; === Загрузить дополнительные настройки ===
LoadAdvancedErrorSettings() {
    global advErrorSwapNeighbors, advErrorAddRandom, advErrorDeleteRandom
    global advErrorMoveCharBetweenWords, advErrorDeleteSpace, advErrorMoveCharInWord
    global advErrorMoveCharToStart, advErrorSequenceError, advErrorMoveCharToPrevWord
    global advErrorInsertSpaceInWord, advErrorInsertSpecialChars, advErrorExtendedSettings
    global advErrorCustomSplit, advErrorCombinedErrors, advErrorShuffleWords
    global advErrorShuffleLines, advErrorRandomPhraseOrder, advErrorJoinPhrases
    
    GuiControl,, AdvErrorSwapNeighbors, %advErrorSwapNeighbors%
    GuiControl,, AdvErrorAddRandom, %advErrorAddRandom%
    GuiControl,, AdvErrorDeleteRandom, %advErrorDeleteRandom%
    GuiControl,, AdvErrorMoveCharBetweenWords, %advErrorMoveCharBetweenWords%
    GuiControl,, AdvErrorDeleteSpace, %advErrorDeleteSpace%
    GuiControl,, AdvErrorMoveCharInWord, %advErrorMoveCharInWord%
    GuiControl,, AdvErrorMoveCharToStart, %advErrorMoveCharToStart%
    GuiControl,, AdvErrorSequenceError, %advErrorSequenceError%
    GuiControl,, AdvErrorMoveCharToPrevWord, %advErrorMoveCharToPrevWord%
    GuiControl,, AdvErrorInsertSpaceInWord, %advErrorInsertSpaceInWord%
    GuiControl,, AdvErrorInsertSpecialChars, %advErrorInsertSpecialChars%
    GuiControl,, AdvErrorExtendedSettings, %advErrorExtendedSettings%
    GuiControl,, AdvErrorCustomSplit, %advErrorCustomSplit%
    GuiControl,, AdvErrorCombinedErrors, %advErrorCombinedErrors%
    GuiControl,, AdvErrorShuffleWords, %advErrorShuffleWords%
    GuiControl,, AdvErrorShuffleLines, %advErrorShuffleLines%
    GuiControl,, AdvErrorRandomPhraseOrder, %advErrorRandomPhraseOrder%
    GuiControl,, AdvErrorJoinPhrases, %advErrorJoinPhrases%
    
    ; Устанавливаем значения по умолчанию для новых полей
    GuiControl,, AdvErrorFrequency, 30
    GuiControl,, AdvErrorIntensity, 5
    GuiControl,, AdvErrorMaxPerWord, 2
    GuiControl,, AdvErrorSpecialChars, =0123456789
    GuiControl,, AdvErrorTargetLetters, ауеоиыэюя
    GuiControl, ChooseString, AdvErrorInsertPosition, После буквы
    GuiControl,, AdvErrorInsertFrequency, 20
}

; === Сохранить дополнительные настройки ===
AdvErrorSettingsOK:
    Gui, AdvErrorSettings:Submit, NoHide
    
    ; Сохраняем все настройки в глобальные переменные
    advErrorSwapNeighbors := AdvErrorSwapNeighbors
    advErrorAddRandom := AdvErrorAddRandom
    advErrorDeleteRandom := AdvErrorDeleteRandom
    advErrorMoveCharBetweenWords := AdvErrorMoveCharBetweenWords
    advErrorDeleteSpace := AdvErrorDeleteSpace
    advErrorMoveCharInWord := AdvErrorMoveCharInWord
    advErrorMoveCharToStart := AdvErrorMoveCharToStart
    advErrorSequenceError := AdvErrorSequenceError
    advErrorMoveCharToPrevWord := AdvErrorMoveCharToPrevWord
    advErrorInsertSpaceInWord := AdvErrorInsertSpaceInWord
    advErrorInsertSpecialChars := AdvErrorInsertSpecialChars
    advErrorExtendedSettings := AdvErrorExtendedSettings
    advErrorCustomSplit := AdvErrorCustomSplit
    advErrorCombinedErrors := AdvErrorCombinedErrors
    advErrorShuffleWords := AdvErrorShuffleWords
    advErrorShuffleLines := AdvErrorShuffleLines
    advErrorRandomPhraseOrder := AdvErrorRandomPhraseOrder
    advErrorJoinPhrases := AdvErrorJoinPhrases
    
    ; Сохраняем в INI файл
    SaveAdvancedErrorSettings()
    
    MsgBox, 64, Успех, Дополнительные настройки ошибок сохранены!
    Gui, AdvErrorSettings:Destroy
    Gui, 1:Default
return

; === Отмена дополнительных настроек ===
AdvErrorSettingsCancel:
    Gui, AdvErrorSettings:Destroy
    Gui, 1:Default
return

AdvErrorSettingsGuiClose:
    Gui, AdvErrorSettings:Destroy
    Gui, 1:Default
return

; === Обновить превью ===
AdvErrorPreview:
    Gui, AdvErrorSettings:Submit, NoHide
    ; Здесь можно добавить логику для генерации превью с примененными ошибками
    MsgBox, 64, Превью, Функция превью будет реализована в следующей версии!
return

; === Сбросить все настройки ===
AdvErrorReset:
    MsgBox, 36, Подтверждение, Вы уверены что хотите сбросить все дополнительные настройки?
    IfMsgBox, Yes
    {
        ; Сбрасываем все чекбоксы
        GuiControl,, AdvErrorSwapNeighbors, 0
        GuiControl,, AdvErrorAddRandom, 0
        GuiControl,, AdvErrorDeleteRandom, 0
        GuiControl,, AdvErrorMoveCharBetweenWords, 0
        GuiControl,, AdvErrorDeleteSpace, 0
        GuiControl,, AdvErrorMoveCharInWord, 0
        GuiControl,, AdvErrorMoveCharToStart, 0
        GuiControl,, AdvErrorSequenceError, 0
        GuiControl,, AdvErrorMoveCharToPrevWord, 0
        GuiControl,, AdvErrorInsertSpaceInWord, 0
        GuiControl,, AdvErrorInsertSpecialChars, 0
        GuiControl,, AdvErrorExtendedSettings, 0
        GuiControl,, AdvErrorCustomSplit, 0
        GuiControl,, AdvErrorCombinedErrors, 0
        GuiControl,, AdvErrorShuffleWords, 0
        GuiControl,, AdvErrorShuffleLines, 0
        GuiControl,, AdvErrorRandomPhraseOrder, 0
        GuiControl,, AdvErrorJoinPhrases, 0
        GuiControl,, AdvErrorSmartCombine, 0
        GuiControl,, AdvErrorPreserveReadability, 0
        GuiControl,, AdvErrorMultipleInserts, 0
        GuiControl,, AdvErrorRandomSymbol, 0
        
        ; Сбрасываем значения
        GuiControl,, AdvErrorFrequency, 30
        GuiControl,, AdvErrorIntensity, 5
        GuiControl,, AdvErrorMaxPerWord, 2
        GuiControl,, AdvErrorSpecialChars, =0123456789
        GuiControl,, AdvErrorTargetLetters, ауеоиыэюя
        GuiControl, ChooseString, AdvErrorInsertPosition, После буквы
        GuiControl,, AdvErrorInsertFrequency, 20
        
        MsgBox, 64, Успех, Все настройки сброшены!
    }
return

; === Сохранить дополнительные настройки в INI ===
SaveAdvancedErrorSettings() {
    global appDataDir
    global advErrorSwapNeighbors, advErrorAddRandom, advErrorDeleteRandom
    global advErrorMoveCharBetweenWords, advErrorDeleteSpace, advErrorMoveCharInWord
    global advErrorMoveCharToStart, advErrorSequenceError, advErrorMoveCharToPrevWord
    global advErrorInsertSpaceInWord, advErrorInsertSpecialChars, advErrorExtendedSettings
    global advErrorCustomSplit, advErrorCombinedErrors, advErrorShuffleWords
    global advErrorShuffleLines, advErrorRandomPhraseOrder, advErrorJoinPhrases
    
    IniWrite, %advErrorSwapNeighbors%, %appDataDir%\AutoTyper.ini, AdvancedErrors, SwapNeighbors
    IniWrite, %advErrorAddRandom%, %appDataDir%\AutoTyper.ini, AdvancedErrors, AddRandom
    IniWrite, %advErrorDeleteRandom%, %appDataDir%\AutoTyper.ini, AdvancedErrors, DeleteRandom
    IniWrite, %advErrorMoveCharBetweenWords%, %appDataDir%\AutoTyper.ini, AdvancedErrors, MoveCharBetweenWords
    IniWrite, %advErrorDeleteSpace%, %appDataDir%\AutoTyper.ini, AdvancedErrors, DeleteSpace
    IniWrite, %advErrorMoveCharInWord%, %appDataDir%\AutoTyper.ini, AdvancedErrors, MoveCharInWord
    IniWrite, %advErrorMoveCharToStart%, %appDataDir%\AutoTyper.ini, AdvancedErrors, MoveCharToStart
    IniWrite, %advErrorSequenceError%, %appDataDir%\AutoTyper.ini, AdvancedErrors, SequenceError
    IniWrite, %advErrorMoveCharToPrevWord%, %appDataDir%\AutoTyper.ini, AdvancedErrors, MoveCharToPrevWord
    IniWrite, %advErrorInsertSpaceInWord%, %appDataDir%\AutoTyper.ini, AdvancedErrors, InsertSpaceInWord
    IniWrite, %advErrorInsertSpecialChars%, %appDataDir%\AutoTyper.ini, AdvancedErrors, InsertSpecialChars
    IniWrite, %advErrorExtendedSettings%, %appDataDir%\AutoTyper.ini, AdvancedErrors, ExtendedSettings
    IniWrite, %advErrorCustomSplit%, %appDataDir%\AutoTyper.ini, AdvancedErrors, CustomSplit
    IniWrite, %advErrorCombinedErrors%, %appDataDir%\AutoTyper.ini, AdvancedErrors, CombinedErrors
    IniWrite, %advErrorShuffleWords%, %appDataDir%\AutoTyper.ini, AdvancedErrors, ShuffleWords
    IniWrite, %advErrorShuffleLines%, %appDataDir%\AutoTyper.ini, AdvancedErrors, ShuffleLines
    IniWrite, %advErrorRandomPhraseOrder%, %appDataDir%\AutoTyper.ini, AdvancedErrors, RandomPhraseOrder
    IniWrite, %advErrorJoinPhrases%, %appDataDir%\AutoTyper.ini, AdvancedErrors, JoinPhrases
}

; === Загрузить дополнительные настройки из INI ===
LoadAdvancedErrorSettingsFromIni() {
    global appDataDir
    global advErrorSwapNeighbors, advErrorAddRandom, advErrorDeleteRandom
    global advErrorMoveCharBetweenWords, advErrorDeleteSpace, advErrorMoveCharInWord
    global advErrorMoveCharToStart, advErrorSequenceError, advErrorMoveCharToPrevWord
    global advErrorInsertSpaceInWord, advErrorInsertSpecialChars, advErrorExtendedSettings
    global advErrorCustomSplit, advErrorCombinedErrors, advErrorShuffleWords
    global advErrorShuffleLines, advErrorRandomPhraseOrder, advErrorJoinPhrases
    
    IniRead, advErrorSwapNeighbors, %appDataDir%\AutoTyper.ini, AdvancedErrors, SwapNeighbors, 0
    IniRead, advErrorAddRandom, %appDataDir%\AutoTyper.ini, AdvancedErrors, AddRandom, 0
    IniRead, advErrorDeleteRandom, %appDataDir%\AutoTyper.ini, AdvancedErrors, DeleteRandom, 0
    IniRead, advErrorMoveCharBetweenWords, %appDataDir%\AutoTyper.ini, AdvancedErrors, MoveCharBetweenWords, 0
    IniRead, advErrorDeleteSpace, %appDataDir%\AutoTyper.ini, AdvancedErrors, DeleteSpace, 0
    IniRead, advErrorMoveCharInWord, %appDataDir%\AutoTyper.ini, AdvancedErrors, MoveCharInWord, 0
    IniRead, advErrorMoveCharToStart, %appDataDir%\AutoTyper.ini, AdvancedErrors, MoveCharToStart, 0
    IniRead, advErrorSequenceError, %appDataDir%\AutoTyper.ini, AdvancedErrors, SequenceError, 0
    IniRead, advErrorMoveCharToPrevWord, %appDataDir%\AutoTyper.ini, AdvancedErrors, MoveCharToPrevWord, 0
    IniRead, advErrorInsertSpaceInWord, %appDataDir%\AutoTyper.ini, AdvancedErrors, InsertSpaceInWord, 0
    IniRead, advErrorInsertSpecialChars, %appDataDir%\AutoTyper.ini, AdvancedErrors, InsertSpecialChars, 0
    IniRead, advErrorExtendedSettings, %appDataDir%\AutoTyper.ini, AdvancedErrors, ExtendedSettings, 0
    IniRead, advErrorCustomSplit, %appDataDir%\AutoTyper.ini, AdvancedErrors, CustomSplit, 0
    IniRead, advErrorCombinedErrors, %appDataDir%\AutoTyper.ini, AdvancedErrors, CombinedErrors, 0
    IniRead, advErrorShuffleWords, %appDataDir%\AutoTyper.ini, AdvancedErrors, ShuffleWords, 0
    IniRead, advErrorShuffleLines, %appDataDir%\AutoTyper.ini, AdvancedErrors, ShuffleLines, 0
    IniRead, advErrorRandomPhraseOrder, %appDataDir%\AutoTyper.ini, AdvancedErrors, RandomPhraseOrder, 0
    IniRead, advErrorJoinPhrases, %appDataDir%\AutoTyper.ini, AdvancedErrors, JoinPhrases, 0
}

; ═══════════════════════════════════════════════════════════════════════════════
; 📊 НАСТРОЙКИ ПРОЦЕНТОВ ОШИБОК
; ═══════════════════════════════════════════════════════════════════════════════

OpenPercentSettings:
    Gui, PercentSettings:New, +Owner1
    Gui, PercentSettings:Font, s10 Bold, Segoe UI
    Gui, PercentSettings:Color, White
    
    ; Заголовок
    Gui, PercentSettings:Add, Text, x15 y10 w770 h30 c0066CC Center, 📊 ПРОЦЕНТНЫЕ НАСТРОЙКИ ОШИБОК
    Gui, PercentSettings:Font, s9 Normal, Segoe UI
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ОСНОВНЫЕ ПАРАМЕТРЫ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, PercentSettings:Add, GroupBox, x10 y45 w780 h100, ⚙️ Основные параметры
    
    Gui, PercentSettings:Add, Text, x20 y65, Минимальное кол-во ошибок в слове:
    Gui, PercentSettings:Add, Edit, vMinErrorsPerWord x250 y62 w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-10, 0
    
    Gui, PercentSettings:Add, Text, x320 y65, Максимальное кол-во ошибок в слове:
    Gui, PercentSettings:Add, Edit, vMaxErrorsPerWord x560 y62 w50 Number
    Gui, PercentSettings:Add, UpDown, Range1-10, 3
    
    Gui, PercentSettings:Add, Text, x20 y95, Минимальное количество слов на строку:
    Gui, PercentSettings:Add, Edit, vMinWordsPerLine x250 y92 w50 Number
    Gui, PercentSettings:Add, UpDown, Range1-100, 1
    
    Gui, PercentSettings:Add, Text, x320 y95, Максимальное количество слов на строку:
    Gui, PercentSettings:Add, Edit, vMaxWordsPerLine x560 y92 w50 Number
    Gui, PercentSettings:Add, UpDown, Range1-100, 20
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ПРОЦЕНТЫ ТИПОВ ОШИБОК (Левая колонка)
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, PercentSettings:Add, GroupBox, x10 y150 w385 h380, 📝 Проценты типов ошибок
    
    yPos := 170
    Gui, PercentSettings:Add, Text, x20 y%yPos%, Перестановка соседних букв:
    Gui, PercentSettings:Add, Edit, vPercentSwapNeighbors x250 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 20
    Gui, PercentSettings:Add, Text, x305 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x20 y%yPos%, Добавление символа:
    Gui, PercentSettings:Add, Edit, vPercentAddChar x250 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 15
    Gui, PercentSettings:Add, Text, x305 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x20 y%yPos%, Дублирование при добавлении:
    Gui, PercentSettings:Add, Edit, vPercentDuplicateChar x250 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 10
    Gui, PercentSettings:Add, Text, x305 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x20 y%yPos%, Удаление случайного символа:
    Gui, PercentSettings:Add, Edit, vPercentDeleteChar x250 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 10
    Gui, PercentSettings:Add, Text, x305 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x20 y%yPos%, Перенос символа между словами:
    Gui, PercentSettings:Add, Edit, vPercentMoveCharBetween x250 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 5
    Gui, PercentSettings:Add, Text, x305 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x20 y%yPos%, Удаление пробела между словами:
    Gui, PercentSettings:Add, Edit, vPercentDeleteSpace x250 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 8
    Gui, PercentSettings:Add, Text, x305 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x20 y%yPos%, Перенос буквы внутри слова:
    Gui, PercentSettings:Add, Edit, vPercentMoveCharInWord x250 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 12
    Gui, PercentSettings:Add, Text, x305 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x20 y%yPos%, Перенос буквы в начало слова:
    Gui, PercentSettings:Add, Edit, vPercentMoveCharToStart x250 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 5
    Gui, PercentSettings:Add, Text, x305 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x20 y%yPos%, Ошибка последовательности:
    Gui, PercentSettings:Add, Edit, vPercentSequenceError x250 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 10
    Gui, PercentSettings:Add, Text, x305 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x20 y%yPos%, Перенос в предыдущее слово:
    Gui, PercentSettings:Add, Edit, vPercentMoveToPrevWord x250 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 5
    Gui, PercentSettings:Add, Text, x305 y%yPos%, `%
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ПРОЦЕНТЫ СПЕЦИАЛЬНЫХ ОШИБОК (Правая колонка)
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, PercentSettings:Add, GroupBox, x405 y150 w385 h380, 🔧 Проценты специальных ошибок
    
    yPos := 170
    Gui, PercentSettings:Add, Text, x415 y%yPos%, Вставка пробела внутри слова:
    Gui, PercentSettings:Add, Edit, vPercentInsertSpace x645 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 7
    Gui, PercentSettings:Add, Text, x700 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x415 y%yPos%, Вставка символов внутри слов:
    Gui, PercentSettings:Add, Edit, vPercentInsertSymbolsIn x645 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 15
    Gui, PercentSettings:Add, Text, x700 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x415 y%yPos%, Вставка символов возле слов:
    Gui, PercentSettings:Add, Edit, vPercentInsertSymbolsNear x645 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 10
    Gui, PercentSettings:Add, Text, x700 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x415 y%yPos%, Случайное удаление пробелов:
    Gui, PercentSettings:Add, Edit, vPercentRandomDeleteSpace x645 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 5
    Gui, PercentSettings:Add, Text, x700 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x415 y%yPos%, Случайная вставка пробелов:
    Gui, PercentSettings:Add, Edit, vPercentRandomInsertSpace x645 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 5
    Gui, PercentSettings:Add, Text, x700 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x415 y%yPos%, Перемешивание букв (легкое):
    Gui, PercentSettings:Add, Edit, vPercentShuffleLight x645 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 10
    Gui, PercentSettings:Add, Text, x700 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x415 y%yPos%, Перемешивание букв (среднее):
    Gui, PercentSettings:Add, Edit, vPercentShuffleMedium x645 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 15
    Gui, PercentSettings:Add, Text, x700 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x415 y%yPos%, Перемешивание букв (высокое):
    Gui, PercentSettings:Add, Edit, vPercentShuffleHigh x645 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 20
    Gui, PercentSettings:Add, Text, x700 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x415 y%yPos%, Перемешивание слов:
    Gui, PercentSettings:Add, Edit, vPercentShuffleWords x645 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 5
    Gui, PercentSettings:Add, Text, x700 y%yPos%, `%
    
    yPos += 30
    Gui, PercentSettings:Add, Text, x415 y%yPos%, Переставка букв:
    Gui, PercentSettings:Add, Edit, vPercentSwapLetters x645 y%yPos% w50 Number
    Gui, PercentSettings:Add, UpDown, Range0-100, 25
    Gui, PercentSettings:Add, Text, x700 y%yPos%, `%
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; КНОПКИ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, PercentSettings:Add, Button, x10 y540 w180 h35 gPercentSettingsOK, ✓ Сохранить
    Gui, PercentSettings:Add, Button, x200 y540 w180 h35 gPercentSettingsCancel, ✗ Отмена
    Gui, PercentSettings:Add, Button, x390 y540 w200 h35 gPercentSettingsReset, 🔄 Сбросить по умолчанию
    Gui, PercentSettings:Add, Button, x600 y540 w190 h35 gOpenSwapLettersSettings, ⚙️ Настройки переставки
    
    ; Загружаем текущие настройки
    LoadPercentSettings()
    
    Gui, PercentSettings:Show, w800 h585, 📊 Процентные настройки ошибок
return

; === Загрузить процентные настройки ===
LoadPercentSettings() {
    ; Устанавливаем значения по умолчанию
    GuiControl,, MinErrorsPerWord, 0
    GuiControl,, MaxErrorsPerWord, 3
    GuiControl,, MinWordsPerLine, 1
    GuiControl,, MaxWordsPerLine, 20
    GuiControl,, PercentSwapNeighbors, 20
    GuiControl,, PercentAddChar, 15
    GuiControl,, PercentDuplicateChar, 10
    GuiControl,, PercentDeleteChar, 10
    GuiControl,, PercentMoveCharBetween, 5
    GuiControl,, PercentDeleteSpace, 8
    GuiControl,, PercentMoveCharInWord, 12
    GuiControl,, PercentMoveCharToStart, 5
    GuiControl,, PercentSequenceError, 10
    GuiControl,, PercentMoveToPrevWord, 5
    GuiControl,, PercentInsertSpace, 7
    GuiControl,, PercentInsertSymbolsIn, 15
    GuiControl,, PercentInsertSymbolsNear, 10
    GuiControl,, PercentRandomDeleteSpace, 5
    GuiControl,, PercentRandomInsertSpace, 5
    GuiControl,, PercentShuffleLight, 10
    GuiControl,, PercentShuffleMedium, 15
    GuiControl,, PercentShuffleHigh, 20
    GuiControl,, PercentShuffleWords, 5
    GuiControl,, PercentSwapLetters, 25
}

; === Сохранить процентные настройки ===
PercentSettingsOK:
    Gui, PercentSettings:Submit, NoHide
    MsgBox, 64, Успех, Процентные настройки сохранены!
    Gui, PercentSettings:Destroy
    Gui, 1:Default
return

; === Отмена процентных настроек ===
PercentSettingsCancel:
    Gui, PercentSettings:Destroy
    Gui, 1:Default
return

; === Сбросить процентные настройки ===
PercentSettingsReset:
    MsgBox, 36, Подтверждение, Сбросить все проценты на значения по умолчанию?
    IfMsgBox, Yes
    {
        LoadPercentSettings()
        MsgBox, 64, Успех, Все проценты сброшены!
    }
return

; === Открыть расширенные настройки переставки букв ===
OpenSwapLettersSettings:
    Gui, SwapLettersSettings:New, +Owner1
    Gui, SwapLettersSettings:Font, s10 Bold, Segoe UI
    Gui, SwapLettersSettings:Color, White
    
    ; Заголовок
    Gui, SwapLettersSettings:Add, Text, x15 y10 w570 h30 c0066CC Center, ⚙️ РАСШИРЕННЫЕ НАСТРОЙКИ ПЕРЕСТАВКИ БУКВ
    Gui, SwapLettersSettings:Font, s9 Normal, Segoe UI
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ОСНОВНЫЕ ПАРАМЕТРЫ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, SwapLettersSettings:Add, GroupBox, x10 y45 w580 h520, ⚙️ Параметры переставки
    
    yPos := 65
    Gui, SwapLettersSettings:Add, Text, x20 y%yPos%, Шанс переставки (`%):
    Gui, SwapLettersSettings:Add, Edit, vSwapChance x250 y%yPos% w50 Number
    Gui, SwapLettersSettings:Add, UpDown, Range0-100, 50
    
    yPos += 30
    Gui, SwapLettersSettings:Add, Text, x20 y%yPos%, Вероятность переставки (`%):
    Gui, SwapLettersSettings:Add, Edit, vSwapProbability x250 y%yPos% w50 Number
    Gui, SwapLettersSettings:Add, UpDown, Range0-100, 70
    
    yPos += 30
    Gui, SwapLettersSettings:Add, Text, x20 y%yPos%, Минимальная длина слова:
    Gui, SwapLettersSettings:Add, Edit, vSwapMinWordLength x250 y%yPos% w50 Number
    Gui, SwapLettersSettings:Add, UpDown, Range2-20, 3
    
    yPos += 30
    Gui, SwapLettersSettings:Add, Text, x20 y%yPos%, Максимальная длина слова:
    Gui, SwapLettersSettings:Add, Edit, vSwapMaxWordLength x250 y%yPos% w50 Number
    Gui, SwapLettersSettings:Add, UpDown, Range3-50, 15
    
    yPos += 30
    Gui, SwapLettersSettings:Add, Text, x20 y%yPos%, Количество переставок на слово:
    Gui, SwapLettersSettings:Add, Edit, vSwapCountPerWord x250 y%yPos% w50 Number
    Gui, SwapLettersSettings:Add, UpDown, Range1-10, 1
    
    yPos += 30
    Gui, SwapLettersSettings:Add, Text, x20 y%yPos%, Дистанция переставки (букв):
    Gui, SwapLettersSettings:Add, Edit, vSwapDistance x250 y%yPos% w50 Number
    Gui, SwapLettersSettings:Add, UpDown, Range1-10, 1
    
    yPos += 30
    Gui, SwapLettersSettings:Add, Checkbox, vSwapOnlyNeighbors x20 y%yPos%, Только соседние буквы
    
    yPos += 25
    Gui, SwapLettersSettings:Add, Checkbox, vSwapPreserveFirst x20 y%yPos%, Сохранять первую букву
    
    yPos += 25
    Gui, SwapLettersSettings:Add, Checkbox, vSwapPreserveLast x20 y%yPos%, Сохранять последнюю букву
    
    yPos += 25
    Gui, SwapLettersSettings:Add, Checkbox, vSwapOnlyVowels x20 y%yPos%, Только гласные
    
    yPos += 25
    Gui, SwapLettersSettings:Add, Checkbox, vSwapOnlyConsonants x20 y%yPos%, Только согласные
    
    yPos += 25
    Gui, SwapLettersSettings:Add, Checkbox, vSwapCaseSensitive x20 y%yPos%, Учитывать регистр
    
    yPos += 25
    Gui, SwapLettersSettings:Add, Checkbox, vSwapRandomDirection x20 y%yPos%, Случайное направление
    
    yPos += 25
    Gui, SwapLettersSettings:Add, Checkbox, vSwapMultiplePositions x20 y%yPos%, Множественные позиции
    
    yPos += 25
    Gui, SwapLettersSettings:Add, Checkbox, vSwapAvoidDuplicates x20 y%yPos%, Избегать дубликатов
    
    yPos += 25
    Gui, SwapLettersSettings:Add, Checkbox, vSwapSmartMode x20 y%yPos%, Умный режим (читаемость)
    
    yPos += 25
    Gui, SwapLettersSettings:Add, Checkbox, vSwapProgressiveIntensity x20 y%yPos%, Прогрессивная интенсивность
    
    yPos += 25
    Gui, SwapLettersSettings:Add, Checkbox, vSwapByWordComplexity x20 y%yPos%, По сложности слова
    
    yPos += 25
    Gui, SwapLettersSettings:Add, Checkbox, vSwapReverseOrder x20 y%yPos%, Обратный порядок
    
    yPos += 25
    Gui, SwapLettersSettings:Add, Checkbox, vSwapMirrorPositions x20 y%yPos%, Зеркальные позиции
    
    yPos += 25
    Gui, SwapLettersSettings:Add, Checkbox, vSwapCyclicShift x20 y%yPos%, Циклический сдвиг
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; КНОПКИ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, SwapLettersSettings:Add, Button, x10 y575 w180 h30 gSwapLettersSettingsOK, ✓ Сохранить
    Gui, SwapLettersSettings:Add, Button, x200 y575 w180 h30 gSwapLettersSettingsCancel, ✗ Отмена
    Gui, SwapLettersSettings:Add, Button, x390 y575 w200 h30 gSwapLettersSettingsReset, 🔄 Сбросить
    
    ; Загружаем настройки
    LoadSwapLettersSettings()
    
    Gui, SwapLettersSettings:Show, w600 h615, ⚙️ Настройки переставки букв
return

; === Загрузить настройки переставки ===
LoadSwapLettersSettings() {
    GuiControl,, SwapChance, 50
    GuiControl,, SwapProbability, 70
    GuiControl,, SwapMinWordLength, 3
    GuiControl,, SwapMaxWordLength, 15
    GuiControl,, SwapCountPerWord, 1
    GuiControl,, SwapDistance, 1
}

; === Сохранить настройки переставки ===
SwapLettersSettingsOK:
    Gui, SwapLettersSettings:Submit, NoHide
    MsgBox, 64, Успех, Настройки переставки букв сохранены!
    Gui, SwapLettersSettings:Destroy
return

; === Отмена настроек переставки ===
SwapLettersSettingsCancel:
    Gui, SwapLettersSettings:Destroy
return

; === Сбросить настройки переставки ===
SwapLettersSettingsReset:
    MsgBox, 36, Подтверждение, Сбросить все настройки переставки?
    IfMsgBox, Yes
    {
        LoadSwapLettersSettings()
        MsgBox, 64, Успех, Настройки сброшены!
    }
return

; ═══════════════════════════════════════════════════════════════════════════════
; 🎨 ВИЗУАЛЬНЫЙ РЕДАКТОР ПРАВИЛ ОШИБОК
; ═══════════════════════════════════════════════════════════════════════════════

OpenVisualRuleEditor:
    Gui, RuleEditor:New, +Owner1 +Resize
    Gui, RuleEditor:Font, s10, Segoe UI
    Gui, RuleEditor:Color, White
    
    ; Заголовок
    Gui, RuleEditor:Add, Text, x15 y10 w970 h30 c0066CC Center, 🎨 ВИЗУАЛЬНЫЙ РЕДАКТОР ПРАВИЛ ОШИБОК
    Gui, RuleEditor:Font, s9, Segoe UI
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; СПИСОК ПРАВИЛ (Левая панель)
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, RuleEditor:Add, GroupBox, x10 y45 w300 h550, 📋 Список правил
    Gui, RuleEditor:Add, ListView, vRulesList x20 y65 w280 h450 Grid gRuleSelected, №|Название|Тип|Вкл
    LV_ModifyCol(1, 30)
    LV_ModifyCol(2, 120)
    LV_ModifyCol(3, 80)
    LV_ModifyCol(4, 40)
    
    Gui, RuleEditor:Add, Button, x20 y520 w135 h25 gAddNewRule, ➕ Новое правило
    Gui, RuleEditor:Add, Button, x160 y520 w140 h25 gDeleteRule, ❌ Удалить
    Gui, RuleEditor:Add, Button, x20 y550 w135 h25 gDuplicateRule, 📋 Дублировать
    Gui, RuleEditor:Add, Button, x160 y550 w140 h25 gToggleRule, 🔄 Вкл/Выкл
    Gui, RuleEditor:Add, Button, x20 y575 w280 h20 gMoveRuleUp, ⬆ Вверх
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; РЕДАКТОР ПРАВИЛА (Правая панель)
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, RuleEditor:Add, GroupBox, x320 y45 w670 h550, ⚙️ Настройки правила
    
    ; Основные параметры
    Gui, RuleEditor:Add, Text, x330 y65, Название правила:
    Gui, RuleEditor:Add, Edit, vRuleName x330 y85 w300
    
    Gui, RuleEditor:Add, Text, x650 y65, Тип правила:
    Gui, RuleEditor:Add, DropDownList, vRuleType x650 y85 w330 gRuleTypeChanged, Замена букв|Перестановка букв|Удаление букв|Вставка символов|Дублирование букв|Пропуск слов|Замена слов|Изменение регистра|Добавление пробелов|Удаление пробелов|Перенос букв между словами|Случайные символы|Опечатки клавиатуры|Замена на похожие|Удвоение согласных|Пропуск гласных|Слияние слов|Разделение слов|Инверсия слов|Случайный порядок букв
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; УСЛОВИЯ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, RuleEditor:Add, GroupBox, x330 y120 w650 h150, 📌 Условия применения
    
    Gui, RuleEditor:Add, Checkbox, vCondWordContains x340 y140, Слово содержит:
    Gui, RuleEditor:Add, Edit, vCondWordContainsText x480 y137 w150
    
    Gui, RuleEditor:Add, Checkbox, vCondWordLength x340 y165, Длина слова:
    Gui, RuleEditor:Add, Text, x480 y168, от
    Gui, RuleEditor:Add, Edit, vCondWordLengthMin x510 y165 w40 Number
    Gui, RuleEditor:Add, Text, x555 y168, до
    Gui, RuleEditor:Add, Edit, vCondWordLengthMax x580 y165 w40 Number
    
    Gui, RuleEditor:Add, Checkbox, vCondPosition x340 y190, Позиция:
    Gui, RuleEditor:Add, DropDownList, vCondPositionType x480 y187 w150, Каждое N-е слово|Случайные слова|Первое слово|Последнее слово|Все слова
    Gui, RuleEditor:Add, Edit, vCondPositionN x635 y187 w40 Number
    
    Gui, RuleEditor:Add, Checkbox, vCondStartsWith x340 y215, Начинается с:
    Gui, RuleEditor:Add, Edit, vCondStartsWithText x480 y212 w150
    
    Gui, RuleEditor:Add, Checkbox, vCondEndsWith x340 y240, Заканчивается на:
    Gui, RuleEditor:Add, Edit, vCondEndsWithText x480 y237 w150
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ДЕЙСТВИЯ (Динамические поля в зависимости от типа)
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, RuleEditor:Add, GroupBox, x330 y275 w650 h200, 🎯 Действие
    
    ; Поля для "Замена букв"
    Gui, RuleEditor:Add, Text, vActionReplaceLabel1 x340 y295 Hidden, Заменить букву:
    Gui, RuleEditor:Add, Edit, vActionReplaceFrom x460 y292 w50 Hidden
    Gui, RuleEditor:Add, Text, vActionReplaceLabel2 x515 y295 Hidden, на:
    Gui, RuleEditor:Add, Edit, vActionReplaceTo x545 y292 w50 Hidden
    
    ; Поля для "Вставка символов"
    Gui, RuleEditor:Add, Text, vActionInsertLabel1 x340 y295 Hidden, Вставить символы:
    Gui, RuleEditor:Add, Edit, vActionInsertChars x460 y292 w150 Hidden
    Gui, RuleEditor:Add, Text, vActionInsertLabel2 x340 y320 Hidden, Позиция:
    Gui, RuleEditor:Add, DropDownList, vActionInsertPos x460 y317 w150 Hidden, В начало|В конец|После буквы|Перед буквой|Случайно
    
    ; Поля для "Перестановка"
    Gui, RuleEditor:Add, Text, vActionSwapLabel x340 y295 Hidden, Переставить букв:
    Gui, RuleEditor:Add, Edit, vActionSwapCount x460 y292 w50 Number Hidden
    
    ; Поля для "Удаление"
    Gui, RuleEditor:Add, Text, vActionDeleteLabel x340 y295 Hidden, Удалить букв:
    Gui, RuleEditor:Add, Edit, vActionDeleteCount x460 y292 w50 Number Hidden
    Gui, RuleEditor:Add, DropDownList, vActionDeletePos x515 y292 w150 Hidden, Случайно|В начале|В конце|В середине
    
    ; Общие параметры
    Gui, RuleEditor:Add, Text, x340 y400, Вероятность применения:
    Gui, RuleEditor:Add, Slider, vRuleProbability x340 y420 w300 Range0-100 ToolTip, 50
    Gui, RuleEditor:Add, Edit, vRuleProbabilityInput x650 y417 w50 Number, 50
    Gui, RuleEditor:Add, Text, x705 y420, `%
    
    Gui, RuleEditor:Add, Checkbox, vRuleEnabled x340 y450, ✓ Правило включено
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ПРЕВЬЮ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, RuleEditor:Add, GroupBox, x330 y480 w650 h115, 👁️ Предпросмотр
    Gui, RuleEditor:Add, Text, x340 y500, Тестовый текст:
    Gui, RuleEditor:Add, Edit, vRuleTestInput x340 y520 w630 h20, привет как дела что делаешь
    Gui, RuleEditor:Add, Text, x340 y545, Результат:
    Gui, RuleEditor:Add, Text, vRuleTestOutput x340 y565 w630 h20 cCC0000, првиет как дела что делаешь
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; КНОПКИ УПРАВЛЕНИЯ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, RuleEditor:Add, Button, x10 y605 w150 h30 gSaveRule, ✓ Сохранить правило
    Gui, RuleEditor:Add, Button, x170 y605 w140 h30 gTestRule, 🔄 Тест
    Gui, RuleEditor:Add, Button, x320 y605 w150 h30 gSaveRulePreset, 💾 Сохранить пресет
    Gui, RuleEditor:Add, Button, x480 y605 w150 h30 gLoadRulePreset, 📂 Загрузить пресет
    Gui, RuleEditor:Add, Button, x640 y605 w170 h30 gExportRules, 📤 Экспорт правил
    Gui, RuleEditor:Add, Button, x820 y605 w170 h30 gImportRules, 📥 Импорт правил
    
    Gui, RuleEditor:Add, Button, x10 y640 w480 h30 gApplyAllRules, ⚡ Применить все правила
    Gui, RuleEditor:Add, Button, x500 y640 w240 h30 gRuleEditorCancel, ✗ Закрыть
    Gui, RuleEditor:Add, Button, x750 y640 w240 h30 gClearAllRules, 🗑️ Очистить все
    
    ; Загружаем существующие правила
    LoadErrorRules()
    
    Gui, RuleEditor:Show, w1000 h680, 🎨 Визуальный редактор правил ошибок
return

; === Загрузить правила в список ===
LoadErrorRules() {
    global errorRules
    Gui, RuleEditor:Default
    Gui, RuleEditor:ListView, RulesList
    LV_Delete()
    
    if (!errorRules)
        errorRules := []
    
    for i, rule in errorRules {
        enabled := rule.enabled ? "✓" : "✗"
        LV_Add("", i, rule.name, rule.type, enabled)
    }
}

; === Выбрано правило из списка ===
RuleSelected:
    if (A_GuiEvent = "Normal" || A_GuiEvent = "DoubleClick") {
        Gui, RuleEditor:Default
        Gui, RuleEditor:ListView, RulesList
        row := LV_GetNext()
        if (row > 0) {
            global errorRules
            rule := errorRules[row]
            
            ; Загружаем данные правила в поля
            GuiControl,, RuleName, % rule.name
            GuiControl, ChooseString, RuleType, % rule.type
            GuiControl,, RuleProbability, % rule.probability
            GuiControl,, RuleProbabilityInput, % rule.probability
            GuiControl,, RuleEnabled, % rule.enabled
            
            ; Загружаем условия
            if (rule.conditions) {
                GuiControl,, CondWordContains, % rule.conditions.wordContains.enabled
                GuiControl,, CondWordContainsText, % rule.conditions.wordContains.text
                GuiControl,, CondWordLength, % rule.conditions.wordLength.enabled
                GuiControl,, CondWordLengthMin, % rule.conditions.wordLength.min
                GuiControl,, CondWordLengthMax, % rule.conditions.wordLength.max
            }
            
            ; Обновляем видимость полей действий
            Gosub, RuleTypeChanged
        }
    }
return

; === Изменен тип правила ===
RuleTypeChanged:
    Gui, RuleEditor:Submit, NoHide
    
    ; Скрываем все поля действий
    GuiControl, RuleEditor:Hide, ActionReplaceLabel1
    GuiControl, RuleEditor:Hide, ActionReplaceFrom
    GuiControl, RuleEditor:Hide, ActionReplaceLabel2
    GuiControl, RuleEditor:Hide, ActionReplaceTo
    GuiControl, RuleEditor:Hide, ActionInsertLabel1
    GuiControl, RuleEditor:Hide, ActionInsertChars
    GuiControl, RuleEditor:Hide, ActionInsertLabel2
    GuiControl, RuleEditor:Hide, ActionInsertPos
    GuiControl, RuleEditor:Hide, ActionSwapLabel
    GuiControl, RuleEditor:Hide, ActionSwapCount
    GuiControl, RuleEditor:Hide, ActionDeleteLabel
    GuiControl, RuleEditor:Hide, ActionDeleteCount
    GuiControl, RuleEditor:Hide, ActionDeletePos
    
    ; Показываем нужные поля
    if (RuleType = "Замена букв") {
        GuiControl, RuleEditor:Show, ActionReplaceLabel1
        GuiControl, RuleEditor:Show, ActionReplaceFrom
        GuiControl, RuleEditor:Show, ActionReplaceLabel2
        GuiControl, RuleEditor:Show, ActionReplaceTo
    } else if (RuleType = "Вставка символов") {
        GuiControl, RuleEditor:Show, ActionInsertLabel1
        GuiControl, RuleEditor:Show, ActionInsertChars
        GuiControl, RuleEditor:Show, ActionInsertLabel2
        GuiControl, RuleEditor:Show, ActionInsertPos
    } else if (RuleType = "Перестановка букв") {
        GuiControl, RuleEditor:Show, ActionSwapLabel
        GuiControl, RuleEditor:Show, ActionSwapCount
    } else if (RuleType = "Удаление букв") {
        GuiControl, RuleEditor:Show, ActionDeleteLabel
        GuiControl, RuleEditor:Show, ActionDeleteCount
        GuiControl, RuleEditor:Show, ActionDeletePos
    }
return

; === Добавить новое правило ===
AddNewRule:
    global errorRules
    if (!errorRules)
        errorRules := []
    
    ; Создаем новое правило с настройками по умолчанию
    newRule := {name: "Новое правило " . (errorRules.Length() + 1)
              , type: "Замена букв"
              , enabled: true
              , probability: 50
              , conditions: {wordContains: {enabled: false, text: ""}
                           , wordLength: {enabled: false, min: 1, max: 20}
                           , position: {enabled: false, type: "Каждое N-е слово", n: 1}}
              , actions: {replaceFrom: "а", replaceTo: "о"}}
    
    errorRules.Push(newRule)
    LoadErrorRules()
    
    ; Выбираем новое правило
    Gui, RuleEditor:ListView, RulesList
    LV_Modify(errorRules.Length(), "Select Focus Vis")
    Gosub, RuleSelected
return

; === Удалить правило ===
DeleteRule:
    Gui, RuleEditor:Default
    Gui, RuleEditor:ListView, RulesList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите правило для удаления!
        return
    }
    
    MsgBox, 36, Подтверждение, Удалить выбранное правило?
    IfMsgBox, Yes
    {
        global errorRules
        errorRules.RemoveAt(row)
        LoadErrorRules()
    }
return

; === Сохранить правило ===
SaveRule:
    Gui, RuleEditor:Submit, NoHide
    Gui, RuleEditor:Default
    Gui, RuleEditor:ListView, RulesList
    row := LV_GetNext()
    
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите правило для сохранения!
        return
    }
    
    global errorRules
    
    ; Сохраняем данные правила
    errorRules[row].name := RuleName
    errorRules[row].type := RuleType
    errorRules[row].probability := RuleProbabilityInput
    errorRules[row].enabled := RuleEnabled
    
    ; Сохраняем условия
    errorRules[row].conditions := {wordContains: {enabled: CondWordContains, text: CondWordContainsText}
                                  , wordLength: {enabled: CondWordLength, min: CondWordLengthMin, max: CondWordLengthMax}
                                  , position: {enabled: CondPosition, type: CondPositionType, n: CondPositionN}
                                  , startsWith: {enabled: CondStartsWith, text: CondStartsWithText}
                                  , endsWith: {enabled: CondEndsWith, text: CondEndsWithText}}
    
    ; Сохраняем действия в зависимости от типа
    if (RuleType = "Замена букв") {
        errorRules[row].actions := {replaceFrom: ActionReplaceFrom, replaceTo: ActionReplaceTo}
    } else if (RuleType = "Вставка символов") {
        errorRules[row].actions := {insertChars: ActionInsertChars, insertPos: ActionInsertPos}
    } else if (RuleType = "Перестановка букв") {
        errorRules[row].actions := {swapCount: ActionSwapCount}
    } else if (RuleType = "Удаление букв") {
        errorRules[row].actions := {deleteCount: ActionDeleteCount, deletePos: ActionDeletePos}
    }
    
    LoadErrorRules()
    MsgBox, 64, Успех, Правило сохранено!
return

; === Тест правила ===
TestRule:
    Gui, RuleEditor:Submit, NoHide
    
    testText := RuleTestInput
    if (testText = "") {
        MsgBox, 48, Ошибка, Введите тестовый текст!
        return
    }
    
    ; Применяем текущее правило к тексту
    result := ApplySingleRule(testText, RuleType, RuleProbabilityInput)
    
    GuiControl,, RuleTestOutput, %result%
return

; === Применить одно правило (упрощенная версия) ===
ApplySingleRule(text, ruleType, probability) {
    Random, chance, 1, 100
    if (chance > probability)
        return text
    
    words := StrSplit(text, " ")
    newWords := []
    
    for i, word in words {
        newWord := word
        
        if (ruleType = "Замена букв") {
            StringReplace, newWord, newWord, а, о, All
        } else if (ruleType = "Перестановка букв" && StrLen(word) > 2) {
            Random, pos, 1, % StrLen(word) - 1
            char1 := SubStr(word, pos, 1)
            char2 := SubStr(word, pos + 1, 1)
            newWord := SubStr(word, 1, pos - 1) . char2 . char1 . SubStr(word, pos + 2)
        } else if (ruleType = "Удаление букв" && StrLen(word) > 2) {
            Random, pos, 1, % StrLen(word)
            newWord := SubStr(word, 1, pos - 1) . SubStr(word, pos + 1)
        } else if (ruleType = "Вставка символов") {
            Random, pos, 1, % StrLen(word) + 1
            newWord := SubStr(word, 1, pos - 1) . "=" . SubStr(word, pos)
        } else if (ruleType = "Дублирование букв" && StrLen(word) > 0) {
            Random, pos, 1, % StrLen(word)
            char := SubStr(word, pos, 1)
            newWord := SubStr(word, 1, pos) . char . SubStr(word, pos + 1)
        }
        
        newWords.Push(newWord)
    }
    
    result := ""
    for i, word in newWords {
        result .= (result != "" ? " " : "") . word
    }
    
    return result
}

; === Закрыть редактор ===
RuleEditorCancel:
RuleEditorGuiClose:
    Gui, RuleEditor:Destroy
return

; === Дублировать правило ===
DuplicateRule:
    Gui, RuleEditor:Default
    Gui, RuleEditor:ListView, RulesList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите правило для дублирования!
        return
    }
    
    global errorRules
    newRule := errorRules[row].Clone()
    newRule.name .= " (копия)"
    errorRules.Push(newRule)
    LoadErrorRules()
return

; === Переключить правило ===
ToggleRule:
    Gui, RuleEditor:Default
    Gui, RuleEditor:ListView, RulesList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите правило!
        return
    }
    
    global errorRules
    errorRules[row].enabled := !errorRules[row].enabled
    LoadErrorRules()
return

; === Переместить правило вверх ===
MoveRuleUp:
    Gui, RuleEditor:Default
    Gui, RuleEditor:ListView, RulesList
    row := LV_GetNext()
    if (row <= 1) {
        return
    }
    
    global errorRules
    temp := errorRules[row - 1]
    errorRules[row - 1] := errorRules[row]
    errorRules[row] := temp
    LoadErrorRules()
    LV_Modify(row - 1, "Select Focus Vis")
return

; === Сохранить пресет правил ===
SaveRulePreset:
    global errorRules, errorRulesPresetsDir
    
    if (!errorRules || errorRules.Length() = 0) {
        MsgBox, 48, Ошибка, Нет правил для сохранения!
        return
    }
    
    InputBox, presetName, Сохранить пресет, Введите название пресета:, , 400, 150
    if (ErrorLevel || presetName = "")
        return
    
    ; Сохраняем в JSON формат
    jsonData := "["
    for i, rule in errorRules {
        if (i > 1)
            jsonData .= ","
        jsonData .= "{""name"":""" . rule.name . """,""type"":""" . rule.type . """,""enabled"":" . (rule.enabled ? "true" : "false") . ",""probability"":" . rule.probability . "}"
    }
    jsonData .= "]"
    
    presetFile := errorRulesPresetsDir . "\" . presetName . ".json"
    FileDelete, %presetFile%
    FileAppend, %jsonData%, %presetFile%, UTF-8
    
    MsgBox, 64, Успех, Пресет "%presetName%" сохранён!
return

; === Загрузить пресет правил ===
LoadRulePreset:
    global errorRulesPresetsDir
    
    FileSelectFile, presetFile, 3, %errorRulesPresetsDir%, Выберите пресет правил, JSON Files (*.json)
    if (ErrorLevel || presetFile = "")
        return
    
    MsgBox, 64, Информация, Функция загрузки пресетов будет реализована в следующей версии!
return

; === Экспорт правил ===
ExportRules:
    MsgBox, 64, Информация, Функция экспорта будет реализована в следующей версии!
return

; === Импорт правил ===
ImportRules:
    MsgBox, 64, Информация, Функция импорта будет реализована в следующей версии!
return

; === Применить все правила ===
ApplyAllRules:
    Gui, RuleEditor:Submit, NoHide
    
    testText := RuleTestInput
    if (testText = "") {
        MsgBox, 48, Ошибка, Введите тестовый текст!
        return
    }
    
    global errorRules
    result := testText
    
    ; Применяем все включенные правила
    for i, rule in errorRules {
        if (rule.enabled) {
            result := ApplySingleRule(result, rule.type, rule.probability)
        }
    }
    
    GuiControl,, RuleTestOutput, %result%
return

; === Очистить все правила ===
ClearAllRules:
    MsgBox, 36, Подтверждение, Удалить все правила?
    IfMsgBox, Yes
    {
        global errorRules
        errorRules := []
        LoadErrorRules()
    }
return


; === Обработка изменения типа ошибок ===
ErrorTypeChanged:
    Gui, ErrorSettings:Submit, NoHide
    
    ; Скрываем все дополнительные поля
    GuiControl, ErrorSettings:Hide, ErrorCountLabel
    GuiControl, ErrorSettings:Hide, ErrorCount
    GuiControl, ErrorSettings:Hide, ErrorCountUpDown
    GuiControl, ErrorSettings:Hide, RandomCharsLabel
    GuiControl, ErrorSettings:Hide, RandomCharsCount
    GuiControl, ErrorSettings:Hide, RandomCharsCountUpDown
    GuiControl, ErrorSettings:Hide, RandomCharsInComplexWords
    GuiControl, ErrorSettings:Hide, RandomCharsPerWordLabel
    GuiControl, ErrorSettings:Hide, RandomCharsPerWord
    GuiControl, ErrorSettings:Hide, RandomCharsPerWordUpDown
    
    ; Показываем нужные поля в зависимости от типа
    if (ErrorType = "Перемешивание букв") {
        GuiControl, ErrorSettings:Show, ErrorCountLabel
        GuiControl, ErrorSettings:Show, ErrorCount
        GuiControl, ErrorSettings:Show, ErrorCountUpDown
    } else if (ErrorType = "Ввод случайных русских букв" || ErrorType = "Ввод случайных английских букв" || ErrorType = "Ввод случайных символов") {
        GuiControl, ErrorSettings:Show, RandomCharsLabel
        GuiControl, ErrorSettings:Show, RandomCharsCount
        GuiControl, ErrorSettings:Show, RandomCharsCountUpDown
        GuiControl, ErrorSettings:Show, RandomCharsInComplexWords
        GuiControl, ErrorSettings:Show, RandomCharsPerWordLabel
        GuiControl, ErrorSettings:Show, RandomCharsPerWord
        GuiControl, ErrorSettings:Show, RandomCharsPerWordUpDown
    }
return

; === Загрузить настройки применения ошибок ===
LoadErrorApplicationSettings() {
    global errorWordCount, errorPosition, errorFrequency, errorChance
    global errorType, errorCount, randomCharsCount, randomCharsInComplexWords, randomCharsPerWord
    global errorCapitalize, errorPreserveLength, errorSmartMode
    
    GuiControl,, ErrorWordCount, %errorWordCount%
    GuiControl, ChooseString, ErrorPosition, %errorPosition%
    GuiControl,, ErrorFrequency, %errorFrequency%
    GuiControl,, ErrorChance, %errorChance%
    GuiControl, ChooseString, ErrorType, %errorType%
    GuiControl,, ErrorCount, %errorCount%
    GuiControl,, RandomCharsCount, %randomCharsCount%
    GuiControl,, RandomCharsInComplexWords, % randomCharsInComplexWords ? 1 : 0
    GuiControl,, RandomCharsPerWord, %randomCharsPerWord%
    GuiControl,, ErrorCapitalize, % errorCapitalize ? 1 : 0
    GuiControl,, ErrorPreserveLength, % errorPreserveLength ? 1 : 0
    GuiControl,, ErrorSmartMode, % errorSmartMode ? 1 : 0
    
    ; Вызываем обработчик для показа/скрытия полей
    Gosub, ErrorTypeChanged
}
return

; === Умная генерация вариаций для слова ===
GenerateSmartVariations(word, count := 5) {
    variations := []
    wordLen := StrLen(word)
    
    if (wordLen <= 1)
        return variations
    
    ; Работаем с оригинальным словом, сохраняя пробелы
    normalizedWord := word
    if (normalizedWord = "")
        return variations
    
    ; Генерируем нужное количество вариаций
    attemptsPerVariation := 10
    Loop % count {
        attempt := 0
        Loop {
            attempt++
            if (attempt > attemptsPerVariation)
                break
            
            ; Создаем вариацию случайным методом
            variation := CreateRandomVariation(normalizedWord)
            
            ; Проверяем что вариация уникальна и отличается от оригинала
            if (variation != normalizedWord && !Contains(variations, variation)) {
                variations.Push(variation)
                break
            }
        }
    }
    
    return variations
}

; === Создание случайной вариации слова ===
CreateRandomVariation(word) {
    letters := StrSplit(word)
    wordLen := letters.Length()
    
    if (wordLen <= 1)
        return word
    
    ; Выбираем случайный метод генерации
    Random, method, 1, 5
    
    ; Метод 1: Перестановка соседних букв
    if (method = 1 && wordLen >= 2) {
        Random, pos, 1, % wordLen - 1
        ; Пропускаем пробелы
        if (letters[pos] != " " && letters[pos + 1] != " ") {
            result := ""
            Loop % wordLen {
                if (A_Index = pos) {
                    result .= letters[pos + 1] . letters[pos]
                    continue
                }
                if (A_Index = pos + 1)
                    continue
                result .= letters[A_Index]
            }
            return result
        }
    }
    
    ; Метод 2: Перестановка в середине слова
    if (method = 2 && wordLen >= 4) {
        mid := Floor(wordLen / 2)
        if (letters[mid] != " " && letters[mid + 1] != " ") {
            result := ""
            Loop % wordLen {
                if (A_Index = mid) {
                    result .= letters[mid + 1] . letters[mid]
                    continue
                }
                if (A_Index = mid + 1)
                    continue
                result .= letters[A_Index]
            }
            return result
        }
    }
    
    ; Метод 3: Перестановка первой и последней буквы
    if (method = 3 && wordLen >= 3) {
        ; Находим первую непробельную букву
        firstPos := 0
        lastPos := 0
        Loop % wordLen {
            if (letters[A_Index] != " ") {
                if (firstPos = 0)
                    firstPos := A_Index
                lastPos := A_Index
            }
        }
        if (firstPos > 0 && lastPos > firstPos) {
            result := ""
            Loop % wordLen {
                if (A_Index = firstPos)
                    result .= letters[lastPos]
                else if (A_Index = lastPos)
                    result .= letters[firstPos]
                else
                    result .= letters[A_Index]
            }
            return result
        }
    }
    
    ; Метод 4: Случайная перестановка двух букв
    if (method = 4 && wordLen >= 2) {
        ; Находим все позиции непробельных букв
        nonSpacePos := []
        Loop % wordLen {
            if (letters[A_Index] != " ")
                nonSpacePos.Push(A_Index)
        }
        if (nonSpacePos.Length() >= 2) {
            Random, idx1, 1, % nonSpacePos.Length()
            Random, idx2, 1, % nonSpacePos.Length()
            if (idx1 != idx2) {
                pos1 := nonSpacePos[idx1]
                pos2 := nonSpacePos[idx2]
                result := ""
                Loop % wordLen {
                    if (A_Index = pos1)
                        result .= letters[pos2]
                    else if (A_Index = pos2)
                        result .= letters[pos1]
                    else
                        result .= letters[A_Index]
                }
                return result
            }
        }
    }
    
    ; Метод 5: Удаление или дублирование буквы
    if (method = 5 && wordLen >= 2) {
        Random, action, 1, 2
        Random, pos, 1, % wordLen
        if (letters[pos] != " ") {
            result := ""
            if (action = 1) {
                ; Удаление буквы
                Loop % wordLen {
                    if (A_Index != pos)
                        result .= letters[A_Index]
                }
            } else {
                ; Дублирование буквы
                Loop % wordLen {
                    result .= letters[A_Index]
                    if (A_Index = pos)
                        result .= letters[A_Index]
                }
            }
            return result
        }
    }
    
    ; Если ничего не сработало, возвращаем оригинал
    return word
}

; === Сохранить настройки ошибок ===
SaveErrorSettings() {
    global errorWordVariations, smartErrorMode, errorWordCount, errorPosition, errorFrequency
    global errorChance, errorType, errorCount, randomCharsCount, randomCharsInComplexWords, randomCharsPerWord
    global errorCapitalize, errorPreserveLength, errorSmartMode
    
    ; Сохраняем умный режим
    IniWrite, %smartErrorMode%, %appDataDir%\AutoTyper.ini, ErrorSettings, SmartMode
    
    ; Сохраняем новые настройки применения ошибок
    IniWrite, %errorWordCount%, %appDataDir%\AutoTyper.ini, ErrorSettings, WordCount
    IniWrite, %errorPosition%, %appDataDir%\AutoTyper.ini, ErrorSettings, Position
    IniWrite, %errorFrequency%, %appDataDir%\AutoTyper.ini, ErrorSettings, Frequency
    IniWrite, %errorChance%, %appDataDir%\AutoTyper.ini, ErrorSettings, Chance
    IniWrite, %errorType%, %appDataDir%\AutoTyper.ini, ErrorSettings, Type
    IniWrite, %errorCount%, %appDataDir%\AutoTyper.ini, ErrorSettings, Count
    IniWrite, %randomCharsCount%, %appDataDir%\AutoTyper.ini, ErrorSettings, RandomCharsCount
    IniWrite, %randomCharsInComplexWords%, %appDataDir%\AutoTyper.ini, ErrorSettings, RandomCharsInComplexWords
    IniWrite, %randomCharsPerWord%, %appDataDir%\AutoTyper.ini, ErrorSettings, RandomCharsPerWord
    IniWrite, %errorCapitalize%, %appDataDir%\AutoTyper.ini, ErrorSettings, Capitalize
    IniWrite, %errorPreserveLength%, %appDataDir%\AutoTyper.ini, ErrorSettings, PreserveLength
    IniWrite, %errorSmartMode%, %appDataDir%\AutoTyper.ini, ErrorSettings, SmartMode2
    
    ; Сохраняем слова и вариации
    for word, variations in errorWordVariations {
        variationsStr := ""
        for i, variation in variations {
            if (i > 1)
                variationsStr .= ","
            variationsStr .= variation
        }
        IniWrite, %variationsStr%, %appDataDir%\AutoTyper.ini, ErrorVariations, %word%
    }
}

; === Загрузить настройки ошибок ===
LoadErrorSettings() {
    global errorWordVariations, smartErrorMode, errorWordCount, errorPosition, errorFrequency
    global errorChance, errorType, errorCount, randomCharsCount, randomCharsInComplexWords, randomCharsPerWord
    global errorCapitalize, errorPreserveLength, errorSmartMode
    
    ; Загружаем умный режим
    IniRead, savedSmartMode, %appDataDir%\AutoTyper.ini, ErrorSettings, SmartMode, 0
    smartErrorMode := savedSmartMode ? true : false
    
    ; Загружаем новые настройки применения ошибок
    IniRead, errorWordCount, %appDataDir%\AutoTyper.ini, ErrorSettings, WordCount, 5
    IniRead, errorPosition, %appDataDir%\AutoTyper.ini, ErrorSettings, Position, Каждое N-слово
    IniRead, errorFrequency, %appDataDir%\AutoTyper.ini, ErrorSettings, Frequency, 3
    IniRead, errorChance, %appDataDir%\AutoTyper.ini, ErrorSettings, Chance, 50
    IniRead, errorType, %appDataDir%\AutoTyper.ini, ErrorSettings, Type, Обычный
    IniRead, errorCount, %appDataDir%\AutoTyper.ini, ErrorSettings, Count, 2
    IniRead, randomCharsCount, %appDataDir%\AutoTyper.ini, ErrorSettings, RandomCharsCount, 1
    IniRead, savedRandomCharsInComplexWords, %appDataDir%\AutoTyper.ini, ErrorSettings, RandomCharsInComplexWords, 0
    randomCharsInComplexWords := savedRandomCharsInComplexWords ? true : false
    IniRead, randomCharsPerWord, %appDataDir%\AutoTyper.ini, ErrorSettings, RandomCharsPerWord, 1
    IniRead, savedCapitalize, %appDataDir%\AutoTyper.ini, ErrorSettings, Capitalize, 1
    errorCapitalize := savedCapitalize ? true : false
    IniRead, savedPreserveLength, %appDataDir%\AutoTyper.ini, ErrorSettings, PreserveLength, 0
    errorPreserveLength := savedPreserveLength ? true : false
    IniRead, savedSmartMode2, %appDataDir%\AutoTyper.ini, ErrorSettings, SmartMode2, 1
    errorSmartMode := savedSmartMode2 ? true : false
    
    ; Загружаем слова и вариации
    errorWordVariations := {}
    
    ; Читаем весь раздел ErrorVariations
    IniRead, allVariations, %appDataDir%\AutoTyper.ini, ErrorVariations
    if (allVariations != "ERROR") {
        ; Парсим строки формата "ключ=значение"
        Loop, Parse, allVariations, `n, `r
        {
            line := Trim(A_LoopField)
            if (line = "")
                continue
            
            ; Разделяем на ключ и значение
            pos := InStr(line, "=")
            if (pos > 0) {
                word := Trim(SubStr(line, 1, pos - 1))
                variationsStr := Trim(SubStr(line, pos + 1))
                
                if (word != "" && variationsStr != "") {
                    variations := []
                    Loop, Parse, variationsStr, `,
                    {
                        variation := Trim(A_LoopField)
                        if (variation != "")
                            variations.Push(variation)
                    }
                    errorWordVariations[word] := variations
                } else if (word != "") {
                    errorWordVariations[word] := []
                }
            }
        }
    }
}

; === Функция обновления режима генератора ошибок ===
UpdateErrorGenLevel:
    Gui, 1:Submit, NoHide
    ; Скрываем поле для своего количества
    GuiControl, Hide, CustomErrorCount
    GuiControl, Hide, CustomErrorText
    
    ; Показываем только если выбран режим "Свой"
    if (ErrorGenLevel = 7) {
        GuiControl, Show, CustomErrorCount
        GuiControl, Show, CustomErrorText
    }
return

; === Функция тестирования генератора ошибок ===
TestErrorGenerator:
    Gui, 1:Submit, NoHide
    if (TestErrorText = "") {
        MsgBox Введите тестовый текст!
        return
    }
    
    resultText := GenerateErrors(TestErrorText, ErrorGenLevel, ErrorLocation, CustomErrorCount)
    MsgBox, 64, Результат теста, Исходный текст:`n%TestErrorText%`n`nТекст с ошибками:`n%resultText%
return

ApplyTestErrorToText:
    Gui, 1:Submit, NoHide
    if (TestErrorText = "") {
        MsgBox, 48, Ошибка, Введите тестовый текст!
        return
    }
    
    resultText := GenerateErrors(TestErrorText, ErrorGenLevel, ErrorLocation, CustomErrorCount)
    GuiControl,, TypeText, %resultText%
    
    SB_SetText("Ошибки применены к основному тексту", 1)
    MsgBox, 64, Успех, Текст с ошибками добавлен в основное поле!
return

ErrorPreview:
    Gui, 1:Submit, NoHide
    if (TestErrorText = "") {
        MsgBox, 48, Ошибка, Введите тестовый текст для превью!
        return
    }
    
    ; Генерируем несколько вариантов для превью
    preview := "=== ПРЕВЬЮ ГЕНЕРАТОРА ОШИБОК ===`n`n"
    preview .= "Исходный текст:`n" . TestErrorText . "`n`n"
    preview .= "Варианты с ошибками:`n`n"
    
    Loop, 3 {
        resultText := GenerateErrors(TestErrorText, ErrorGenLevel, ErrorLocation, CustomErrorCount)
        preview .= "Вариант " . A_Index . ":`n" . resultText . "`n`n"
    }
    
    MsgBox, 64, Превью ошибок, %preview%
return

ErrorExport:
    Gui, 1:Submit, NoHide
    if (TestErrorText = "") {
        MsgBox, 48, Ошибка, Введите тестовый текст для экспорта!
        return
    }
    
    global appDataDir
    
    FileSelectFile, exportFile, S16, %appDataDir%\error_test.txt, Экспорт теста ошибок, Текстовые файлы (*.txt)
    if (exportFile = "")
        return
    
    ; Генерируем 10 вариантов
    content := "=== ЭКСПОРТ ГЕНЕРАТОРА ОШИБОК ===`n`n"
    content .= "Исходный текст: " . TestErrorText . "`n`n"
    content .= "Настройки:`n"
    content .= "- Уровень: " . ErrorGenLevel . "`n"
    content .= "- Позиция: " . ErrorLocation . "`n`n"
    content .= "Варианты с ошибками:`n`n"
    
    Loop, 10 {
        resultText := GenerateErrors(TestErrorText, ErrorGenLevel, ErrorLocation, CustomErrorCount)
        content .= A_Index . ". " . resultText . "`n"
    }
    
    FileDelete, %exportFile%
    FileAppend, %content%, %exportFile%, UTF-8
    
    MsgBox, 64, Успех, Тест экспортирован в:`n%exportFile%
return

; === Тест перемешивателя текста (кнопка в GUI) ===
RunShuffleTest:
    Gui, 1:Submit, NoHide
    ; Получаем текст из поля теста
    if (ShuffleTestInput = "") {
        MsgBox, 48, Тест перемешивателя, Введите текст для тестирования перемешивания!
        return
    }

    ; Определяем числовой уровень перемешивания по выбранному имени
    shuffleNum := 1
    if (TextShuffleLevel = "Низкий")
        shuffleNum := 2
    else if (TextShuffleLevel = "Средний")
        shuffleNum := 3
    else if (TextShuffleLevel = "Высокий")
        shuffleNum := 4
    else if (TextShuffleLevel = "Экстремальный")
        shuffleNum := 5

    ; Выполняем перемешивание и выводим результат в поле вывода
    result := ShuffleText(ShuffleTestInput, shuffleNum)
    GuiControl,, ShuffleTestOutput, %result%
return

; === Тест разбивки текста (кнопка в GUI) ===
RunSplitTest:
    Gui, 1:Submit, NoHide
    ; Выбираем источник текста
    if (SplitSource = "Основной текст")
        src := TypeText
    else
        src := SplitManualInput

    if (Trim(src) = "") {
        MsgBox, 48, Тест разбивки, Введите текст (или выберите источник с основного текста)!
        return
    }

    ; Получаем числовой размер блока
    splitN := SplitSize + 0
    if (splitN < 1)
        splitN := 1

    ; Нормализуем пробелы и перевод строки в пробелы
    processed := RegExReplace(src, "[\r\n]+", " ")
    processed := RegExReplace(processed, "\s+", " ")
    processed := Trim(processed)

    ; Разбиваем на слова
    words := StrSplit(processed, " ")
    total := words.Length()
    preview := ""
    idx := 1
    while (idx <= total) {
        chunk := []
        loop, % splitN {
            if (idx > total)
                break
            chunk.Push(words[idx])
            idx += 1
        }
        ; Объединяем слова в одну строку (AHK v1 не имеет Join, поэтому собираем вручную)
        chunkText := ""
        for k, v in chunk {
            if (k > 1)
                chunkText .= " "
            chunkText .= v
        }
        preview .= chunkText
        if (idx <= total)
            preview .= "`n"
    }

    GuiControl,, SplitPreviewOutput, %preview%
return

; === Добавить собственное значение для количества слов (кнопка ➕ рядом с SplitSize) ===
AddSplitNumber:
    Gui, 1:Submit, NoHide
    val := Trim(SplitSize)
    if (val = "") {
        InputBox, val, Добавить число слов, Введите число слов (целое положительное):, , 300, 130
        if ErrorLevel
            return
        val := Trim(val)
    }

    if (!RegExMatch(val, "^\d+$") || val <= 0) {
        MsgBox, 48, Неверное значение, Введите корректное положительное целое число.
        return
    }

    ; Загружаем текущий список кастомных значений (строка с запятыми)
    if (savedSplitCustomList = "")
        newList := val
    else {
        ; Проверим, уже ли есть такое значение
        found := false
        parts := StrSplit(savedSplitCustomList, ",")
        for i, p in parts {
            if (p = val) {
                found := true
                break
            }
        }
        if (!found) {
            newList := savedSplitCustomList "," val
        } else {
            newList := savedSplitCustomList
        }
    }

    ; Сохраняем в INI
    savedSplitCustomList := newList
    IniWrite, %savedSplitCustomList%, %appDataDir%\AutoTyper.ini, Split, CustomList

    ; Устанавливаем текущее значение в контроле (пользователь видит введённое значение)
    GuiControl,, SplitSize, %val%

    MsgBox, 64, Сохранено, Число %val% сохранено в списке пользовательских значений.`n(Будет доступно в выпадающем списке после перезапуска.)
return

; === Функция применения ошибок к основному тексту ===
ApplyErrorToText:
    Gui, 1:Submit, NoHide
    if (TypeText = "") {
        MsgBox Основной текст пуст!
        return
    }
    
    TypeText := GenerateErrors(TypeText, ErrorGenLevel, ErrorLocation, CustomErrorCount)
    GuiControl,, TypeText, %TypeText%
    MsgBox, 64, Успех, Ошибки применены к основному тексту!
return

; === Основная функция генерации ошибок ===
GenerateErrors(text, level, location, customCount) {
    ; Ранее здесь применялся параметр перемешивания ошибок (ErrorShuffleLevel).
    ; Убран: перемешиватель текста теперь полностью независим от генератора ошибок.
    if (level = 1) ; Отключено
        return text
    
    ; Определяем количество ошибок
    errorCount := 0
    if (level = 2) ; Маленький
        errorCount := 5
    else if (level = 3) ; Средний
        errorCount := 10
    else if (level = 4) ; Высокий
        errorCount := 15
    else if (level = 5) ; Гигантский
        errorCount := 20
    else if (level = 6) ; Экстремальный
        errorCount := 25
    else if (level = 7) ; Свой
        errorCount := customCount
    
    if (errorCount <= 0)
        return text
    
    ; Генерация случайных букв для вставки
    randomLetters := "абвгдеёжзийклмнопрстуфхцчшщъыьэюя"
    
    if (location = 1) { ; В слове
        words := StrSplit(text, " ")
        if (words.Length() = 0)
            return text
        
        ; Выбираем случайное слово
        Random, wordIndex, 1, % words.Length()
        targetWord := words[wordIndex]
        
        ; Вставляем ошибки в выбранное слово
        Loop % errorCount {
            Random, pos, 1, % StrLen(targetWord)
            Random, letterIndex, 1, % StrLen(randomLetters)
            newLetter := SubStr(randomLetters, letterIndex, 1)
            targetWord := SubStr(targetWord, 1, pos - 1) . newLetter . SubStr(targetWord, pos + 1)
        }
        
        words[wordIndex] := targetWord
        
        ; Собираем текст обратно
        result := ""
        for i, word in words
            result .= (result ? " " : "") . word
        ; Previously applied ShuffleText here — removed. Перемешиватель теперь управляется отдельно в своей вкладке.
        return result
        
    } else if (location = 2) { ; В предложении
        sentences := StrSplit(text, ".!?")
        if (sentences.Length() = 0)
            return text
        
        ; Выбираем случайное предложение
        Random, sentenceIndex, 1, % sentences.Length()
        targetSentence := sentences[sentenceIndex]
        
        ; Вставляем ошибки в предложение
        Loop % errorCount {
            Random, pos, 1, % StrLen(targetSentence)
            Random, letterIndex, 1, % StrLen(randomLetters)
            newLetter := SubStr(randomLetters, letterIndex, 1)
            targetSentence := SubStr(targetSentence, 1, pos - 1) . newLetter . SubStr(targetSentence, pos + 1)
        }
        
        sentences[sentenceIndex] := targetSentence
        
        ; Собираем текст обратно
        result := ""
        for i, sentence in sentences
            result .= sentence . (i < sentences.Length() ? SubStr(text, InStr(text, sentence) + StrLen(sentence), 1) : "")
        ; Previously applied ShuffleText here — removed. Перемешиватель теперь управляется отдельно в своей вкладке.
        return result
        
    } else if (location = 3) { ; В разброс
        result := text
        textLength := StrLen(result)
        
        Loop % errorCount {
            Random, pos, 1, % textLength
            Random, letterIndex, 1, % StrLen(randomLetters)
            newLetter := SubStr(randomLetters, letterIndex, 1)
            result := SubStr(result, 1, pos - 1) . newLetter . SubStr(result, pos + 1)
        }
        ; Previously applied ShuffleText here — removed. Перемешиватель теперь управляется отдельно в своей вкладке.
        return result
    }
    
    return text
}

; === Функция обновления режима Auto-Enter ===
UpdateAutoEnterMode:
    Gui, 1:Submit, NoHide
    ; Скрываем все элементы сначала
    GuiControl, Hide, MaxWordsLabel
    GuiControl, Hide, MaxWordsInput
    GuiControl, Hide, MaxWordsHint
    GuiControl, Hide, TimeLabel
    GuiControl, Hide, TimeInput
    GuiControl, Hide, TimeUnit
    GuiControl, Hide, TimeHint
    
    ; Показываем нужные элементы в зависимости от режима
    if (AutoEnterMode = 2) { ; Максимум слов
        GuiControl, Show, MaxWordsLabel
        GuiControl, Show, MaxWordsInput
        GuiControl, Show, MaxWordsHint
    } else if (AutoEnterMode = 3) { ; Enter через время
        GuiControl, Show, TimeLabel
        GuiControl, Show, TimeInput
        GuiControl, Show, TimeUnit
        GuiControl, Show, TimeHint
    } else if (AutoEnterMode = 4) { ; По циклам
        ; Циклы управляются через ListView
        SB_SetText("Режим циклов Auto-Enter активирован", 1)
    } else if (AutoEnterMode = 5) { ; По биндам
        ; Бинды управляются через ListView
        SB_SetText("Режим биндов Auto-Enter активирован", 1)
    }
    
    UpdateAutoEnterTestStatus()
return

; Multi-window functions removed per user request

; === НОВАЯ СИСТЕМА КАТЕГОРИЙ ===

; Инициализация системы категорий
InitializeCategorySystem() {
    global categoriesFile, presetDir, navigationLevel
    
    ; Создаем файл категорий если не существует
    if (!FileExist(categoriesFile)) {
        ; Создаем пример структуры
        IniWrite, Общие, %categoriesFile%, Categories, List
        IniWrite, Стандартные, %categoriesFile%, Category_Общие, Subcategories
        
        ; Создаем папки
        generalPath := presetDir . "\Общие\Стандартные"
        if (!FileExist(generalPath))
            FileCreateDir, %generalPath%
        
        ; Мигрируем старые пресеты если они есть
        Loop, Files, %presetDir%\*.txt
        {
            ; Перемещаем старые txt файлы в Общие\Стандартные
            oldPath := A_LoopFileFullPath
            newPath := generalPath . "\" . A_LoopFileName
            FileCopy, %oldPath%, %newPath%, 1
            FileDelete, %oldPath%
        }
    }
    
    ; Устанавливаем начальный уровень навигации
    navigationLevel := "categories"
}

; === Функция загрузки пресетов (УСТАРЕЛА - заменена на LoadCategories) ===
LoadPresets() {
    LoadCategories()  ; Перенаправляем на новую систему
}

; === НОВАЯ СИСТЕМА КАТЕГОРИЙ ===

; Загрузка категорий
LoadCategories() {
    global categoriesFile, navigationLevel, currentCategory, currentSubcategory, presetDir
    
    GuiControl,, CategoryList, |
    
    if (navigationLevel = "categories") {
        ; Показываем категории
        GuiControl,, NavigationTitle, 📂 Категории:
        IniRead, categories, %categoriesFile%, Categories, List, 
        if (categories != "") {
            Loop, Parse, categories, |
            {
                if (A_LoopField != "")
                    GuiControl,, CategoryList, %A_LoopField%
            }
        }
    } else if (navigationLevel = "subcategories") {
        ; Показываем подкатегории
        GuiControl,, NavigationTitle, 📁 Подкатегории [%currentCategory%]:
        IniRead, subcategories, %categoriesFile%, Category_%currentCategory%, Subcategories, 
        if (subcategories != "") {
            Loop, Parse, subcategories, |
            {
                if (A_LoopField != "")
                    GuiControl,, CategoryList, %A_LoopField%
            }
        }
    } else if (navigationLevel = "presets") {
        ; Показываем шаблоны
        GuiControl,, NavigationTitle, 📄 Шаблоны [%currentCategory% → %currentSubcategory%]:
        categoryPath := presetDir . "\" . currentCategory . "\" . currentSubcategory
        GuiControl,, CategoryList, |
        Loop, Files, %categoryPath%\*.txt
        {
            name := RegExReplace(A_LoopFileName, "\.txt$")
            GuiControl,, CategoryList, %name%
        }
    }
}

; Открыть категорию/подкатегорию/шаблон
LoadCategory:
    Gui, 1:Submit, NoHide
    global navigationLevel, currentCategory, currentSubcategory, presetDir
    
    if (CategoryList = "")
        return
    
    if (navigationLevel = "categories") {
        ; Переход в подкатегории
        currentCategory := CategoryList
        navigationLevel := "subcategories"
        LoadCategories()
    } else if (navigationLevel = "subcategories") {
        ; Переход в шаблоны
        currentSubcategory := CategoryList
        navigationLevel := "presets"
        LoadCategories()
    } else if (navigationLevel = "presets") {
        ; Загрузка шаблона
        filePath := presetDir . "\" . currentCategory . "\" . currentSubcategory . "\" . CategoryList . ".txt"
        if FileExist(filePath) {
            FileRead, loadedText, %filePath%
            GuiControl,, TypeText, %loadedText%
            SB_SetText("Шаблон загружен: " . CategoryList, 1)
        }
    }
return

; Вернуться в главное меню
BackToMenu:
    global navigationLevel, currentCategory, currentSubcategory
    
    if (navigationLevel = "presets") {
        navigationLevel := "subcategories"
        currentSubcategory := ""
    } else if (navigationLevel = "subcategories") {
        navigationLevel := "categories"
        currentCategory := ""
    }
    LoadCategories()
return

; Создать категорию
CreateCategory:
    global categoriesFile
    InputBox, newCategory, Создать категорию, Введите имя категории:
    if (ErrorLevel or newCategory = "")
        return
    
    ; Добавляем категорию в список
    IniRead, categories, %categoriesFile%, Categories, List, 
    if (categories = "" || categories = "ERROR")
        categories := newCategory
    else
        categories .= "|" . newCategory
    IniWrite, %categories%, %categoriesFile%, Categories, List
    
    ; Создаем папку для категории
    categoryPath := presetDir . "\" . newCategory
    if (!FileExist(categoryPath))
        FileCreateDir, %categoryPath%
    
    LoadCategories()
    SB_SetText("Категория создана: " . newCategory, 1)
return

; Создать подкатегорию
CreateSubcategory:
    global categoriesFile, navigationLevel, currentCategory, presetDir
    
    if (navigationLevel != "subcategories" && navigationLevel != "presets") {
        MsgBox, 48, Ошибка, Сначала откройте категорию!
        return
    }
    
    InputBox, newSubcategory, Создать подкатегорию, Введите имя подкатегории:
    if (ErrorLevel or newSubcategory = "")
        return
    
    ; Добавляем подкатегорию в список
    IniRead, subcategories, %categoriesFile%, Category_%currentCategory%, Subcategories, 
    if (subcategories = "" || subcategories = "ERROR")
        subcategories := newSubcategory
    else
        subcategories .= "|" . newSubcategory
    IniWrite, %subcategories%, %categoriesFile%, Category_%currentCategory%, Subcategories
    
    ; Создаем папку для подкатегории
    subcategoryPath := presetDir . "\" . currentCategory . "\" . newSubcategory
    if (!FileExist(subcategoryPath))
        FileCreateDir, %subcategoryPath%
    
    LoadCategories()
    SB_SetText("Подкатегория создана: " . newSubcategory, 1)
return

; Удалить категорию или подкатегорию (с GUI выбором)
DeleteCategoryOrSubcategory:
    global categoriesFile, presetDir
    
    ; Создаем GUI для выбора типа удаления
    Gui, DeleteCatDialog:New
    Gui, DeleteCatDialog:Font, s9, Segoe UI
    Gui, DeleteCatDialog:Add, Text, x10 y10, Что вы хотите удалить?
    Gui, DeleteCatDialog:Add, Radio, vDeleteType x10 y35 Checked gDeleteCatDialog_UpdateList, Категорию
    Gui, DeleteCatDialog:Add, Radio, x10 y60 gDeleteCatDialog_UpdateList, Подкатегорию
    Gui, DeleteCatDialog:Add, Text, x10 y90, Выберите для удаления:
    Gui, DeleteCatDialog:Add, ComboBox, vDeleteCatItem x10 y110 w360
    Gui, DeleteCatDialog:Add, Button, x10 y145 w175 gDeleteCatConfirm, ✓ Удалить
    Gui, DeleteCatDialog:Add, Button, x195 y145 w175 gDeleteCatCancel, ✗ Отмена
    
    ; Заполняем список категорий по умолчанию
    IniRead, categories, %categoriesFile%, Categories, List, 
    Loop, Parse, categories, |
    {
        if (A_LoopField != "")
            GuiControl, DeleteCatDialog:, DeleteCatItem, %A_LoopField%
    }
    
    Gui, DeleteCatDialog:Show, w380 h185, Удалить категорию/подкатегорию
return

DeleteCatDialog_UpdateList:
    Gui, DeleteCatDialog:Submit, NoHide
    global categoriesFile
    
    GuiControl, DeleteCatDialog:, DeleteCatItem, |
    
    if (DeleteType = 1) {
        ; Показываем категории
        IniRead, categories, %categoriesFile%, Categories, List, 
        Loop, Parse, categories, |
        {
            if (A_LoopField != "")
                GuiControl, DeleteCatDialog:, DeleteCatItem, %A_LoopField%
        }
    } else {
        ; Показываем подкатегории
        IniRead, allCategories, %categoriesFile%, Categories, List, 
        Loop, Parse, allCategories, |
        {
            if (A_LoopField = "")
                continue
            category := A_LoopField
            IniRead, subcategories, %categoriesFile%, Category_%category%, Subcategories, 
            Loop, Parse, subcategories, |
            {
                if (A_LoopField != "") {
                    subcatPath := category . " → " . A_LoopField
                    GuiControl, DeleteCatDialog:, DeleteCatItem, %subcatPath%
                }
            }
        }
    }
return

DeleteCatConfirm:
    Gui, DeleteCatDialog:Submit, NoHide
    global categoriesFile, presetDir
    
    if (DeleteCatItem = "") {
        MsgBox, 48, Ошибка, Выберите элемент для удаления!
        return
    }
    
    if (DeleteType = 1) {
        ; Удаление категории
        MsgBox, 4, Удалить?, Удалить категорию "%DeleteCatItem%" и всё её содержимое?
        IfMsgBox, Yes
        {
            ; Удаляем из списка
            IniRead, categories, %categoriesFile%, Categories, List, 
            categories := RegExReplace(categories, "\Q" . DeleteCatItem . "\E\|?", "")
            categories := RegExReplace(categories, "\|$", "")
            IniWrite, %categories%, %categoriesFile%, Categories, List
            
            ; Удаляем секцию
            IniDelete, %categoriesFile%, Category_%DeleteCatItem%
            
            ; Удаляем папку
            categoryPath := presetDir . "\" . DeleteCatItem
            FileRemoveDir, %categoryPath%, 1
            
            Gui, DeleteCatDialog:Destroy
            Gui, 1:Default
            LoadCategories()
            SB_SetText("Категория удалена: " . DeleteCatItem, 1)
        }
    } else {
        ; Удаление подкатегории
        MsgBox, 4, Удалить?, Удалить подкатегорию "%DeleteCatItem%" и всё её содержимое?
        IfMsgBox, Yes
        {
            ; Парсим путь
            parts := StrSplit(DeleteCatItem, "→")
            if (parts.Length() = 2) {
                category := Trim(parts[1])
                subcategory := Trim(parts[2])
                
                ; Удаляем из списка
                IniRead, subcategories, %categoriesFile%, Category_%category%, Subcategories, 
                subcategories := RegExReplace(subcategories, "\Q" . subcategory . "\E\|?", "")
                subcategories := RegExReplace(subcategories, "\|$", "")
                IniWrite, %subcategories%, %categoriesFile%, Category_%category%, Subcategories
                
                ; Удаляем папку
                subcategoryPath := presetDir . "\" . category . "\" . subcategory
                FileRemoveDir, %subcategoryPath%, 1
                
                Gui, DeleteCatDialog:Destroy
                Gui, 1:Default
                LoadCategories()
                SB_SetText("Подкатегория удалена: " . subcategory, 1)
            }
        }
    }
return

DeleteCatCancel:
    Gui, DeleteCatDialog:Destroy
    Gui, 1:Default
return

DeleteCatDialogGuiClose:
    Gui, DeleteCatDialog:Destroy
    Gui, 1:Default
return

; Удалить шаблон (с GUI выбором)
DeleteTemplate:
    global categoriesFile, presetDir
    
    ; Создаем GUI для выбора шаблона
    Gui, DeleteTplDialog:New
    Gui, DeleteTplDialog:Font, s9, Segoe UI
    Gui, DeleteTplDialog:Add, Text, x10 y10, Выберите шаблон для удаления:
    Gui, DeleteTplDialog:Add, ComboBox, vDeleteTplItem x10 y30 w360
    Gui, DeleteTplDialog:Add, Button, x10 y65 w175 gDeleteTplConfirm, ✓ Удалить
    Gui, DeleteTplDialog:Add, Button, x195 y65 w175 gDeleteTplCancel, ✗ Отмена
    
    ; Заполняем список всех шаблонов
    IniRead, allCategories, %categoriesFile%, Categories, List, 
    
    Loop, Parse, allCategories, |
    {
        if (A_LoopField = "")
            continue
        category := A_LoopField
        IniRead, subcategories, %categoriesFile%, Category_%category%, Subcategories, 
        Loop, Parse, subcategories, |
        {
            if (A_LoopField = "")
                continue
            subcategory := A_LoopField
            templatePath := presetDir . "\" . category . "\" . subcategory
            Loop, Files, %templatePath%\*.txt
            {
                templateName := RegExReplace(A_LoopFileName, "\.txt$")
                fullPath := category . " → " . subcategory . " → " . templateName
                GuiControl, DeleteTplDialog:, DeleteTplItem, %fullPath%
            }
        }
    }
    
    Gui, DeleteTplDialog:Show, w380 h105, Удалить шаблон
return

DeleteTplConfirm:
    Gui, DeleteTplDialog:Submit, NoHide
    global presetDir
    
    if (DeleteTplItem = "") {
        MsgBox, 48, Ошибка, Выберите шаблон для удаления!
        return
    }
    
    MsgBox, 4, Удалить?, Удалить шаблон "%DeleteTplItem%"?
    IfMsgBox, Yes
    {
        ; Парсим путь
        parts := StrSplit(DeleteTplItem, "→")
        if (parts.Length() = 3) {
            category := Trim(parts[1])
            subcategory := Trim(parts[2])
            templateName := Trim(parts[3])
            
            filePath := presetDir . "\" . category . "\" . subcategory . "\" . templateName . ".txt"
            FileDelete, %filePath%
            
            Gui, DeleteTplDialog:Destroy
            Gui, 1:Default
            GuiControl,, TypeText,
            LoadCategories()
            SB_SetText("Шаблон удален: " . templateName, 1)
        }
    }
return

DeleteTplCancel:
    Gui, DeleteTplDialog:Destroy
    Gui, 1:Default
return

DeleteTplDialogGuiClose:
    Gui, DeleteTplDialog:Destroy
    Gui, 1:Default
return

; Переместить шаблон
MovePreset:
    Gui, 1:Submit, NoHide
    global navigationLevel, currentCategory, currentSubcategory, categoriesFile, presetDir
    
    if (navigationLevel != "presets") {
        MsgBox, 48, Ошибка, Откройте раздел с шаблонами!
        return
    }
    
    if (CategoryList = "") {
        MsgBox, 48, Ошибка, Выберите шаблон для перемещения!
        return
    }
    
    ; Сохраняем имя выбранного шаблона
    selectedPreset := CategoryList
    
    ; Создаем GUI для выбора целевой подкатегории
    Gui, MoveDialog:New
    Gui, MoveDialog:Font, s9, Segoe UI
    Gui, MoveDialog:Add, Text, x10 y10, Переместить шаблон "%selectedPreset%" в:
    Gui, MoveDialog:Add, Text, x10 y35, Выберите подкатегорию:
    Gui, MoveDialog:Add, ComboBox, vMoveTargetSubcategory x10 y55 w380
    Gui, MoveDialog:Add, Button, x10 y90 w185 gMovePresetConfirm, ✓ Переместить
    Gui, MoveDialog:Add, Button, x205 y90 w185 gMovePresetCancel, ✗ Отмена
    
    ; Заполняем список подкатегорий
    IniRead, allCategories, %categoriesFile%, Categories, List, 
    
    Loop, Parse, allCategories, |
    {
        if (A_LoopField = "")
            continue
        category := A_LoopField
        IniRead, subcategories, %categoriesFile%, Category_%category%, Subcategories, 
        Loop, Parse, subcategories, |
        {
            if (A_LoopField != "") {
                ; Пропускаем текущую подкатегорию
                if (category = currentCategory && A_LoopField = currentSubcategory)
                    continue
                GuiControl, MoveDialog:, MoveTargetSubcategory, % category . " → " . A_LoopField
            }
        }
    }
    
    Gui, MoveDialog:Show, w400 h130, Переместить шаблон
return

MovePresetConfirm:
    Gui, MoveDialog:Submit, NoHide
    global selectedPreset, currentCategory, currentSubcategory, categoriesFile, presetDir
    
    if (MoveTargetSubcategory = "") {
        MsgBox, 48, Ошибка, Выберите целевую подкатегорию!
        return
    }
    
    ; Парсим путь
    targetParts := StrSplit(MoveTargetSubcategory, "→")
    if (targetParts.Length() != 2) {
        MsgBox, 16, Ошибка, Неверный формат пути!
        return
    }
    
    targetCategory := Trim(targetParts[1])
    targetSubcategory := Trim(targetParts[2])
    
    ; Перемещаем файл
    sourcePath := presetDir . "\" . currentCategory . "\" . currentSubcategory . "\" . selectedPreset . ".txt"
    targetDir := presetDir . "\" . targetCategory . "\" . targetSubcategory
    targetPath := targetDir . "\" . selectedPreset . ".txt"
    
    if (!FileExist(targetDir))
        FileCreateDir, %targetDir%
    
    FileCopy, %sourcePath%, %targetPath%, 1
    FileDelete, %sourcePath%
    
    Gui, MoveDialog:Destroy
    Gui, 1:Default
    LoadCategories()
    SB_SetText("Шаблон перемещен: " . selectedPreset, 1)
return

MovePresetCancel:
    Gui, MoveDialog:Destroy
    Gui, 1:Default
return

MoveDialogGuiClose:
    Gui, MoveDialog:Destroy
    Gui, 1:Default
return

; === ФУНКЦИИ УПРАВЛЕНИЯ ВСТАВКАМИ ТЕКСТА ===

; Добавить вставку
AddInsert:
    Gui, InsertDialog:New, +Owner1
    Gui, InsertDialog:Font, s10, Segoe UI
    Gui, InsertDialog:Color, White
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; 📝 ЗАГОЛОВОК
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, InsertDialog:Add, Text, x15 y10 w470 h30 c0066CC Center, ➕ ДОБАВИТЬ ВСТАВКУ
    Gui, InsertDialog:Font, s9, Segoe UI
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; 📄 ТЕКСТ ВСТАВКИ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, InsertDialog:Add, GroupBox, x10 y40 w480 h100, 📄 Текст для вставки
    Gui, InsertDialog:Add, Edit, vInsertText x20 y60 w460 h70 Multi
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; 📍 ПОЗИЦИЯ ВСТАВКИ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, InsertDialog:Add, GroupBox, x10 y145 w480 h90, 📍 Позиция вставки
    Gui, InsertDialog:Add, DropDownList, vInsertPosition x20 y165 w300 gCheckCustomNWords, Перед 1 слова|Перед 2 слов|Перед 3 слов|Перед 4 слов|Перед 5 слов|Перед N слов|Перед N слов с конца|Перед слова|ТОЛЬКО перед слова|После 1 слова|После 2 слов|После 3 слов|После 4 слов|После 5 слов|После N слов|После N слов с конца|После слова|ТОЛЬКО после слова|В начале после N слов|В середине после N слов|В конце после N слов|В начале перед N слов|В середине перед N слов|В конце перед N слов|Поочерёдно|Случайно|В начале|В середине|В конце
    Gui, InsertDialog:Add, Text, x330 y168, N:
    Gui, InsertDialog:Add, Edit, vInsertNWords x350 y165 w60 Number Hidden, 6
    Gui, InsertDialog:Add, Text, vInsertTargetLabel x20 y195 Hidden, Целевое слово:
    Gui, InsertDialog:Add, Edit, vInsertTargetWord x120 y192 w290 Hidden
    Gui, InsertDialog:Add, Text, x420 y168, раз:
    Gui, InsertDialog:Add, Edit, vInsertRepeatN x450 y165 w40 Number, 1
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ⌨️ БИНД (С ЗАХВАТОМ КЛАВИШ)
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, InsertDialog:Add, GroupBox, x10 y240 w235 h80, ⌨️ Горячая клавиша
    Gui, InsertDialog:Add, Edit, vInsertHotkey x20 y260 w140 ReadOnly
    Gui, InsertDialog:Add, Button, vInsertCaptureBtn x165 y258 w70 h24 gCaptureInsertHotkey, 🎯 Захват
    Gui, InsertDialog:Add, Text, x20 y290 cGray, Нажмите "Захват" и клавишу
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ⚙️ ДОПОЛНИТЕЛЬНО
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, InsertDialog:Add, GroupBox, x255 y240 w235 h80, ⚙️ Дополнительно
    Gui, InsertDialog:Add, Checkbox, vInsertApplyErrors x265 y260 Checked, Применять ошибки
    Gui, InsertDialog:Add, Text, x265 y285, Игнор. слова:
    Gui, InsertDialog:Add, Edit, vInsertIgnoreWords x350 y282 w130 h20
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; 🔄 ВАРИАЦИИ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, InsertDialog:Add, GroupBox, vInsertVariationsGroupBox x10 y325 w480 h170, 🔄 Вариации текста
    Gui, InsertDialog:Add, ListView, vInsertVariationsList x20 y345 w380 h100, №|Вариация
    LV_ModifyCol(1, 30)
    LV_ModifyCol(2, 340)
    Gui, InsertDialog:Add, Button, vInsertAddVariation x410 y345 w70 h25 gAddInsertVariation, ➕ Добав.
    Gui, InsertDialog:Add, Button, vInsertDeleteVariation x410 y375 w70 h25 gDeleteInsertVariation, ❌ Удал.
    Gui, InsertDialog:Add, Button, vInsertEditVariation x410 y405 w70 h25 gEditInsertVariation, ✏️ Ред.
    Gui, InsertDialog:Add, Text, vInsertVariationStartLabel x20 y455, Начать с:
    Gui, InsertDialog:Add, DropDownList, vInsertVariationStartPosition x90 y452 w150, С начала|С середины|С конца|Случайно
    Gui, InsertDialog:Add, Checkbox, vInsertVariationRandom x260 y455, 🎲 Случайный выбор
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; 🔘 КНОПКИ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, InsertDialog:Add, Button, x10 y505 w155 h35 gInsertDialogOK, ✓ Добавить вставку
    Gui, InsertDialog:Add, Button, x175 y505 w155 h35 gOpenInsertRulesEditor, 📋 Правила
    Gui, InsertDialog:Add, Button, x340 y505 w150 h35 gInsertDialogCancel, ✗ Отмена
    
    Gui, InsertDialog:Show, w500 h555, ➕ Добавить вставку
return

CheckCustomNWords:
    Gui, InsertDialog:Submit, NoHide
    ; Показываем поле для ввода N, если выбрана любая позиция, содержащая 'N слов'
    if InStr(InsertPosition, "N слов")
        GuiControl, InsertDialog:Show, InsertNWords
    else
        GuiControl, InsertDialog:Hide, InsertNWords

    ; Показываем поле для ввода целевого слова, если выбрана позиция типа '... слова' или 'ТОЛЬКО ...'
    if (InStr(InsertPosition, "слова") || InStr(InsertPosition, "ТОЛЬКО")) {
        GuiControl, InsertDialog:Show, InsertTargetLabel
        GuiControl, InsertDialog:Show, InsertTargetWord
    } else {
        GuiControl, InsertDialog:Hide, InsertTargetLabel
        GuiControl, InsertDialog:Hide, InsertTargetWord
    }
return

InsertDialogOK:
    Gui, InsertDialog:Submit
    global customInserts, insertCount, insertRepeatCount
    
    ; Сохраняем N-раз вставки
    insertRepeatCount := InsertRepeatN > 0 ? InsertRepeatN : 1
    
    if (InsertText = "") {
        MsgBox, 48, Ошибка, Введите текст для вставки!
        return
    }
    
    if (InsertPosition = "") {
        MsgBox, 48, Ошибка, Выберите позицию вставки!
        return
    }
    
    finalPosition := InsertPosition
    ; Заменяем маркер N на введённое число если нужно
    if InStr(InsertPosition, "N слов") {
        if (InsertNWords = "" || InsertNWords <= 0) {
            MsgBox, 48, Ошибка, Укажите количество слов!
            return
        }
        StringReplace, finalPosition, finalPosition, N, %InsertNWords%, All
    }
    ; Обрабатываем позиции типа 'Перед слова' / 'После слова' / 'ТОЛЬКО перед слова' / 'ТОЛЬКО после слова'
    if (InStr(InsertPosition, "слова") || InStr(InsertPosition, "ТОЛЬКО")) {
        if (InsertTargetWord = "") {
            MsgBox, 48, Ошибка, Укажите целевое слово для вставки!
            return
        }
        ; Сохраняем позицию вместе с целевым словом
        finalPosition := InsertPosition . " " . Trim(InsertTargetWord)
    }
    
    ; Собираем вариации из ListView
    variations := []
    variationStartPosition := "С начала"
    Gui, InsertDialog:Default
    Gui, ListView, InsertVariationsList
    rowCount := LV_GetCount()
    Loop, %rowCount% {
        LV_GetText(variationText, A_Index, 1)
        if (variationText != "")
            variations.Push(variationText)
    }
    Gui, InsertDialog:Submit, NoHide
    variationStartPosition := InsertVariationStartPosition
    
    ; Добавляем вставку в массив
    insertObj := {}
    insertObj.text := InsertText
    insertObj.position := finalPosition
    insertObj.ignoreWords := InsertIgnoreWords
    insertObj.hotkey := InsertHotkey
    insertObj.enabled := 1
    insertObj.applyErrors := InsertApplyErrors ? 1 : 0
    insertObj.variations := variations
    insertObj.variationStartPosition := variationStartPosition
    customInserts.Push(insertObj)
    idx := customInserts.Length()
    ; Регистрируем хоткей если указан
    if (InsertHotkey != "")
        RegisterInsertHotkey(InsertHotkey, idx)
    insertCount++
    
    Gui, InsertDialog:Destroy
    Gui, 1:Default
    UpdateInsertsList()
    SaveInserts()
return

InsertDialogCancel:
    Gui, InsertDialog:Destroy
    Gui, 1:Default
return

InsertDialogGuiClose:
    Gui, InsertDialog:Destroy
    Gui, 1:Default
return

; === ВИЗУАЛЬНЫЙ РЕДАКТОР ПРАВИЛ ВСТАВКИ СЛОВ ===

OpenInsertRulesEditor:
    Gui, InsertRulesEditor:New, +Resize +MinSize900x600
    Gui, InsertRulesEditor:Font, s10 Bold, Segoe UI
    Gui, InsertRulesEditor:Color, White
    
    ; Заголовок
    Gui, InsertRulesEditor:Add, Text, x10 y10 w880 h30 c0066CC Center, 📋 ВИЗУАЛЬНЫЙ РЕДАКТОР ПРАВИЛ ВСТАВКИ СЛОВ
    Gui, InsertRulesEditor:Font, s9 Normal, Segoe UI
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ЛЕВАЯ ПАНЕЛЬ - СПИСОК ПРАВИЛ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, InsertRulesEditor:Add, GroupBox, x10 y50 w350 h500, 📜 Список правил
    Gui, InsertRulesEditor:Add, ListView, vInsertRulesList x20 y70 w330 h380 gInsertRuleSelected AltSubmit Checked, Правило|Тип|Статус
    LV_ModifyCol(1, 180)
    LV_ModifyCol(2, 80)
    LV_ModifyCol(3, 60)
    
    ; Кнопки управления правилами
    Gui, InsertRulesEditor:Add, Button, x20 y460 w100 h25 gAddInsertRule, ➕ Добавить
    Gui, InsertRulesEditor:Add, Button, x130 y460 w100 h25 gEditInsertRule, ✏️ Изменить
    Gui, InsertRulesEditor:Add, Button, x240 y460 w110 h25 gDeleteInsertRule, ❌ Удалить
    Gui, InsertRulesEditor:Add, Button, x20 y490 w165 h25 gDuplicateInsertRule, 📋 Дублировать
    Gui, InsertRulesEditor:Add, Button, x195 y490 w155 h25 gClearInsertRules, 🗑️ Очистить всё
    Gui, InsertRulesEditor:Add, Button, x20 y520 w165 h25 gLoadInsertRulesPreset, 📂 Загрузить
    Gui, InsertRulesEditor:Add, Button, x195 y520 w155 h25 gSaveInsertRulesPreset, 💾 Сохранить
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ПРАВАЯ ПАНЕЛЬ - НАСТРОЙКИ ПРАВИЛА
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, InsertRulesEditor:Add, GroupBox, x370 y50 w520 h500, ⚙️ Настройки правила
    
    ; Название правила
    Gui, InsertRulesEditor:Add, Text, x380 y70, Название правила:
    Gui, InsertRulesEditor:Add, Edit, vInsertRuleName x380 y90 w500 h25
    
    ; Тип правила
    Gui, InsertRulesEditor:Add, Text, x380 y125, Тип правила:
    Gui, InsertRulesEditor:Add, DropDownList, vInsertRuleType x380 y145 w500 gInsertRuleTypeChanged, Вставка перед словом|Вставка после слова|Вставка перед каждым N-словом|Вставка после каждого N-слова|Вставка в начало текста|Вставка в конец текста|Вставка в середину текста|Вставка перед словами из списка|Вставка после слов из списка|Вставка перед длинными словами|Вставка после длинных слов|Вставка перед короткими словами|Вставка после коротких слов|Вставка перед заглавными словами|Вставка после заглавных слов|Вставка перед словами с цифрами|Вставка после слов с цифрами|Вставка перед словами с символами|Вставка после слов с символами|Вставка случайно (N раз)|Вставка поочерёдно|Вставка по шаблону|Вставка по регулярному выражению|Вставка перед словами определённой длины|Вставка после слов определённой длины|Вставка перед гласными|Вставка после гласных|Вставка перед согласными|Вставка после согласных|Вставка перед словами на букву|Вставка после слов на букву|Вставка перед словами заканчивающимися на|Вставка после слов заканчивающихся на|Вставка перед словами содержащими|Вставка после слов содержащих|Вставка через N слов|Вставка в каждое N-предложение|Вставка перед знаками препинания|Вставка после знаков препинания|Вставка перед числами|Вставка после чисел|Вставка перед URL|Вставка после URL|Вставка перед email|Вставка после email|Вставка перед хештегами|Вставка после хештегов|Вставка перед упоминаниями|Вставка после упоминаний|Вставка в начало каждой строки|Вставка в конец каждой строки|Вставка перед словами из категории|Вставка после слов из категории
    
    ; Текст для вставки
    Gui, InsertRulesEditor:Add, Text, x380 y180, Текст для вставки:
    Gui, InsertRulesEditor:Add, Edit, vInsertRuleText x380 y200 w500 h60 Multi
    
    ; Параметры правила (динамические)
    Gui, InsertRulesEditor:Add, GroupBox, vInsertRuleParamsBox x380 y270 w500 h150, 🔧 Параметры правила
    
    ; Параметр 1 (универсальный)
    Gui, InsertRulesEditor:Add, Text, vInsertRuleParam1Label x390 y290 Hidden, Параметр 1:
    Gui, InsertRulesEditor:Add, Edit, vInsertRuleParam1 x390 y310 w480 h25 Hidden
    
    ; Параметр 2 (универсальный)
    Gui, InsertRulesEditor:Add, Text, vInsertRuleParam2Label x390 y345 Hidden, Параметр 2:
    Gui, InsertRulesEditor:Add, Edit, vInsertRuleParam2 x390 y365 w480 h25 Hidden
    
    ; Параметр 3 (чекбокс)
    Gui, InsertRulesEditor:Add, Checkbox, vInsertRuleParam3 x390 y395 Hidden, Параметр 3
    
    ; Дополнительные настройки
    Gui, InsertRulesEditor:Add, GroupBox, x380 y430 w500 h110, 🎯 Дополнительные настройки
    Gui, InsertRulesEditor:Add, Checkbox, vInsertRuleEnabled x390 y450 Checked, ✓ Правило включено
    Gui, InsertRulesEditor:Add, Text, x390 y475, Вероятность срабатывания:
    Gui, InsertRulesEditor:Add, Slider, vInsertRuleProbability x390 y495 w350 Range0-100 TickInterval10 ToolTip gInsertRuleProbabilityChanged, 100
    Gui, InsertRulesEditor:Add, Edit, vInsertRuleProbabilityInput x750 y492 w50 Number, 100
    Gui, InsertRulesEditor:Add, Text, x810 y495, `%
    Gui, InsertRulesEditor:Add, Checkbox, vInsertRuleApplyErrors x390 y520, Применять ошибки к вставке
    
    ; Кнопки
    Gui, InsertRulesEditor:Add, Button, x370 y560 w250 h30 gSaveInsertRuleChanges, ✓ Сохранить изменения
    Gui, InsertRulesEditor:Add, Button, x630 y560 w260 h30 gCloseInsertRulesEditor, ✗ Закрыть редактор
    
    ; Загружаем правила в список
    UpdateInsertRulesList()
    
    Gui, InsertRulesEditor:Show, w900 h600, 📋 Визуальный редактор правил вставки слов
return

; Обновить список правил
UpdateInsertRulesList() {
    global insertRules
    Gui, InsertRulesEditor:Default
    Gui, ListView, InsertRulesList
    LV_Delete()
    
    for i, rule in insertRules {
        status := rule.enabled ? "✓" : "✗"
        LV_Add(rule.enabled ? "Check" : "", rule.name, rule.type, status)
    }
}

; Выбрано правило из списка
InsertRuleSelected:
    if (A_GuiEvent = "Normal" || A_GuiEvent = "DoubleClick") {
        Gui, InsertRulesEditor:Default
        Gui, ListView, InsertRulesList
        selectedRow := LV_GetNext(0)
        
        if (selectedRow > 0) {
            global insertRules
            rule := insertRules[selectedRow]
            
            ; Заполняем поля
            GuiControl, InsertRulesEditor:, InsertRuleName, % rule.name
            GuiControl, InsertRulesEditor:ChooseString, InsertRuleType, % rule.type
            GuiControl, InsertRulesEditor:, InsertRuleText, % rule.text
            GuiControl, InsertRulesEditor:, InsertRuleParam1, % rule.param1
            GuiControl, InsertRulesEditor:, InsertRuleParam2, % rule.param2
            GuiControl, InsertRulesEditor:, InsertRuleParam3, % rule.param3
            GuiControl, InsertRulesEditor:, InsertRuleEnabled, % rule.enabled
            GuiControl, InsertRulesEditor:, InsertRuleProbability, % rule.probability
            GuiControl, InsertRulesEditor:, InsertRuleProbabilityInput, % rule.probability
            GuiControl, InsertRulesEditor:, InsertRuleApplyErrors, % rule.applyErrors
            
            ; Обновляем видимость параметров
            Gosub, InsertRuleTypeChanged
        }
    }
    else if (A_GuiEvent = "I") {
        ; Изменение чекбокса
        Gui, InsertRulesEditor:Default
        Gui, ListView, InsertRulesList
        rowNumber := A_EventInfo
        
        if (rowNumber > 0) {
            global insertRules
            isChecked := LV_GetNext(rowNumber - 1, "Checked") = rowNumber
            insertRules[rowNumber].enabled := isChecked
            
            ; Обновляем статус в списке
            LV_GetText(ruleName, rowNumber, 1)
            LV_Modify(rowNumber, "", ruleName, insertRules[rowNumber].type, isChecked ? "✓" : "✗")
        }
    }
return

; Изменен тип правила
InsertRuleTypeChanged:
    Gui, InsertRulesEditor:Submit, NoHide
    
    ; Скрываем все параметры
    GuiControl, InsertRulesEditor:Hide, InsertRuleParam1Label
    GuiControl, InsertRulesEditor:Hide, InsertRuleParam1
    GuiControl, InsertRulesEditor:Hide, InsertRuleParam2Label
    GuiControl, InsertRulesEditor:Hide, InsertRuleParam2
    GuiControl, InsertRulesEditor:Hide, InsertRuleParam3
    
    ; Показываем нужные параметры в зависимости от типа
    if (InsertRuleType = "Вставка перед словом" || InsertRuleType = "Вставка после слова") {
        GuiControl, InsertRulesEditor:, InsertRuleParam1Label, Целевое слово:
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1Label
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1
    }
    else if (InsertRuleType = "Вставка перед каждым N-словом" || InsertRuleType = "Вставка после каждого N-слова" || InsertRuleType = "Вставка через N слов") {
        GuiControl, InsertRulesEditor:, InsertRuleParam1Label, Каждое N-слово:
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1Label
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1
    }
    else if (InsertRuleType = "Вставка перед словами из списка" || InsertRuleType = "Вставка после слов из списка") {
        GuiControl, InsertRulesEditor:, InsertRuleParam1Label, Список слов (через запятую):
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1Label
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1
    }
    else if (InsertRuleType = "Вставка перед длинными словами" || InsertRuleType = "Вставка после длинных слов" || InsertRuleType = "Вставка перед короткими словами" || InsertRuleType = "Вставка после коротких слов") {
        GuiControl, InsertRulesEditor:, InsertRuleParam1Label, Минимальная длина слова:
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1Label
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1
    }
    else if (InsertRuleType = "Вставка случайно (N раз)") {
        GuiControl, InsertRulesEditor:, InsertRuleParam1Label, Количество вставок:
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1Label
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1
    }
    else if (InsertRuleType = "Вставка по регулярному выражению") {
        GuiControl, InsertRulesEditor:, InsertRuleParam1Label, Регулярное выражение:
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1Label
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1
    }
    else if (InsertRuleType = "Вставка перед словами определённой длины" || InsertRuleType = "Вставка после слов определённой длины") {
        GuiControl, InsertRulesEditor:, InsertRuleParam1Label, Длина слова:
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1Label
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1
    }
    else if (InsertRuleType = "Вставка перед словами на букву" || InsertRuleType = "Вставка после слов на букву") {
        GuiControl, InsertRulesEditor:, InsertRuleParam1Label, Начальная буква:
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1Label
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1
    }
    else if (InsertRuleType = "Вставка перед словами заканчивающимися на" || InsertRuleType = "Вставка после слов заканчивающихся на") {
        GuiControl, InsertRulesEditor:, InsertRuleParam1Label, Конечная буква/слог:
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1Label
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1
    }
    else if (InsertRuleType = "Вставка перед словами содержащими" || InsertRuleType = "Вставка после слов содержащих") {
        GuiControl, InsertRulesEditor:, InsertRuleParam1Label, Подстрока:
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1Label
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1
    }
    else if (InsertRuleType = "Вставка в каждое N-предложение") {
        GuiControl, InsertRulesEditor:, InsertRuleParam1Label, Каждое N-предложение:
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1Label
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1
    }
    else if (InsertRuleType = "Вставка перед словами из категории" || InsertRuleType = "Вставка после слов из категории") {
        GuiControl, InsertRulesEditor:, InsertRuleParam1Label, Категория (существительные/глаголы/прилагательные):
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1Label
        GuiControl, InsertRulesEditor:Show, InsertRuleParam1
    }
return

; Обработчик изменения слайдера вероятности
InsertRuleProbabilityChanged:
    GuiControlGet, probValue, InsertRulesEditor:, InsertRuleProbability
    GuiControl, InsertRulesEditor:, InsertRuleProbabilityInput, %probValue%
return

; Добавить новое правило
AddInsertRule:
    global insertRules
    
    ; Создаём новое правило с дефолтными значениями
    newRule := {name: "Новое правило " . (insertRules.Length() + 1), type: "Вставка перед словом", text: "", param1: "", param2: "", param3: 0, enabled: true, probability: 100, applyErrors: false}
    insertRules.Push(newRule)
    
    UpdateInsertRulesList()
    
    ; Выбираем новое правило
    Gui, InsertRulesEditor:Default
    Gui, ListView, InsertRulesList
    LV_Modify(insertRules.Length(), "Select Focus Vis")
    
    ; Заполняем поля
    GuiControl, InsertRulesEditor:, InsertRuleName, % newRule.name
    GuiControl, InsertRulesEditor:ChooseString, InsertRuleType, % newRule.type
    GuiControl, InsertRulesEditor:, InsertRuleText, % newRule.text
    GuiControl, InsertRulesEditor:, InsertRuleParam1, % newRule.param1
    GuiControl, InsertRulesEditor:, InsertRuleParam2, % newRule.param2
    GuiControl, InsertRulesEditor:, InsertRuleParam3, % newRule.param3
    GuiControl, InsertRulesEditor:, InsertRuleEnabled, % newRule.enabled
    GuiControl, InsertRulesEditor:, InsertRuleProbability, % newRule.probability
    GuiControl, InsertRulesEditor:, InsertRuleProbabilityInput, % newRule.probability
    GuiControl, InsertRulesEditor:, InsertRuleApplyErrors, % newRule.applyErrors
    
    Gosub, InsertRuleTypeChanged
return

; Изменить правило
EditInsertRule:
    Gui, InsertRulesEditor:Default
    Gui, ListView, InsertRulesList
    selectedRow := LV_GetNext(0)
    
    if (selectedRow = 0) {
        MsgBox, 48, Ошибка, Выберите правило для редактирования!
        return
    }
    
    ; Правило уже загружено в поля, просто фокусируемся на имени
    GuiControl, InsertRulesEditor:Focus, InsertRuleName
return

; Удалить правило
DeleteInsertRule:
    Gui, InsertRulesEditor:Default
    Gui, ListView, InsertRulesList
    selectedRow := LV_GetNext(0)
    
    if (selectedRow = 0) {
        MsgBox, 48, Ошибка, Выберите правило для удаления!
        return
    }
    
    global insertRules
    LV_GetText(ruleName, selectedRow, 1)
    
    MsgBox, 4, Подтверждение, Удалить правило "%ruleName%"?
    IfMsgBox, Yes
    {
        insertRules.RemoveAt(selectedRow)
        UpdateInsertRulesList()
        
        ; Очищаем поля
        GuiControl, InsertRulesEditor:, InsertRuleName,
        GuiControl, InsertRulesEditor:, InsertRuleText,
        GuiControl, InsertRulesEditor:, InsertRuleParam1,
        GuiControl, InsertRulesEditor:, InsertRuleParam2,
        GuiControl, InsertRulesEditor:, InsertRuleParam3, 0
    }
return

; Дублировать правило
DuplicateInsertRule:
    Gui, InsertRulesEditor:Default
    Gui, ListView, InsertRulesList
    selectedRow := LV_GetNext(0)
    
    if (selectedRow = 0) {
        MsgBox, 48, Ошибка, Выберите правило для дублирования!
        return
    }
    
    global insertRules
    originalRule := insertRules[selectedRow]
    
    ; Создаём копию правила
    newRule := {name: originalRule.name . " (копия)", type: originalRule.type, text: originalRule.text, param1: originalRule.param1, param2: originalRule.param2, param3: originalRule.param3, enabled: originalRule.enabled, probability: originalRule.probability, applyErrors: originalRule.applyErrors}
    insertRules.Push(newRule)
    
    UpdateInsertRulesList()
    
    ; Выбираем новое правило
    LV_Modify(insertRules.Length(), "Select Focus Vis")
return

; Очистить все правила
ClearInsertRules:
    MsgBox, 4, Подтверждение, Удалить все правила?
    IfMsgBox, Yes
    {
        global insertRules
        insertRules := []
        UpdateInsertRulesList()
        
        ; Очищаем поля
        GuiControl, InsertRulesEditor:, InsertRuleName,
        GuiControl, InsertRulesEditor:, InsertRuleText,
        GuiControl, InsertRulesEditor:, InsertRuleParam1,
        GuiControl, InsertRulesEditor:, InsertRuleParam2,
        GuiControl, InsertRulesEditor:, InsertRuleParam3, 0
    }
return

; Сохранить изменения правила
SaveInsertRuleChanges:
    Gui, InsertRulesEditor:Submit, NoHide
    Gui, InsertRulesEditor:Default
    Gui, ListView, InsertRulesList
    selectedRow := LV_GetNext(0)
    
    if (selectedRow = 0) {
        MsgBox, 48, Ошибка, Выберите правило для сохранения изменений!
        return
    }
    
    if (InsertRuleName = "") {
        MsgBox, 48, Ошибка, Введите название правила!
        return
    }
    
    if (InsertRuleText = "") {
        MsgBox, 48, Ошибка, Введите текст для вставки!
        return
    }
    
    global insertRules
    
    ; Обновляем правило
    insertRules[selectedRow].name := InsertRuleName
    insertRules[selectedRow].type := InsertRuleType
    insertRules[selectedRow].text := InsertRuleText
    insertRules[selectedRow].param1 := InsertRuleParam1
    insertRules[selectedRow].param2 := InsertRuleParam2
    insertRules[selectedRow].param3 := InsertRuleParam3
    insertRules[selectedRow].enabled := InsertRuleEnabled
    insertRules[selectedRow].probability := InsertRuleProbabilityInput
    insertRules[selectedRow].applyErrors := InsertRuleApplyErrors
    
    UpdateInsertRulesList()
    
    ; Восстанавливаем выделение
    LV_Modify(selectedRow, "Select Focus Vis")
    
    MsgBox, 64, Успех, Изменения сохранены!
return

; Загрузить пресет правил
LoadInsertRulesPreset:
    global appDataDir, insertRules
    presetDir := appDataDir . "\insert_rules_presets"
    
    if (!FileExist(presetDir))
        FileCreateDir, %presetDir%
    
    FileSelectFile, selectedFile, 1, %presetDir%, Выберите пресет правил, INI Files (*.ini)
    
    if (ErrorLevel || selectedFile = "")
        return
    
    ; Загружаем правила из файла
    IniRead, ruleCount, %selectedFile%, Rules, Count, 0
    
    if (ruleCount = 0) {
        MsgBox, 48, Ошибка, Пресет пуст или повреждён!
        return
    }
    
    insertRules := []
    
    Loop, %ruleCount% {
        section := "Rule" . A_Index
        IniRead, name, %selectedFile%, %section%, Name, Правило %A_Index%
        IniRead, type, %selectedFile%, %section%, Type, Вставка перед словом
        IniRead, text, %selectedFile%, %section%, Text,
        IniRead, param1, %selectedFile%, %section%, Param1, EMPTY
        IniRead, param2, %selectedFile%, %section%, Param2, EMPTY
        IniRead, param3, %selectedFile%, %section%, Param3, 0
        IniRead, enabled, %selectedFile%, %section%, Enabled, 1
        IniRead, probability, %selectedFile%, %section%, Probability, 100
        IniRead, applyErrors, %selectedFile%, %section%, ApplyErrors, 0
        
        ; Заменяем маркер EMPTY на пустую строку
        if (param1 = "EMPTY")
            param1 := ""
        if (param2 = "EMPTY")
            param2 := ""
        
        insertRules.Push({name: name, type: type, text: text, param1: param1, param2: param2, param3: param3, enabled: enabled, probability: probability, applyErrors: applyErrors})
    }
    
    UpdateInsertRulesList()
    MsgBox, 64, Успех, Пресет загружен! Загружено правил: %ruleCount%
return

; Сохранить пресет правил
SaveInsertRulesPreset:
    global appDataDir, insertRules
    presetDir := appDataDir . "\insert_rules_presets"
    
    if (!FileExist(presetDir))
        FileCreateDir, %presetDir%
    
    InputBox, presetName, Сохранить пресет, Введите название пресета:
    
    if (ErrorLevel || presetName = "")
        return
    
    presetFile := presetDir . "\" . presetName . ".ini"
    
    ; Удаляем старый файл если существует
    if (FileExist(presetFile))
        FileDelete, %presetFile%
    
    ; Сохраняем правила
    IniWrite, % insertRules.Length(), %presetFile%, Rules, Count
    
    for i, rule in insertRules {
        section := "Rule" . i
        IniWrite, % rule.name, %presetFile%, %section%, Name
        IniWrite, % rule.type, %presetFile%, %section%, Type
        IniWrite, % rule.text, %presetFile%, %section%, Text
        
        ; Заменяем пустые значения на маркер EMPTY
        param1Value := rule.param1 = "" ? "EMPTY" : rule.param1
        param2Value := rule.param2 = "" ? "EMPTY" : rule.param2
        
        IniWrite, %param1Value%, %presetFile%, %section%, Param1
        IniWrite, %param2Value%, %presetFile%, %section%, Param2
        IniWrite, % rule.param3, %presetFile%, %section%, Param3
        IniWrite, % rule.enabled, %presetFile%, %section%, Enabled
        IniWrite, % rule.probability, %presetFile%, %section%, Probability
        IniWrite, % rule.applyErrors, %presetFile%, %section%, ApplyErrors
    }
    
    MsgBox, 64, Успех, Пресет сохранён: %presetName%
return

; Закрыть редактор правил
CloseInsertRulesEditor:
InsertRulesEditorGuiClose:
    Gui, InsertRulesEditor:Destroy
    Gui, InsertDialog:Default
return

; === ФУНКЦИИ УПРАВЛЕНИЯ ВАРИАЦИЯМИ ВСТАВОК ===

; Добавить вариацию в диалоге добавления
AddInsertVariation:
    InputBox, newVariation, Добавить вариацию, Введите текст вариации:
    if (!ErrorLevel && newVariation != "") {
        Gui, InsertDialog:Default
        Gui, ListView, InsertVariationsList
        LV_Add("", newVariation)
    }
return

; Удалить вариацию в диалоге добавления
DeleteInsertVariation:
    Gui, InsertDialog:Default
    Gui, ListView, InsertVariationsList
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0) {
        MsgBox, 48, Ошибка, Выберите вариацию для удаления!
        return
    }
    LV_Delete(focusedRow)
return

; Редактировать вариацию в диалоге добавления
EditInsertVariation:
    Gui, InsertDialog:Default
    Gui, ListView, InsertVariationsList
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0) {
        MsgBox, 48, Ошибка, Выберите вариацию для редактирования!
        return
    }
    LV_GetText(currentText, focusedRow, 1)
    InputBox, newVariation, Редактировать вариацию, Введите новый текст вариации:, , 400, 140, , , , , %currentText%
    if (!ErrorLevel && newVariation != "") {
        LV_Modify(focusedRow, "", newVariation)
    }
return

; Редактировать вставку
EditInsert:
    Gui, 1:Default
    Gui, ListView, InsertsList
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0) {
        MsgBox, 48, Ошибка, Выберите вставку для редактирования!
        return
    }
    
    insertObj := customInserts[focusedRow]
    
    ; Создаем диалог редактирования
    Gui, EditInsertDialog:New
    Gui, EditInsertDialog:Font, s9, Segoe UI
    Gui, EditInsertDialog:Add, Text, x10 y10, Текст для вставки:
    Gui, EditInsertDialog:Add, Edit, vEditInsertText x10 y30 w420 h60, % insertObj.text
    
    Gui, EditInsertDialog:Add, Text, x10 y100, Позиция вставки:
    Gui, EditInsertDialog:Add, DropDownList, vEditInsertPosition x10 y120 w290 gCheckEditCustomNWords, Перед 1 слова|Перед 2 слов|Перед 3 слов|Перед 4 слов|Перед 5 слов|Перед N слов|Перед N слов с конца|Перед слова|ТОЛЬКО перед слова|После 1 слова|После 2 слов|После 3 слов|После 4 слов|После 5 слов|После N слов|После N слов с конца|После слова|ТОЛЬКО после слова|В начале после N слов|В середине после N слов|В конце после N слов|В начале перед N слов|В середине перед N слов|В конце перед N слов|Поочерёдно|Случайно|В начале|В середине|В конце
    Gui, EditInsertDialog:Add, Edit, vEditInsertNWords x310 y120 w120 Number Hidden
    
    Gui, EditInsertDialog:Add, Text, vEditInsertTargetLabel x10 y150 Hidden, Целевое слово:
    Gui, EditInsertDialog:Add, Edit, vEditInsertTargetWord x10 y170 w420 Hidden
    
    Gui, EditInsertDialog:Add, Text, x10 y200, Бинд (AHK):
    Gui, EditInsertDialog:Add, Edit, vEditInsertHotkey x10 y220 w420, % insertObj.hotkey
    
    Gui, EditInsertDialog:Add, Text, x10 y255, Игнорировать слова (через запятую):
    Gui, EditInsertDialog:Add, Edit, vEditInsertIgnoreWords x10 y275 w420, % insertObj.ignoreWords
    
    ; Чекбокс применения ошибок
    applyErrorsChecked := (insertObj.applyErrors = 1) ? 1 : 0
    Gui, EditInsertDialog:Add, Checkbox, vEditInsertApplyErrors x10 y305, Применять ошибки
    GuiControl,, EditInsertApplyErrors, %applyErrorsChecked%
    
    ; Таблица вариаций (всегда видима)
    if (!insertObj.variations)
        insertObj.variations := []
    if (!insertObj.variationStartPosition)
        insertObj.variationStartPosition := "С начала"
    Gui, EditInsertDialog:Add, GroupBox, vEditVariationsGroupBox x10 y330 w420 h200, Вариации текста
    Gui, EditInsertDialog:Add, ListView, vEditVariationsList x20 y350 w400 h130, Вариация
    Gui, EditInsertDialog:Add, Button, vEditAddVariation x20 y485 w100 h25 gAddEditVariation, ➕ Добавить
    Gui, EditInsertDialog:Add, Button, vEditDeleteVariation x130 y485 w100 h25 gDeleteEditVariation, ❌ Удалить
    Gui, EditInsertDialog:Add, Button, vEditEditVariation x240 y485 w100 h25 gEditEditVariation, ✏️ Редактировать
    Gui, EditInsertDialog:Add, Text, vEditVariationStartLabel x20 y515 w150, Откуда начать добавлять вставку:
    Gui, EditInsertDialog:Add, DropDownList, vEditVariationStartPosition x180 y512 w250, С начала|С середины|С конца
    
    ; Загружаем вариации в ListView
    UpdateEditVariationsList(insertObj.variations)
    GuiControl, EditInsertDialog:ChooseString, EditVariationStartPosition, % insertObj.variationStartPosition
    
    ; Logic to pre-select position, populate N or target-word when present
    pos := insertObj.position
    ; Anchored N-word patterns: "В начале/В середине/В конце (перед|после) N слов"
    if RegExMatch(pos, "^(В начале|В середине|В конце)\s+(перед|Перед|после|После)\s+(\d+)\s+слов", match) {
        anchor := match1
        dir := match2
        n := match3
        StringLower, dirLow, dir
        ; Build dropdown label like: "В начале после N слов" or "В середине перед N слов"
        label := anchor " " dirLow " N слов"
        GuiControl, EditInsertDialog:ChooseString, EditInsertPosition, %label%
        GuiControl, EditInsertDialog:, EditInsertNWords, %n%
        GuiControl, EditInsertDialog:Show, EditInsertNWords
    }
    else if RegExMatch(pos, "^ТОЛЬКО после слова\s+(.+)$", match) {
        GuiControl, EditInsertDialog:ChooseString, EditInsertPosition, ТОЛЬКО после слова
        GuiControl, EditInsertDialog:, EditInsertTargetWord, % Trim(match1)
        GuiControl, EditInsertDialog:Show, EditInsertTargetWord
    }
    else if RegExMatch(pos, "^ТОЛЬКО перед слова\s+(.+)$", match) {
        GuiControl, EditInsertDialog:ChooseString, EditInsertPosition, ТОЛЬКО перед слова
        GuiControl, EditInsertDialog:, EditInsertTargetWord, % Trim(match1)
        GuiControl, EditInsertDialog:Show, EditInsertTargetWord
    }
    else if RegExMatch(pos, "^После слова\s+(.+)$", match) {
        GuiControl, EditInsertDialog:ChooseString, EditInsertPosition, После слова
        GuiControl, EditInsertDialog:, EditInsertTargetWord, % Trim(match1)
        GuiControl, EditInsertDialog:Show, EditInsertTargetWord
    }
    else if RegExMatch(pos, "^Перед слова\s+(.+)$", match) {
        GuiControl, EditInsertDialog:ChooseString, EditInsertPosition, Перед слова
        GuiControl, EditInsertDialog:, EditInsertTargetWord, % Trim(match1)
        GuiControl, EditInsertDialog:Show, EditInsertTargetWord
    }
    else if RegExMatch(pos, "(\d+)", match) {
        n := match1
        if InStr(pos, "Перед") {
            if InStr(pos, "с конца")
                GuiControl, EditInsertDialog:ChooseString, EditInsertPosition, Перед N слов с конца
            else
                GuiControl, EditInsertDialog:ChooseString, EditInsertPosition, Перед N слов
        }
        else if InStr(pos, "После") {
            if InStr(pos, "с конца")
                GuiControl, EditInsertDialog:ChooseString, EditInsertPosition, После N слов с конца
            else
                GuiControl, EditInsertDialog:ChooseString, EditInsertPosition, После N слов
        }
        GuiControl, EditInsertDialog:, EditInsertNWords, %n%
        GuiControl, EditInsertDialog:Show, EditInsertNWords
    } else {
        GuiControl, EditInsertDialog:ChooseString, EditInsertPosition, %pos%
    }
    
    Gui, EditInsertDialog:Add, Button, x10 y545 w205 gEditInsertDialogOK, ✓ Сохранить
    Gui, EditInsertDialog:Add, Button, x225 y545 w205 gEditInsertDialogCancel, ✗ Отмена
    Gui, EditInsertDialog:Add, Text, vEditInsertIndex Hidden, %focusedRow%
    Gui, EditInsertDialog:Show, w450 h590, Редактировать вставку
return

CheckEditCustomNWords:
    Gui, EditInsertDialog:Submit, NoHide
    ; Показываем поле для ввода N, если выбрана любая позиция, содержащая 'N слов'
    if InStr(EditInsertPosition, "N слов")
        GuiControl, EditInsertDialog:Show, EditInsertNWords
    else
        GuiControl, EditInsertDialog:Hide, EditInsertNWords

    ; Показываем поле для ввода целевого слова, если выбрана позиция типа '... слова' или 'ТОЛЬКО ...'
    if (InStr(EditInsertPosition, "слова") || InStr(EditInsertPosition, "ТОЛЬКО")) {
        GuiControl, EditInsertDialog:Show, EditInsertTargetLabel
        GuiControl, EditInsertDialog:Show, EditInsertTargetWord
    } else {
        GuiControl, EditInsertDialog:Hide, EditInsertTargetLabel
        GuiControl, EditInsertDialog:Hide, EditInsertTargetWord
    }
return

EditInsertDialogOK:
    Gui, EditInsertDialog:Submit, NoHide
    global customInserts
    GuiControlGet, idx,, EditInsertIndex
    
    if (EditInsertText = "") {
        MsgBox, 48, Ошибка, Введите текст для вставки!
        return
    }
    
    finalPosition := EditInsertPosition
    if InStr(EditInsertPosition, "N слов") {
        if (EditInsertNWords = "" || EditInsertNWords <= 0) {
            MsgBox, 48, Ошибка, Укажите количество слов!
            return
        }
        StringReplace, finalPosition, finalPosition, N, %EditInsertNWords%, All
    }
    if (InStr(EditInsertPosition, "слова") || InStr(EditInsertPosition, "ТОЛЬКО")) {
        if (EditInsertTargetWord = "") {
            MsgBox, 48, Ошибка, Укажите целевое слово для вставки!
            return
        }
        finalPosition := EditInsertPosition . " " . Trim(EditInsertTargetWord)
    }
    
    ; Собираем вариации из ListView
    variations := []
    variationStartPosition := "С начала"
    Gui, EditInsertDialog:Default
    Gui, ListView, EditVariationsList
    rowCount := LV_GetCount()
    Loop, %rowCount% {
        LV_GetText(variationText, A_Index, 1)
        if (variationText != "")
            variations.Push(variationText)
    }
    variationStartPosition := EditVariationStartPosition
    
    ; Обновляем вставку (с обработкой хоткея)
    oldHK := customInserts[idx].hotkey
    if (oldHK != "" && oldHK != EditInsertHotkey)
        UnregisterInsertHotkey(oldHK)

    customInserts[idx].text := EditInsertText
    customInserts[idx].position := finalPosition
    customInserts[idx].ignoreWords := EditInsertIgnoreWords
    customInserts[idx].hotkey := EditInsertHotkey
    customInserts[idx].applyErrors := EditInsertApplyErrors ? 1 : 0
    customInserts[idx].variations := variations
    customInserts[idx].variationStartPosition := variationStartPosition

    if (EditInsertHotkey != "" && EditInsertHotkey != oldHK)
        RegisterInsertHotkey(EditInsertHotkey, idx)

    Gui, EditInsertDialog:Destroy
    Gui, 1:Default
    UpdateInsertsList()
    SaveInserts()
return

EditInsertDialogCancel:
    Gui, EditInsertDialog:Destroy
    Gui, 1:Default
return

EditInsertDialogGuiClose:
    Gui, EditInsertDialog:Destroy
    Gui, 1:Default
return

; Обновление списка вариаций в диалоге редактирования
UpdateEditVariationsList(variations) {
    Gui, EditInsertDialog:Default
    Gui, ListView, EditVariationsList
    GuiControl, EditInsertDialog:-Redraw, EditVariationsList
    LV_Delete()
    for i, variation in variations {
        LV_Add("", variation)
    }
    GuiControl, EditInsertDialog:+Redraw, EditVariationsList
}

; Добавить вариацию в диалоге редактирования
AddEditVariation:
    InputBox, newVariation, Добавить вариацию, Введите текст вариации:
    if (!ErrorLevel && newVariation != "") {
        Gui, EditInsertDialog:Default
        Gui, ListView, EditVariationsList
        LV_Add("", newVariation)
    }
return

; Удалить вариацию в диалоге редактирования
DeleteEditVariation:
    Gui, EditInsertDialog:Default
    Gui, ListView, EditVariationsList
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0) {
        MsgBox, 48, Ошибка, Выберите вариацию для удаления!
        return
    }
    LV_Delete(focusedRow)
return

; Редактировать вариацию в диалоге редактирования
EditEditVariation:
    Gui, EditInsertDialog:Default
    Gui, ListView, EditVariationsList
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0) {
        MsgBox, 48, Ошибка, Выберите вариацию для редактирования!
        return
    }
    LV_GetText(currentText, focusedRow, 1)
    InputBox, newVariation, Редактировать вариацию, Введите новый текст вариации:, , 400, 140, , , , , %currentText%
    if (!ErrorLevel && newVariation != "") {
        LV_Modify(focusedRow, "", newVariation)
    }
return

; Удалить вставку
DeleteInsert:
    Gui, 1:Default
    Gui, ListView, InsertsList
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0) {
        MsgBox, 48, Ошибка, Выберите вставку для удаления!
        return
    }
    
    MsgBox, 4, Удалить?, Удалить эту вставку?
    IfMsgBox, Yes
    {
        ; Unregister hotkey if exists
        hk := customInserts[focusedRow].hotkey
        if (hk != "")
            UnregisterInsertHotkey(hk)

        customInserts.RemoveAt(focusedRow)
        insertCount--
        ; После удаления индексы сдвинулись — перестроим мапу хоткеев
        RebuildHotkeyMap()
        UpdateInsertsList()
        SaveInserts()
    }
return

; Очистить все вставки
ClearInserts:
    global customInserts, insertCount
    
    MsgBox, 4, Очистить?, Удалить все вставки?
    IfMsgBox, Yes
    {
        ; Unregister all hotkeys first
        for index, insertObj in customInserts {
            if (insertObj.hotkey != "")
                UnregisterInsertHotkey(insertObj.hotkey)
        }
        customInserts := []
        insertCount := 0
        UpdateInsertsList()
        SaveInserts()
    }
return

; Переключить вкл/выкл для выбранной вставки
ToggleInsert:
    Gui, 1:Default
    Gui, ListView, InsertsList
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0) {
        MsgBox, 48, Ошибка, Выберите вставку для переключения!
        return
    }

    global customInserts
    if (!customInserts[focusedRow]) {
        MsgBox, 48, Ошибка, Неверная вставка!
        return
    }

    ; Toggle
    customInserts[focusedRow].enabled := customInserts[focusedRow].enabled ? 0 : 1
    UpdateInsertsList()
    SaveInserts()
    LV_Modify(focusedRow, "Select")
    status := customInserts[focusedRow].enabled ? "включена" : "выключена"
    SB_SetText("Вставка " . customInserts[focusedRow].text . " " . status, 1)
return

; === Функции контекстного меню ===

; Добавить выделенный текст в вставку
AddSelectedToInsert:
    selectedText := GetSelectedText()
    
    if (selectedText = "") {
        MsgBox, 48, Ошибка, Не удалось получить выделенный текст!`n`nВыделите текст и нажмите Alt+C
        return
    }
    
    ; Создаем диалог для настройки вставки
    Gui, QuickInsertDialog:New, -Resize -MaximizeBox, Добавить вставку
    Gui, QuickInsertDialog:Font, s9, Segoe UI
    
    Gui, QuickInsertDialog:Add, Text, x10 y10, Текст вставки:
    Gui, QuickInsertDialog:Add, Edit, vQuickInsertText x10 y30 w460 h60 Multi ReadOnly, %selectedText%
    
    Gui, QuickInsertDialog:Add, Text, x10 y100, Позиция:
    Gui, QuickInsertDialog:Add, DropDownList, vQuickInsertPosition x10 y120 w460, Перед 1 слова|Перед 2 слов|Перед 3 слов|Перед 4 слов|Перед 5 слов|Перед N слов|Перед N слов с конца|Перед слова|ТОЛЬКО перед слова|После 1 слова|После 2 слов|После 3 слов|После 4 слов|После 5 слов|После N слов|После N слов с конца|После слова|ТОЛЬКО после слова|В начале после N слов|В середине после N слов|В конце после N слов|В начале перед N слов|В середине перед N слов|В конце перед N слов|Поочерёдно|Случайно|В начале|В середине|В конце
    GuiControl, Choose, QuickInsertPosition, 1
    
    Gui, QuickInsertDialog:Add, Button, x10 y160 w225 h30 gQuickInsertOK, ✓ Добавить
    Gui, QuickInsertDialog:Add, Button, x245 y160 w225 h30 gQuickInsertCancel, ✗ Отмена
    
    Gui, QuickInsertDialog:Show, w480 h200
return

QuickInsertOK:
    Gui, QuickInsertDialog:Submit
    
    global customInserts, insertCount
    
    ; Создаем объект вставки
    insertObj := {}
    insertObj.text := QuickInsertText
    insertObj.position := QuickInsertPosition
    insertObj.ignoreWords := ""
    insertObj.hotkey := ""
    insertObj.enabled := 1
    insertObj.applyErrors := 0
    insertObj.variations := []
    insertObj.variationStartPosition := "С начала"
    
    customInserts.Push(insertObj)
    insertCount++
    
    Gui, QuickInsertDialog:Destroy
    Gui, 1:Default
    UpdateInsertsList()
    SaveInserts()
    
    MsgBox, 64, Успех, Текст добавлен в вставки!
return

QuickInsertCancel:
    Gui, QuickInsertDialog:Destroy
    Gui, 1:Default
return

QuickInsertDialogGuiClose:
    Gui, QuickInsertDialog:Destroy
    Gui, 1:Default
return

; Добавить выделенный текст в основной текст
AddSelectedToMainText:
    selectedText := GetSelectedText()
    
    if (selectedText = "") {
        MsgBox, 48, Ошибка, Не удалось получить выделенный текст!`n`nВыделите текст и нажмите Alt+C
        return
    }
    
    ; Получаем текущий текст
    GuiControlGet, currentText,, TypeText
    
    ; Добавляем выделенный текст
    if (currentText != "") {
        newText := currentText . "`n" . selectedText
    } else {
        newText := selectedText
    }
    
    GuiControl,, TypeText, %newText%
    MsgBox, 64, Успех, Текст добавлен в основное поле!
return

; Закрыть контекстное меню
CloseContextMenu:
return

; Смена режима Auto-Enter через контекстное меню
ChangeAutoEnter:
    Gui, 1:Submit, NoHide
    ; Получаем текущий режим и параметры
    currentMode := "Отключено"
    if (AutoEnterMode = 2)
        currentMode := "Максимум слов"
    else if (AutoEnterMode = 3)
        currentMode := "Enter через время"
    
    ; Создаём диалог выбора режима
    Gui, AutoEnterDialog:New, +Owner1 +ToolWindow
    Gui, AutoEnterDialog:Font, s10
    Gui, AutoEnterDialog:Add, Text, x10 y10 w280, Выберите режим Auto-Enter:
    Gui, AutoEnterDialog:Add, DropDownList, vNewAutoEnterMode x10 y40 w280 gUpdateAutoEnterFields, Отключено|Максимум слов|Enter через время
    GuiControl, AutoEnterDialog:ChooseString, NewAutoEnterMode, %currentMode%
    
    ; Поля для режима "Максимум слов"
    Gui, AutoEnterDialog:Add, Text, vAEWordsLabel x10 y80 w120, Количество слов:
    Gui, AutoEnterDialog:Add, Edit, vAEWordsInput x130 y77 w80 Number, %MaxWordsInput%
    Gui, AutoEnterDialog:Add, Text, vAEWordsHint x220 y80 w70 cGray, (0 = без лимита)
    
    ; Поля для режима "Enter через время"
    Gui, AutoEnterDialog:Add, Text, vAETimeLabel x10 y80 w120 Hidden, Интервал:
    Gui, AutoEnterDialog:Add, Edit, vAETimeInput x130 y77 w80 Number Hidden, %TimeInput%
    Gui, AutoEnterDialog:Add, DropDownList, vAETimeUnit x220 y77 w70 Hidden, мс|сек
    GuiControl, AutoEnterDialog:ChooseString, AETimeUnit, %TimeUnit%
    
    ; Кнопки
    Gui, AutoEnterDialog:Add, Button, x10 y120 w130 h30 gAutoEnterDialogOK Default, ✓ OK
    Gui, AutoEnterDialog:Add, Button, x150 y120 w130 h30 gAutoEnterDialogCancel, ✗ Отмена
    
    ; Обновляем видимость полей
    Gosub, UpdateAutoEnterFields
    Gui, AutoEnterDialog:Show, w300 h160, Режим Auto-Enter
return

; Обновить видимость полей в диалоге Auto-Enter
UpdateAutoEnterFields:
    Gui, AutoEnterDialog:Submit, NoHide
    
    ; Скрываем все поля
    GuiControl, AutoEnterDialog:Hide, AEWordsLabel
    GuiControl, AutoEnterDialog:Hide, AEWordsInput
    GuiControl, AutoEnterDialog:Hide, AEWordsHint
    GuiControl, AutoEnterDialog:Hide, AETimeLabel
    GuiControl, AutoEnterDialog:Hide, AETimeInput
    GuiControl, AutoEnterDialog:Hide, AETimeUnit
    
    ; Показываем нужные поля
    if (NewAutoEnterMode = "Максимум слов") {
        GuiControl, AutoEnterDialog:Show, AEWordsLabel
        GuiControl, AutoEnterDialog:Show, AEWordsInput
        GuiControl, AutoEnterDialog:Show, AEWordsHint
    } else if (NewAutoEnterMode = "Enter через время") {
        GuiControl, AutoEnterDialog:Show, AETimeLabel
        GuiControl, AutoEnterDialog:Show, AETimeInput
        GuiControl, AutoEnterDialog:Show, AETimeUnit
    }
return

AutoEnterDialogOK:
    Gui, AutoEnterDialog:Submit, NoHide
    
    ; Устанавливаем новый режим
    if (NewAutoEnterMode = "Отключено") {
        GuiControl, 1:, AutoEnterMode, 1
        successMsg := "Режим Auto-Enter отключён"
    } else if (NewAutoEnterMode = "Максимум слов") {
        GuiControl, 1:, AutoEnterMode, 2
        ; Устанавливаем количество слов
        if (AEWordsInput != "")
            GuiControl, 1:, MaxWordsInput, %AEWordsInput%
        successMsg := "Режим: Максимум слов"
        if (AEWordsInput != "" && AEWordsInput != "0")
            successMsg .= "`nКоличество слов: " . AEWordsInput
        else
            successMsg .= "`nКоличество слов: без ограничений"
    } else if (NewAutoEnterMode = "Enter через время") {
        GuiControl, 1:, AutoEnterMode, 3
        ; Устанавливаем интервал времени
        if (AETimeInput != "") {
            GuiControl, 1:, TimeInput, %AETimeInput%
            GuiControl, 1:ChooseString, TimeUnit, %AETimeUnit%
        }
        successMsg := "Режим: Enter через время"
        if (AETimeInput != "")
            successMsg .= "`nИнтервал: " . AETimeInput . " " . AETimeUnit
    }
    
    ; Обновляем интерфейс и синхронизируем переменные с GUI
    Gui, 1:Default
    Gosub, UpdateAutoEnterMode
    Gui, 1:Submit, NoHide
    
    Gui, AutoEnterDialog:Destroy
    MsgBox, 64, Успех, %successMsg%
return

AutoEnterDialogCancel:
    Gui, AutoEnterDialog:Destroy
return

AutoEnterDialogClose:
    Gui, AutoEnterDialog:Destroy
return

; Изменить регистр текста
ChangeTextCase:
    Gui, TextCaseDialog:New, -Resize, Изменить регистр текста
    Gui, TextCaseDialog:Font, s9, Segoe UI
    
    Gui, TextCaseDialog:Add, Text, x10 y10, Выберите регистр:
    Gui, TextCaseDialog:Add, DropDownList, vNewTextCase x10 y30 w260, Обычный|ВЕРХНИЙ|нижний|Случайный
    GuiControl, TextCaseDialog:ChooseString, NewTextCase, Обычный
    
    Gui, TextCaseDialog:Add, Button, x10 y70 w125 h30 gTextCaseDialogOK, ✓ Применить
    Gui, TextCaseDialog:Add, Button, x145 y70 w125 h30 gTextCaseDialogCancel, ✗ Отмена
    
    Gui, TextCaseDialog:Show, w280 h110
return

TextCaseDialogOK:
    Gui, TextCaseDialog:Submit
    GuiControl, 1:ChooseString, TextCase, %NewTextCase%
    Gui, TextCaseDialog:Destroy
    Gui, 1:Default
    MsgBox, 64, Успех, Регистр текста изменен на: %NewTextCase%
return

TextCaseDialogCancel:
TextCaseDialogGuiClose:
    Gui, TextCaseDialog:Destroy
    Gui, 1:Default
return

; Изменить уровень ошибок
ChangeErrorLevel:
    Gui, ErrorLevelDialog:New, -Resize, Изменить уровень ошибок
    Gui, ErrorLevelDialog:Font, s9, Segoe UI
    
    Gui, ErrorLevelDialog:Add, Text, x10 y10, Выберите уровень ошибок:
    Gui, ErrorLevelDialog:Add, DropDownList, vNewErrorLevel x10 y30 w260, Нет|Лёгкий|Средний|Высокий|Экстремальный
    GuiControl, ErrorLevelDialog:ChooseString, NewErrorLevel, Нет
    
    Gui, ErrorLevelDialog:Add, Button, x10 y70 w125 h30 gErrorLevelDialogOK, ✓ Применить
    Gui, ErrorLevelDialog:Add, Button, x145 y70 w125 h30 gErrorLevelDialogCancel, ✗ Отмена
    
    Gui, ErrorLevelDialog:Show, w280 h110
return

ErrorLevelDialogOK:
    Gui, ErrorLevelDialog:Submit
    GuiControl, 1:ChooseString, ErrorLevelSetting, %NewErrorLevel%
    Gui, ErrorLevelDialog:Destroy
    Gui, 1:Default
    MsgBox, 64, Успех, Уровень ошибок изменен на: %NewErrorLevel%
return

ErrorLevelDialogCancel:
ErrorLevelDialogGuiClose:
    Gui, ErrorLevelDialog:Destroy
    Gui, 1:Default
return

; Изменить генерацию строк/слов
ChangeGeneratorCount:
    Gui, GeneratorCountDialog:New, -Resize, Изменить генерацию
    Gui, GeneratorCountDialog:Font, s9, Segoe UI
    
    Gui, GeneratorCountDialog:Add, Text, x10 y10, Режим генерации:
    Gui, GeneratorCountDialog:Add, Radio, vGenModeLines x10 y30 gUpdateGenModePreview, По строкам
    Gui, GeneratorCountDialog:Add, Radio, vGenModeWords x150 y30 gUpdateGenModePreview Checked, По словам
    
    Gui, GeneratorCountDialog:Add, Text, vGenCountLabel x10 y60, Количество слов:
    Gui, GeneratorCountDialog:Add, Edit, vGenCount x10 y80 w260 Number, 5
    
    Gui, GeneratorCountDialog:Add, Button, x10 y120 w125 h30 gGeneratorCountDialogOK, ✓ Применить
    Gui, GeneratorCountDialog:Add, Button, x145 y120 w125 h30 gGeneratorCountDialogCancel, ✗ Отмена
    
    Gui, GeneratorCountDialog:Show, w280 h160
return

UpdateGenModePreview:
    Gui, GeneratorCountDialog:Submit, NoHide
    if (GenModeLines) {
        GuiControl, GeneratorCountDialog:, GenCountLabel, Количество строк:
    } else {
        GuiControl, GeneratorCountDialog:, GenCountLabel, Количество слов:
    }
return

GeneratorCountDialogOK:
    Gui, GeneratorCountDialog:Submit
    
    if (GenModeLines) {
        GuiControl, 1:, GenByLines, 1
        GuiControl, 1:, GenByWords, 0
        GuiControl, 1:, LinesCount, %GenCount%
        Gosub, UpdateGenType
        MsgBox, 64, Успех, Генератор установлен: %GenCount% строк
    } else {
        GuiControl, 1:, GenByLines, 0
        GuiControl, 1:, GenByWords, 1
        GuiControl, 1:, WordsCount, %GenCount%
        Gosub, UpdateGenType
        MsgBox, 64, Успех, Генератор установлен: %GenCount% слов
    }
    
    Gui, GeneratorCountDialog:Destroy
    Gui, 1:Default
return

GeneratorCountDialogCancel:
GeneratorCountDialogGuiClose:
    Gui, GeneratorCountDialog:Destroy
    Gui, 1:Default
return

; Получить выделенный текст из любого приложения
GetSelectedText() {
    ; Сохраняем текущий буфер обмена
    clipboardBackup := ClipboardAll
    Clipboard := ""
    
    ; Копируем выделенный текст
    Send, ^c
    ClipWait, 0.5
    
    selectedText := Clipboard
    
    ; Восстанавливаем буфер обмена
    Clipboard := clipboardBackup
    clipboardBackup := ""
    
    return Trim(selectedText)
}

; Транслитерация символа
TranslitChar(char) {
    ; Русские буквы -> латинские
    translitMap := {а: "a", б: "b", в: "v", г: "g", д: "d", е: "e", ё: "yo", ж: "zh", з: "z", и: "i", й: "y", к: "k", л: "l", м: "m", н: "n", о: "o", п: "p", р: "r", с: "s", т: "t", у: "u", ф: "f", х: "h", ц: "ts", ч: "ch", ш: "sh", щ: "sch", ъ: "", ы: "y", ь: "", э: "e", ю: "yu", я: "ya", А: "A", Б: "B", В: "V", Г: "G", Д: "D", Е: "E", Ё: "Yo", Ж: "Zh", З: "Z", И: "I", Й: "Y", К: "K", Л: "L", М: "M", Н: "N", О: "O", П: "P", Р: "R", С: "S", Т: "T", У: "U", Ф: "F", Х: "H", Ц: "Ts", Ч: "Ch", Ш: "Sh", Щ: "Sch", Ъ: "", Ы: "Y", Ь: "", Э: "E", Ю: "Yu", Я: "Ya"}
    
    if (translitMap.HasKey(char))
        return translitMap[char]
    return char
}

; Обновить список вставок
UpdateInsertsList() {
    global customInserts
    Gui, 1:Default
    Gui, ListView, InsertsList
    GuiControl, -Redraw, InsertsList
    LV_Delete()
    
    for index, insertObj in customInserts {
        displayText := insertObj.text
        if (insertObj.enabled = 0)
            displayText .= " (выкл)"
        LV_Add("", displayText, insertObj.position, insertObj.ignoreWords)
    }
    
    GuiControl, +Redraw, InsertsList
}

; Сохранить вставки в INI
SaveInserts() {
    global customInserts
    ; Удаляем старые записи
    IniDelete, %appDataDir%\AutoTyper.ini, Inserts
    ; Сохраняем количество вставок
    IniWrite, % customInserts.Length(), %appDataDir%\AutoTyper.ini, Inserts, Count
    ; Сохраняем каждую вставку
    for i, insertObj in customInserts {
        section := "Insert" . i
        IniWrite, % insertObj.text, %appDataDir%\AutoTyper.ini, %section%, Text
        IniWrite, % insertObj.position, %appDataDir%\AutoTyper.ini, %section%, Position
        IniWrite, % insertObj.ignoreWords, %appDataDir%\AutoTyper.ini, %section%, IgnoreWords
        IniWrite, % insertObj.hotkey, %appDataDir%\AutoTyper.ini, %section%, Hotkey
        IniWrite, % insertObj.enabled, %appDataDir%\AutoTyper.ini, %section%, Enabled
        IniWrite, % insertObj.applyErrors, %appDataDir%\AutoTyper.ini, %section%, ApplyErrors
        IniWrite, % insertObj.useVariations ? 1 : 0, %appDataDir%\AutoTyper.ini, %section%, UseVariations
        IniWrite, % insertObj.variationStartPosition ? insertObj.variationStartPosition : "С начала", %appDataDir%\AutoTyper.ini, %section%, VariationStartPosition
        ; Сохраняем вариации
        if (insertObj.variations && insertObj.variations.Length() > 0) {
            variationsText := ""
            for j, variation in insertObj.variations {
                variationsText .= (variationsText ? "|" : "") . variation
            }
            IniWrite, %variationsText%, %appDataDir%\AutoTyper.ini, %section%, Variations
        } else {
            IniDelete, %appDataDir%\AutoTyper.ini, %section%, Variations
        }
    }
}

; Загрузить вставки из INI
LoadInserts() {
    global customInserts, insertCount
    customInserts := []
    insertCount := 0
    IniRead, insertCount, %appDataDir%\AutoTyper.ini, Inserts, Count, 0
    if (insertCount > 0) {
        Loop, %insertCount% {
            section := "Insert" . A_Index
            IniRead, insertText, %appDataDir%\AutoTyper.ini, %section%, Text,
            IniRead, insertPosition, %appDataDir%\AutoTyper.ini, %section%, Position,
            IniRead, insertIgnoreWords, %appDataDir%\AutoTyper.ini, %section%, IgnoreWords,
            IniRead, insertHotkey, %appDataDir%\AutoTyper.ini, %section%, Hotkey,
            IniRead, insertEnabled, %appDataDir%\AutoTyper.ini, %section%, Enabled, 1
            IniRead, insertApplyErrors, %appDataDir%\AutoTyper.ini, %section%, ApplyErrors, 0
            IniRead, insertVariationStartPosition, %appDataDir%\AutoTyper.ini, %section%, VariationStartPosition, С начала
            IniRead, insertVariations, %appDataDir%\AutoTyper.ini, %section%, Variations,
            if (insertText != "") {
                insertObj := {}
                insertObj.text := insertText
                insertObj.position := insertPosition
                insertObj.ignoreWords := insertIgnoreWords
                insertObj.hotkey := insertHotkey
                insertObj.enabled := insertEnabled
                insertObj.applyErrors := insertApplyErrors
                insertObj.variationStartPosition := insertVariationStartPosition
                ; Загружаем вариации
                insertObj.variations := []
                if (insertVariations != "" && insertVariations != "ERROR") {
                    Loop, Parse, insertVariations, |
                    {
                        if (A_LoopField != "")
                            insertObj.variations.Push(A_LoopField)
                    }
                }
                customInserts.Push(insertObj)
                ; Регистрируем хоткей если указан
                if (insertHotkey != "")
                    RegisterInsertHotkey(insertHotkey, customInserts.Length())
            }
        }
    }
    UpdateInsertsList()
}

; Register a user-provided hotkey to toggle a specific insert
RegisterInsertHotkey(hotkey, idx) {
    global hotkeyMap
    if (hotkey = "")
        return
    ; If already registered for another index, unregister first
    if (hotkeyMap.HasKey(hotkey))
        UnregisterInsertHotkey(hotkey)
    hotkeyMap[hotkey] := idx
    Hotkey, %hotkey%, DynamicInsertHotkey, On
}

UnregisterInsertHotkey(hotkey) {
    global hotkeyMap
    if (hotkey = "")
        return
    Hotkey, %hotkey%, DynamicInsertHotkey, Off
    hotkeyMap.Delete(hotkey)
}

; Перестроить мапу хоткеев после операций, меняющих индексы вставок
RebuildHotkeyMap() {
    global hotkeyMap, customInserts
    ; Unregister all currently registered hotkeys
    for hk, idx in hotkeyMap
        Hotkey, %hk%, DynamicInsertHotkey, Off
    hotkeyMap := {}
    ; Re-register according to current insert indices
    for index, insertObj in customInserts {
        if (insertObj.hotkey != "")
            RegisterInsertHotkey(insertObj.hotkey, index)
    }
}

DynamicInsertHotkey:
    global hotkeyMap, customInserts
    hk := A_ThisHotkey
    if (!hotkeyMap.HasKey(hk))
        return
    idx := hotkeyMap[hk]
    if (!customInserts[idx])
        return
    customInserts[idx].enabled := customInserts[idx].enabled ? 0 : 1
    UpdateInsertsList()
    SaveInserts()
    status := customInserts[idx].enabled ? "включена" : "выключена"
    SB_SetText("Вставка " . customInserts[idx].text . " " . status, 1)
return

; === CTRL + X Logic removed ===

; === Scrollbar Logic ===
UpdateScrollBars() {
    Gui, +LastFound
    GuiHwnd := WinExist()
    
    ; Calculate total height of content (increased to fit larger GUI)
    ContentHeight := 1100
    
    VarSetCapacity(si, 28, 0)
    NumPut(28, si, 0, "UInt") ; cbSize
    NumPut(1, si, 4, "UInt") ; fMask = SIF_RANGE
    NumPut(ContentHeight, si, 12, "Int") ; nMax
    
    DllCall("SetScrollInfo", "Ptr", GuiHwnd, "Int", 1, "Ptr", &si, "Int", 1)
}

GuiSize:
    UpdateScrollBars()
return

OnScroll(wParam, lParam, msg, hwnd) {
    static SIF_ALL=0x17, SIF_POS=0x4, SCROLL_STEP=20
    
    bar := (msg=0x115) ? 1 : 0 ; 1 = SB_VERT, 0 = SB_HORZ
    
    Gui, +LastFound
    GuiHwnd := WinExist()
    if (hwnd != GuiHwnd)
        return
        
    VarSetCapacity(si, 28, 0)
    NumPut(28, si, 0, "UInt") ; cbSize
    NumPut(SIF_ALL, si, 4, "UInt") ; fMask
    if !DllCall("GetScrollInfo", "Ptr", hwnd, "Int", bar, "Ptr", &si)
        return

    nMin  := NumGet(si, 8, "Int")
    nMax  := NumGet(si, 12, "Int")
    nPage := NumGet(si, 16, "UInt")
    nPos  := NumGet(si, 20, "Int")
    
    action := wParam & 0xFFFF
    newPos := nPos
    
    if (action = 0) ; SB_LINEUP
        newPos := nPos - SCROLL_STEP
    else if (action = 1) ; SB_LINEDOWN
        newPos := nPos + SCROLL_STEP
    else if (action = 2) ; SB_PAGEUP
        newPos := nPos - nPage
    else if (action = 3) ; SB_PAGEDOWN
        newPos := nPos + nPage
    else if (action = 5 || action = 4) ; SB_THUMBTRACK or SB_THUMBPOSITION
        newPos := (wParam >> 16) & 0xFFFF
    else
        return

    ; Ограничиваем диапазон
    maxPos := nMax - nPage + 1
    if (maxPos < nMin)
        maxPos := nMin
    if (newPos < nMin)
        newPos := nMin
    if (newPos > maxPos)
        newPos := maxPos
    
    ; Если позиция не изменилась, ничего не делаем
    if (newPos = nPos)
        return
        
    ; Обновляем позицию в структуре
    NumPut(newPos, si, 20, "Int")
    NumPut(SIF_POS, si, 4, "UInt")
    DllCall("SetScrollInfo", "Ptr", hwnd, "Int", bar, "Ptr", &si, "Int", 1)
    
    ; Прокручиваем содержимое окна
    DllCall("ScrollWindow", "Ptr", hwnd, "Int", 0, "Int", nPos - newPos, "Ptr", 0, "Ptr", 0)
}

; Обработка прокрутки колёсиком мыши
OnMouseWheel(wParam, lParam, msg, hwnd) {
    static SIF_ALL=0x17, SIF_POS=0x4, WHEEL_DELTA=120, SCROLL_LINES=3
    
    Gui, +LastFound
    GuiHwnd := WinExist()
    if (hwnd != GuiHwnd)
        return
    
    ; Определяем направление прокрутки
    wheelDelta := (wParam >> 16)
    if (wheelDelta > 0x7FFF)
        wheelDelta := -(0x10000 - wheelDelta)
    
    scrollAmount := -1 * Floor(wheelDelta / WHEEL_DELTA) * SCROLL_LINES * 20
    
    ; Получаем текущую позицию скролла
    VarSetCapacity(si, 28, 0)
    NumPut(28, si, 0, "UInt")
    NumPut(SIF_ALL, si, 4, "UInt")
    if !DllCall("GetScrollInfo", "Ptr", hwnd, "Int", 1, "Ptr", &si)
        return
    
    nMin  := NumGet(si, 8, "Int")
    nMax  := NumGet(si, 12, "Int")
    nPage := NumGet(si, 16, "UInt")
    nPos  := NumGet(si, 20, "Int")
    
    newPos := nPos + scrollAmount
    
    ; Ограничиваем диапазон
    maxPos := nMax - nPage + 1
    if (maxPos < nMin)
        maxPos := nMin
    if (newPos < nMin)
        newPos := nMin
    if (newPos > maxPos)
        newPos := maxPos
    
    if (newPos = nPos)
        return
    
    ; Обновляем позицию
    NumPut(newPos, si, 20, "Int")
    NumPut(SIF_POS, si, 4, "UInt")
    DllCall("SetScrollInfo", "Ptr", hwnd, "Int", 1, "Ptr", &si, "Int", 1)
    
    ; Прокручиваем окно
    DllCall("ScrollWindow", "Ptr", hwnd, "Int", 0, "Int", nPos - newPos, "Ptr", 0, "Ptr", 0)
}

; === Сохранение шаблона (обновлено для новой системы) ===
SavePreset:
    Gui, 1:Submit, NoHide
    global navigationLevel, currentCategory, currentSubcategory, presetDir, categoriesFile
    
    ; Создаем GUI для выбора подкатегории и ввода имени
    Gui, SaveDialog:New
    Gui, SaveDialog:Font, s9, Segoe UI
    Gui, SaveDialog:Add, Text, x10 y10, Введите имя шаблона:
    Gui, SaveDialog:Add, Edit, vSavePresetName x10 y30 w380
    Gui, SaveDialog:Add, Text, x10 y65, В какую подкатегорию сохранить шаблон?
    Gui, SaveDialog:Add, ComboBox, vSaveTargetSubcategory x10 y85 w380
    Gui, SaveDialog:Add, Button, x10 y120 w185 gSavePresetConfirm, ✓ Сохранить
    Gui, SaveDialog:Add, Button, x205 y120 w185 gSavePresetCancel, ✗ Отмена
    
    ; Заполняем список всех подкатегорий
    IniRead, allCategories, %categoriesFile%, Categories, List, 
    
    Loop, Parse, allCategories, |
    {
        if (A_LoopField = "")
            continue
        category := A_LoopField
        IniRead, subcategories, %categoriesFile%, Category_%category%, Subcategories, 
        Loop, Parse, subcategories, |
        {
            if (A_LoopField != "") {
                subcatPath := category . " → " . A_LoopField
                GuiControl, SaveDialog:, SaveTargetSubcategory, %subcatPath%
                ; Выбираем текущую подкатегорию по умолчанию
                if (navigationLevel = "presets" && category = currentCategory && A_LoopField = currentSubcategory) {
                    GuiControl, SaveDialog:ChooseString, SaveTargetSubcategory, %subcatPath%
                }
            }
        }
    }
    
    Gui, SaveDialog:Show, w400 h165, Сохранить шаблон
return

SavePresetConfirm:
    Gui, SaveDialog:Submit, NoHide
    global presetDir, categoriesFile
    
    if (SavePresetName = "") {
        MsgBox, 48, Ошибка, Введите имя шаблона!
        return
    }
    
    if (SaveTargetSubcategory = "") {
        MsgBox, 48, Ошибка, Выберите подкатегорию!
        return
    }
    
    ; Парсим путь
    targetParts := StrSplit(SaveTargetSubcategory, "→")
    if (targetParts.Length() != 2) {
        MsgBox, 16, Ошибка, Неверный формат пути!
        return
    }
    
    targetCategory := Trim(targetParts[1])
    targetSubcategory := Trim(targetParts[2])
    
    ; Получаем текст из основного окна
    Gui, 1:Default
    Gui, 1:Submit, NoHide
    
    ; Сохраняем файл
    targetDir := presetDir . "\" . targetCategory . "\" . targetSubcategory
    if (!FileExist(targetDir))
        FileCreateDir, %targetDir%
    
    filePath := targetDir . "\" . SavePresetName . ".txt"
    FileDelete, %filePath%
    FileAppend, %TypeText%, %filePath%, UTF-8
    
    Gui, SaveDialog:Destroy
    Gui, 1:Default
    
    ; Если сохранили в текущую подкатегорию, обновляем список
    ; В противном случае не меняем текущий вид
    if (navigationLevel = "presets" && targetCategory = currentCategory && targetSubcategory = currentSubcategory) {
        LoadCategories()
        GuiControl,, CategoryList, %SavePresetName%
    }
    
    SB_SetText("Шаблон сохранен: " . SavePresetName . " в " . targetCategory . " → " . targetSubcategory, 1)
return

SavePresetCancel:
    Gui, SaveDialog:Destroy
    Gui, 1:Default
return

SaveDialogGuiClose:
    Gui, SaveDialog:Destroy
    Gui, 1:Default
return

; === Новая функция: Удаление модели трансформера ===
; === Создать новый шаблон ===
CreateTemplate:
    InputBox, templateName, Создать шаблон, Введите имя нового шаблона:, , 300, 140
    if (ErrorLevel || templateName = "")
        return
    
    ; Создаем пустой файл
    global templatesDir
    filePath := templatesDir . "\" . templateName . ".txt"
    if (FileExist(filePath)) {
        MsgBox, 48, Ошибка, Шаблон с таким именем уже существует!
        return
    }
    
    FileAppend, , %filePath%, UTF-8
    LoadTemplates()
    
    ; Находим и выделяем новый шаблон в ListView
    Gui, 1:Default
    Gui, ListView, TemplateList
    Loop % LV_GetCount()
    {
        LV_GetText(name, A_Index)
        if (name = templateName) {
            LV_Modify(A_Index, "Select Focus")
            break
        }
    }
    
    Gosub, TemplateSelected
    MsgBox, 64, Успех, Шаблон "%templateName%" создан!`n`nОткройте файл в папке templates для редактирования.
return

; === Удалить шаблон генератора ===
DeleteGeneratorTemplate:
    Gui, 1:Default
    Gui, ListView, TemplateList
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0) {
        MsgBox, 48, Ошибка, Выберите шаблон для удаления!
        return
    }
    
    LV_GetText(templateName, focusedRow)
    
    MsgBox, 4, Удалить шаблон?, Удалить шаблон "%templateName%"?
    IfMsgBox, Yes
    {
        global templatesDir
        filePath := templatesDir . "\" . templateName . ".txt"
        FileDelete, %filePath%
        LoadTemplates()
        GuiControl,, TemplateContent,
        SB_SetText("Шаблон удалён", 1)
    }
return

; === Обновить список шаблонов ===
RefreshTemplates:
    LoadTemplates()
    SB_SetText("Список обновлён", 1)
return

; === Обновить список игнорируемых слов в UI ===
UpdateIgnoredWordsList() {
    global ignoredWords
    ; Устанавливаем ListView для работы
    Gui, 1:Default
    Gui, ListView, GenIgnoredList
    ; Очищаем список
    LV_Delete()
    ; Добавляем все слова
    for i, word in ignoredWords {
        LV_Add("", word)
    }
}

; === Обработчик выбора слова из списка ===
GenIgnoredSelected:
    ; Просто обновляем выбор, удаление происходит по кнопке
return

; === СТАРЫЕ ФУНКЦИИ CUSTOM WORDS УДАЛЕНЫ - ЗАМЕНЕНЫ НА НОВЫЕ ===
; (см. строки 11139+)

; === СТАРЫЕ ФУНКЦИИ CUSTOM WORDS УДАЛЕНЫ - ЗАМЕНЕНЫ НА НОВЫЕ ===
; (см. строки 11139+)

; === Обновить список собственных слов в ListView ===
UpdateCustomWordsList() {
    ; Эта функция заменена на UpdateCustomWordsListView() в новом коде
    UpdateCustomWordsListView()
}

; === Обработчик выбора собственного слова ===
CustomWordSelected:
    ; Просто обновляем выбор
return

; === Переключение типа скорости ===
UpdateSpeedType:
    Gui, 1:Submit, NoHide
    if (SpeedType = "Букв в секунду") {
        GuiControl,, SpeedUnit, букв/сек
        ; Показываем обычные поля скорости
        GuiControl, Show, SpeedInput
        GuiControl, Show, SpeedUnit
        ; Скрываем поля задержки буфера обмена
        GuiControl, Hide, ClipboardDelayLabel
        GuiControl, Hide, ClipboardDelayInput
        GuiControl, Hide, ClipboardDelayUnit
    }
    else if (SpeedType = "Слов в минуту") {
        GuiControl,, SpeedUnit, слов/мин
        ; Показываем обычные поля скорости
        GuiControl, Show, SpeedInput
        GuiControl, Show, SpeedUnit
        ; Скрываем поля задержки буфера обмена
        GuiControl, Hide, ClipboardDelayLabel
        GuiControl, Hide, ClipboardDelayInput
        GuiControl, Hide, ClipboardDelayUnit
    }
    else if (SpeedType = "Интервал" || SpeedType = "Задержка") {
        GuiControl,, SpeedUnit, мс
        ; Показываем обычные поля скорости
        GuiControl, Show, SpeedInput
        GuiControl, Show, SpeedUnit
        ; Скрываем поля задержки буфера обмена
        GuiControl, Hide, ClipboardDelayLabel
        GuiControl, Hide, ClipboardDelayInput
        GuiControl, Hide, ClipboardDelayUnit
    }
    else if (SpeedType = "Вставка через буфер обмена") {
        ; Скрываем обычные поля скорости
        GuiControl, Hide, SpeedInput
        GuiControl, Hide, SpeedUnit
        ; Показываем поля для задержки буфера обмена
        GuiControl, Show, ClipboardDelayLabel
        GuiControl, Show, ClipboardDelayInput
        GuiControl, Show, ClipboardDelayUnit
    }
return

; === Тестовая генерация из шаблона ===
; === Переключение типа генерации ===
UpdateGenType:
    Gui, 1:Submit, NoHide
    if (GenByLines) {
        ; Показываем поля для строк
        GuiControl, Show, GenLineCountLabel
        GuiControl, Show, GenLineCount
        GuiControl, Show, GenLineCountHint
        ; Скрываем поля для слов
        GuiControl, Hide, GenWordCountLabel
        GuiControl, Hide, GenWordCount
        GuiControl, Hide, GenWordCountHint
    } else {
        ; Скрываем поля для строк
        GuiControl, Hide, GenLineCountLabel
        GuiControl, Hide, GenLineCount
        GuiControl, Hide, GenLineCountHint
        ; Показываем поля для слов
        GuiControl, Show, GenWordCountLabel
        GuiControl, Show, GenWordCount
        GuiControl, Show, GenWordCountHint
    }
    ; Проверяем режим генерации для показа дополнительных полей
    Gosub, UpdateGenerationMode
return

UpdateGenerationMode:
    Gui, 1:Submit, NoHide
    if (GenerationMode = "Построчно с параметрами") {
        ; Показываем кнопку настроек для построчной генерации
        GuiControl, Show, GenCustomSettingsBtn
        ; Скрываем стандартные поля
        GuiControl, Hide, GenLineCountLabel
        GuiControl, Hide, GenLineCount
        GuiControl, Hide, GenLineCountHint
        GuiControl, Hide, GenWordCountLabel
        GuiControl, Hide, GenWordCount
        GuiControl, Hide, GenWordCountHint
    } else {
        ; Скрываем кнопку настроек
        GuiControl, Hide, GenCustomSettingsBtn
    }
return

; Открыть настройки построчной генерации
OpenCustomGenSettings:
    global GenCustomLines, GenCustomWordsPerLine
    
    ; Инициализируем значения по умолчанию если не заданы
    if (GenCustomLines = "")
        GenCustomLines := 5
    if (GenCustomWordsPerLine = "")
        GenCustomWordsPerLine := 10
    
    Gui, CustomGenDialog:New, -Resize, Настройки построчной генерации
    Gui, CustomGenDialog:Font, s9, Segoe UI
    
    Gui, CustomGenDialog:Add, Text, x10 y10, Количество строк для генерации:
    Gui, CustomGenDialog:Add, Edit, vCustomGenLines x10 y30 w260 Number, %GenCustomLines%
    
    Gui, CustomGenDialog:Add, Text, x10 y60, Количество слов на строку:
    Gui, CustomGenDialog:Add, Edit, vCustomGenWordsPerLine x10 y80 w260 Number, %GenCustomWordsPerLine%
    
    Gui, CustomGenDialog:Add, Button, x10 y120 w125 h30 gCustomGenDialogOK, ✓ Сохранить
    Gui, CustomGenDialog:Add, Button, x145 y120 w125 h30 gCustomGenDialogCancel, ✗ Отмена
    
    Gui, CustomGenDialog:Show, w280 h160
return

CustomGenDialogOK:
    Gui, CustomGenDialog:Submit
    global GenCustomLines := CustomGenLines
    global GenCustomWordsPerLine := CustomGenWordsPerLine
    Gui, CustomGenDialog:Destroy
    Gui, 1:Default
    MsgBox, 64, Успех, Настройки сохранены!`nСтрок: %GenCustomLines%`nСлов на строку: %GenCustomWordsPerLine%
return

CustomGenDialogCancel:
CustomGenDialogGuiClose:
    Gui, CustomGenDialog:Destroy
    Gui, 1:Default
return

TestGeneration:
    Gui, 1:Submit, NoHide
    global genCurrentTemplate, genCurrentCategory, genCurrentSubcategory, genTemplatesDir
    global currentTemplate, templatesDir
    
    generatedText := ""
    
    ; Отладка: показываем текущие значения переменных
    ; MsgBox, Отладка:`ngenCurrentTemplate: %genCurrentTemplate%`ngenCurrentCategory: %genCurrentCategory%`ngenCurrentSubcategory: %genCurrentSubcategory%
    
    ; Проверяем, выбран ли шаблон в новой системе
    if (genCurrentTemplate != "" && genCurrentCategory != "" && genCurrentSubcategory != "") {
        ; Используем новую систему генерации
        generatedText := GenerateTextNew()
    } 
    ; Fallback на старую систему
    else if (currentTemplate != "") {
        generatedText := GenerateFromTemplate()
    }
    else {
        ; Ни один шаблон не выбран
        MsgBox, 48, Ошибка, Выберите шаблон!`n`nОткройте категорию → подкатегорию → выберите шаблон из списка.`n`nТекущие значения:`nШаблон: %genCurrentTemplate%`nКатегория: %genCurrentCategory%`nПодкатегория: %genCurrentSubcategory%
        return
    }
    
    if (generatedText != "") {
        GuiControl,, TestGenOutput, %generatedText%
        SB_SetText("Тест выполнен", 1)
    } else {
        GuiControl,, TestGenOutput, [Ошибка генерации - проверьте шаблон и настройки]
        MsgBox, 48, Ошибка, Не удалось сгенерировать текст!`n`nПроверьте:`n- Выбран ли шаблон`n- Есть ли содержимое в шаблоне`n- Правильно ли настроен режим генерации
    }
return

; === Копировать результат генерации в буфер обмена ===
CopyGenToClipboard:
    Gui, 1:Submit, NoHide
    if (TestGenOutput = "") {
        MsgBox, 48, Ошибка, Нет результата для копирования! Сначала выполните генерацию.
        return
    }
    Clipboard := TestGenOutput
    SB_SetText("Результат скопирован в буфер обмена", 1)
return

; === Добавить результат генерации в основной текст ===
AddGenToMainText:
    Gui, 1:Submit, NoHide
    if (TestGenOutput = "") {
        MsgBox, 48, Ошибка, Нет результата для добавления! Сначала выполните генерацию.
        return
    }
    GuiControlGet, currentText,, TypeText
    if (currentText != "") {
        newText := currentText . "`n" . TestGenOutput
    } else {
        newText := TestGenOutput
    }
    GuiControl,, TypeText, %newText%
    SB_SetText("Результат добавлен в основной текст", 1)
return

; === Добавить результат генерации в разбивку текста ===
AddGenToSplitText:
    Gui, 1:Submit, NoHide
    if (TestGenOutput = "") {
        MsgBox, 48, Ошибка, Нет результата для добавления! Сначала выполните генерацию.
        return
    }
    GuiControlGet, currentSplitText,, SplitManualInput
    if (currentSplitText != "") {
        newSplitText := currentSplitText . "`n" . TestGenOutput
    } else {
        newSplitText := TestGenOutput
    }
    GuiControl,, SplitManualInput, %newSplitText%
    SB_SetText("Результат добавлен в разбивку текста", 1)
return

; === Генерация текста из шаблона ===
GenerateFromTemplate() {
    global currentTemplate, templatesDir, GenerationMode, GenLineCount, GenWordCount, GenByLines, GenByWords, GenCapitalize, GenPunctuation, GenTranslit, ignoredWords, GenCustomLines, GenCustomWordsPerLine, GenCountValue
    
    if (currentTemplate = "") {
        return ""
    }
    
    ; Загружаем шаблоны (поддержка нескольких через |)
    fullContent := ""
    templateList := StrSplit(currentTemplate, "|")
    for index, tName in templateList {
        FileRead, content, %templatesDir%\%tName%.txt
        if (!ErrorLevel) {
            fullContent .= (fullContent = "" ? "" : "`n") . content
        }
    }
    
    if (fullContent = "") {
        return ""
    }
    
    content := fullContent
    
    ; Определяем режим генерации
    Gui, 1:Submit, NoHide
    generateByWords := GenByWords ? true : false
    
    ; Обновляем GenWordCount и GenLineCount из GenCountValue
    if (generateByWords) {
        GenWordCount := GenCountValue
    } else {
        GenLineCount := GenCountValue
    }
    
    ; Специальный режим: Построчно с параметрами
    if (GenerationMode = "Построчно с параметрами") {
        return GenerateCustomLineMode(content)
    }
    
    if (generateByWords) {
        ; Генерация по словам - берем строки и объединяем в текст, затем извлекаем N слов
        
        ; Собираем все строки из шаблона
        allLines := []
        Loop, Parse, content, `n, `r
        {
            line := Trim(A_LoopField)
            if (line != "") {
                allLines.Push(line)
            }
        }
        
        if (allLines.Length() = 0) {
            return ""
        }
        
        ; Определяем количество слов для генерации
        wordCount := (GenCountValue > 0) ? GenCountValue : 10
        
        ; Выбираем и объединяем строки в зависимости от режима генерации
        combinedText := ""
        
        if (GenerationMode = "Случайная строка") {
            ; Берем случайные строки пока не наберем нужное количество слов
            Loop {
                Random, idx, 1, % allLines.Length()
                combinedText .= (combinedText ? " " : "") . allLines[idx]
                
                ; Подсчитываем слова в объединенном тексте
                wordArray := StrSplit(combinedText, " ")
                if (wordArray.Length() >= wordCount)
                    break
            }
        }
        else if (GenerationMode = "Последовательно") {
            ; Берем строки последовательно
            for idx, line in allLines {
                combinedText .= (combinedText ? " " : "") . line
                
                wordArray := StrSplit(combinedText, " ")
                if (wordArray.Length() >= wordCount)
                    break
            }
        }
        else if (GenerationMode = "Случайный порядок") {
            ; Берем случайные строки
            Loop {
                Random, idx, 1, % allLines.Length()
                combinedText .= (combinedText ? " " : "") . allLines[idx]
                
                wordArray := StrSplit(combinedText, " ")
                if (wordArray.Length() >= wordCount)
                    break
            }
        }
        else if (GenerationMode = "Без повторов") {
            ; Берем строки без повторов
            usedIndices := []
            Loop {
                if (usedIndices.Length() >= allLines.Length())
                    break
                    
                Loop {
                    Random, idx, 1, % allLines.Length()
                    if (!Contains(usedIndices, idx)) {
                        usedIndices.Push(idx)
                        combinedText .= (combinedText ? " " : "") . allLines[idx]
                        break
                    }
                }
                
                wordArray := StrSplit(combinedText, " ")
                if (wordArray.Length() >= wordCount)
                    break
            }
        }
        else if (GenerationMode = "По строкам" || GenerationMode = "Бесконечность") {
            ; Берем строки последовательно или случайно
            Loop {
                Random, idx, 1, % allLines.Length()
                combinedText .= (combinedText ? " " : "") . allLines[idx]
                
                wordArray := StrSplit(combinedText, " ")
                if (wordArray.Length() >= wordCount)
                    break
            }
        }
        else {
            ; По умолчанию - случайные строки
            Loop {
                Random, idx, 1, % allLines.Length()
                combinedText .= (combinedText ? " " : "") . allLines[idx]
                
                wordArray := StrSplit(combinedText, " ")
                if (wordArray.Length() >= wordCount)
                    break
            }
        }
        
        ; Извлекаем ровно N слов из объединенного текста
        allWords := []
        Loop, Parse, combinedText, %A_Space%
        {
            word := Trim(A_LoopField)
            if (word != "") {
                ; Проверяем, не является ли слово игнорируемым
                if (!IsIgnoredWord(word, ignoredWords)) {
                    allWords.Push(word)
                    if (allWords.Length() >= wordCount)
                        break
                }
            }
        }
        
        ; Собираем результат
        result := ""
        for i, word in allWords {
            result .= (result ? " " : "") . word
        }
    } else {
        ; Генерация по строкам (старый режим)
        ; Разбиваем на строки и фильтруем игнорируемые слова
        lines := []
        Loop, Parse, content, `n, `r
        {
            line := Trim(A_LoopField)
            if (line != "") {
                ; Фильтруем игнорируемые слова из строки
                filteredLine := FilterIgnoredWordsFromLine(line, ignoredWords)
                if (filteredLine != "")
                    lines.Push(filteredLine)
            }
        }
        
        if (lines.Length() = 0) {
            return ""
        }
        
        ; Определяем количество строк для генерации
        lineCount := (GenCountValue > 0) ? GenCountValue : 1
        if (lineCount > lines.Length())
            lineCount := lines.Length()
        
        result := ""
        usedIndices := []
        
        ; Генерируем текст в зависимости от режима
        if (GenerationMode = "Случайная строка") {
            ; Случайная строка
            Random, idx, 1, % lines.Length()
            result := lines[idx]
        }
        else if (GenerationMode = "Последовательно") {
            ; Последовательно с начала
            Loop, %lineCount% {
                if (A_Index <= lines.Length())
                    result .= (result ? " " : "") . lines[A_Index]
            }
        }
        else if (GenerationMode = "Случайный порядок") {
            ; Случайный порядок
            Loop, %lineCount% {
                Random, idx, 1, % lines.Length()
                result .= (result ? " " : "") . lines[idx]
            }
        }
        else if (GenerationMode = "Без повторов") {
            ; Без повторов
            Loop, %lineCount% {
                if (usedIndices.Length() >= lines.Length())
                    break
                Loop {
                    Random, idx, 1, % lines.Length()
                    if (!Contains(usedIndices, idx)) {
                        usedIndices.Push(idx)
                        result .= (result ? " " : "") . lines[idx]
                        break
                    }
                }
            }
        }
        else if (GenerationMode = "По строкам") {
            ; По строкам - случайный выбор строк, каждая строка на новой строке
            Loop, %lineCount% {
                Random, idx, 1, % lines.Length()
                result .= (result ? "`n" : "") . lines[idx]
            }
        }
        else if (GenerationMode = "Бесконечность") {
            ; Бесконечность - генерируем указанное количество строк случайным образом
            Loop, %lineCount% {
                ; Случайный выбор строки из всех доступных
                Random, idx, 1, % lines.Length()
                result .= (result ? "`n" : "") . lines[idx]
            }
        }
        else {
            ; По умолчанию - случайная строка
            Random, idx, 1, % lines.Length()
            result := lines[idx]
        }
    }
    
    ; Добавляем custom-слова в результат
    global customWords
    if (customWords.Length() > 0) {
        ; Собираем активные custom-слова
        activeWords := []
        for i, item in customWords {
            if (item.enabled) {
                activeWords.Push(item.word)
            }
        }
        
        ; Если есть активные слова, добавляем их случайным образом
        if (activeWords.Length() > 0) {
            ; Вставляем 1-3 custom-слова в случайные позиции
            Random, insertCount, 1, 3
            if (insertCount > activeWords.Length())
                insertCount := activeWords.Length()
            
            ; Разбиваем результат на слова
            resultWords := StrSplit(result, " ")
            
            Loop, %insertCount% {
                ; Выбираем случайное custom-слово
                Random, wordIdx, 1, % activeWords.Length()
                customWord := activeWords[wordIdx]
                
                ; Вставляем в случайную позицию
                if (resultWords.Length() > 0) {
                    Random, pos, 1, % resultWords.Length() + 1
                    resultWords.InsertAt(pos, customWord)
                } else {
                    resultWords.Push(customWord)
                }
            }
            
            ; Собираем слова обратно в строку
            result := ""
            for i, word in resultWords {
                result .= (result ? " " : "") . word
            }
        }
    }
    
    ; Применяем форматирование
    if (GenCapitalize) {
        StringUpper, firstChar, % SubStr(result, 1, 1)
        result := firstChar . SubStr(result, 2)
    }
    
    if (GenPunctuation && !RegExMatch(result, "[.!?]$")) {
        result .= "."
    }
    
    ; Применяем транслитерацию если включена
    if (GenTranslit) {
        result := Transliterate(result)
    }
    
    return result
}

; === Генерация в режиме "Построчно с параметрами" ===
GenerateCustomLineMode(content) {
    global GenCustomLines, GenCustomWordsPerLine, GenCapitalize, GenPunctuation, GenTranslit, ignoredWords
    
    ; Получаем параметры
    Gui, 1:Submit, NoHide
    linesCount := (GenCustomLines > 0) ? GenCustomLines : 5
    wordsPerLine := (GenCustomWordsPerLine > 0) ? GenCustomWordsPerLine : 10
    
    ; Собираем все строки из шаблона
    allSourceLines := []
    Loop, Parse, content, `n, `r
    {
        line := Trim(A_LoopField)
        if (line != "") {
            allSourceLines.Push(line)
        }
    }
    
    if (allSourceLines.Length() = 0) {
        return ""
    }
    
    ; Генерируем указанное количество строк
    resultLines := []
    
    Loop, %linesCount% {
        ; Для каждой строки генерируем нужное количество слов
        lineWords := []
        wordsCollected := 0
        
        ; Берем случайные строки из шаблона и извлекаем из них слова
        while (wordsCollected < wordsPerLine) {
            Random, idx, 1, % allSourceLines.Length()
            sourceLine := allSourceLines[idx]
            
            ; Разбиваем строку на слова
            Loop, Parse, sourceLine, %A_Space%
            {
                word := Trim(A_LoopField)
                if (word != "" && !IsIgnoredWord(word, ignoredWords)) {
                    lineWords.Push(word)
                    wordsCollected++
                    if (wordsCollected >= wordsPerLine)
                        break
                }
            }
        }
        
        ; Собираем слова в строку
        generatedLine := ""
        for i, word in lineWords {
            generatedLine .= (generatedLine ? " " : "") . word
        }
        
        ; Применяем форматирование к строке
        if (GenCapitalize && generatedLine != "") {
            StringUpper, firstChar, % SubStr(generatedLine, 1, 1)
            generatedLine := firstChar . SubStr(generatedLine, 2)
        }
        
        if (GenPunctuation && generatedLine != "" && !RegExMatch(generatedLine, "[.!?]$")) {
            generatedLine .= "."
        }
        
        ; Применяем транслитерацию если включена
        if (GenTranslit && generatedLine != "") {
            translitLine := ""
            Loop, Parse, generatedLine
            {
                translitLine .= TranslitChar(A_LoopField)
            }
            generatedLine := translitLine
        }
        
        resultLines.Push(generatedLine)
    }
    
    ; Собираем все строки в результат
    result := ""
    for i, line in resultLines {
        result .= (result ? "`n" : "") . line
    }
    
    return result
}

; === Функция загрузки шаблонов ===
LoadTemplates() {
    global templatesDir
    
    ; Создаем папку для шаблонов если не существует
    if (!FileExist(templatesDir))
        FileCreateDir, %templatesDir%
    
    Gui, 1:Default
    Gui, ListView, TemplateList
    LV_Delete()
    templateCount := 0
    Loop, Files, %templatesDir%\*.txt
    {
        name := RegExReplace(A_LoopFileName, "\.txt$")
        LV_Add("", name)
        templateCount++
    }
    LV_ModifyCol(1, 400)
    SB_SetText("Шаблонов: " . templateCount, 2)
}

; === Получить выбранные шаблоны ===
GetSelectedTemplates() {
    Gui, 1:Default
    Gui, ListView, TemplateList
    checkedTemplates := ""
    RowNumber := 0
    Loop
    {
        RowNumber := LV_GetNext(RowNumber, "Checked")
        if not RowNumber
            break
        LV_GetText(tName, RowNumber)
        checkedTemplates .= (checkedTemplates = "" ? "" : "|") . tName
    }
    if (checkedTemplates = "") {
        focusedRow := LV_GetNext(0, "Focused")
        if (focusedRow != 0) {
            LV_GetText(checkedTemplates, focusedRow)
        }
    }
    return checkedTemplates
}

; === Выбор шаблона ===
TemplateSelected:
    if (A_GuiEvent != "Normal" && A_GuiEvent != "K")
        return
        
    Gui, 1:Default
    Gui, ListView, TemplateList
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0) {
        GuiControl,, TemplateContent,
        return
    }
    
    LV_GetText(selectedName, focusedRow)
    
    ; Загружаем содержимое выбранного шаблона
    global templatesDir, currentTemplate
    
    FileRead, templateContent, %templatesDir%\%selectedName%.txt
    if (ErrorLevel) {
        return
    }
    
    ; Показываем содержимое в окне
    GuiControl,, TemplateContent, %templateContent%
    
    ; Подсчитываем строки
    lines := StrSplit(templateContent, "`n")
    lineCount := 0
    for index, line in lines {
        if (Trim(line) != "")
            lineCount++
    }
    
    SB_SetText("Строк в шаблоне: " . lineCount, 2)
return

; === Загрузка шаблона ===
LoadTemplate:
    checkedTemplates := GetSelectedTemplates()
    
    if (checkedTemplates = "") {
        MsgBox, 48, Ошибка, Выберите хотя бы один шаблон (отметьте галочкой)!
        return
    }
    
    global currentTemplate, templatesDir
    currentTemplate := checkedTemplates
    
    fullContent := ""
    totalLineCount := 0
    templateList := StrSplit(checkedTemplates, "|")
    for index, tName in templateList {
        FileRead, content, %templatesDir%\%tName%.txt
        if (!ErrorLevel) {
            fullContent .= (fullContent = "" ? "" : "`n") . content
        }
    }
    
    ; Показываем содержимое в окне
    GuiControl,, TemplateContent, %fullContent%
    
    ; Подсчитываем строки
    lines := StrSplit(fullContent, "`n")
    for index, line in lines {
        if (Trim(line) != "")
            totalLineCount++
    }
    
    SB_SetText("Выбрано шаблонов: " . templateList.MaxIndex() . " (Строк: " . totalLineCount . ")", 2)
    SB_SetText("Шаблоны загружены", 1)
return

; === Новая функция: Пауза печати ===
PauseTyping:
    isTyping := !isTyping
    if (isTyping) {
        SetTimer, DoAutoType, -50
        SB_SetText("Продолжено", 3)
    } else {
        SB_SetText("На паузе", 3)
    }
return


; === Очистка текста ===
CleanText(text) {
    ; Удаляем лишние пробелы и знаки препинания
    text := RegExReplace(text, "[^\w\sа-яА-ЯёЁ]", " ")
    text := RegExReplace(text, "\s+", " ")
    text := Trim(text)
    return text
}

; === Добавление ошибок в текст (старая функция) ===
AddErrors(text, level) {
    ; Новая модель ошибок: перестановка букв в словах
    if (level = "Нет")
        return text

    ; Разбиваем текст на слова (сохраняя пробелы и знаки препинания)
    words := StrSplit(text, " ")
    result := ""

    for i, word in words {
        if (word = "") {
            result .= (result ? " " : "") . word
            continue
        }

        ; Обрабатываем каждое слово
        mutated := ShuffleWordByLevel(word, level)
        result .= (result ? " " : "") . mutated
    }

    ; Apply readability transform if set in GUI (separate control)
    global Readability
    if (Readability != "" && Readability != "Обычная читаемость")
        result := ApplyReadability(result, Readability)

    return result
}

; === Сохранить форматирование слова (регистр и знаки препинания) ===
PreserveWordFormat(originalWord, newWord) {
    ; Сохраняем знаки препинания из оригинала
    prefix := ""
    suffix := ""
    
    ; Извлекаем префикс (знаки препинания в начале)
    RegExMatch(originalWord, "^([^\w\p{L}]+)", prefixMatch)
    if (prefixMatch)
        prefix := prefixMatch1
    
    ; Извлекаем суффикс (знаки препинания в конце)
    RegExMatch(originalWord, "([^\w\p{L}]+)$", suffixMatch)
    if (suffixMatch)
        suffix := suffixMatch1
    
    ; Сохраняем регистр первой буквы
    StringUpper, firstChar, % SubStr(originalWord, StrLen(prefix) + 1, 1)
    StringLower, restWord, % SubStr(newWord, 1, 1)
    
    if (firstChar = SubStr(originalWord, StrLen(prefix) + 1, 1)) {
        ; Первая буква была заглавной
        StringUpper, firstNewChar, % SubStr(newWord, 1, 1)
        result := prefix . firstNewChar . SubStr(newWord, 2) . suffix
    } else {
        result := prefix . newWord . suffix
    }
    
    return result
}

; === Перемешивание слова по уровню ошибок ===
ShuffleWordByLevel(word, level) {
    ; Извлекаем только буквы из слова
    letters := []
    nonLetters := {}
    positions := []
    idx := 1
    
    Loop, Parse, word
    {
        ch := A_LoopField
        if (RegExMatch(ch, "[A-Za-zА-Яа-яЁё]")) {
            letters.Push(ch)
            positions.Push(idx)
        } else {
            nonLetters[idx] := ch
        }
        idx++
    }
    
    letterCount := letters.Length()
    if (letterCount <= 1)
        return word
    
    ; Применяем перестановки в зависимости от уровня
    if (level = "Лёгкий") {
        ; Лёгкий: перестановка 1-2 соседних букв
        ; Пример: Привет -> Приевт, дела -> деал, делаешь -> делашеь
        if (letterCount >= 2) {
            ; Переставляем 1-2 пары соседних букв
            swaps := (letterCount >= 4) ? 2 : 1
            Loop % swaps {
                ; Выбираем случайную позицию (не первая и не последняя)
                start := 1
                end := letterCount - 1
                if (end > start) {
                    Random, pos, %start%, %end%
                    ; Переставляем буквы на позициях pos и pos+1
                    tmp := letters[pos]
                    letters[pos] := letters[pos + 1]
                    letters[pos + 1] := tmp
                }
            }
        }
    }
    else if (level = "Средний") {
        ; Средний: более сильные перестановки (2-3 буквы)
        ; Пример: Привет -> Преивт, как -> ака, дела -> елад, что -> отч, делаешь -> деалшеь
        if (letterCount >= 3) {
            ; Переставляем несколько букв внутри слова
            swaps := Min(3, Round(letterCount * 0.4))
            Loop % swaps {
                Random, i1, 1, %letterCount%
                Random, i2, 1, %letterCount%
                if (i1 != i2) {
                    tmp := letters[i1]
                    letters[i1] := letters[i2]
                    letters[i2] := tmp
                }
            }
        }
    }
    else if (level = "Высокий") {
        ; Высокий: еще более сильные перестановки (3-4 буквы)
        ; Пример: Привет -> Рпеивт, как -> ака, дела -> елад, что -> отч, делаешь -> еалшьед
        if (letterCount >= 3) {
            ; Переставляем больше букв
            swaps := Min(4, Round(letterCount * 0.6))
            Loop % swaps {
                Random, i1, 1, %letterCount%
                Random, i2, 1, %letterCount%
                if (i1 != i2) {
                    tmp := letters[i1]
                    letters[i1] := letters[i2]
                    letters[i2] := tmp
                }
            }
        }
    }
    else if (level = "Экстремальный") {
        ; Экстремальный: полная перестановка всех букв в слове
        ; Пример: Привет -> Евитрп, как -> акк, дела -> адле, что -> отч, делаешь -> ашльедл
        ; Перемешиваем все буквы кроме первой (если слово длинное)
        if (letterCount >= 2) {
            ; Полная перестановка всех букв
            Loop % letterCount {
                i := A_Index
                Random, j, %i%, %letterCount%
                tmp := letters[i]
                letters[i] := letters[j]
                letters[j] := tmp
            }
        }
    }
    
    ; Собираем слово обратно, сохраняя небуквенные символы
    result := ""
    letterIdx := 1
    
    Loop, Parse, word
    {
        ch := A_LoopField
        if (RegExMatch(ch, "[A-Za-zА-Яа-яЁё]")) {
            ; Это буква - берем из перемешанного массива
            if (letterIdx <= letters.Length()) {
                result .= letters[letterIdx]
                letterIdx++
            } else {
                result .= ch
            }
        } else {
            ; Это небуквенный символ - сохраняем как есть
            result .= ch
        }
    }
    
    return result
}

; === Перемешивание букв в словах ===
ShuffleText(text, level) {
    if (level <= 1)
        return text

    result := ""
    words := StrSplit(text, " ")
    for i, word in words {
        if (word = "") {
            result .= (result ? " " : "") . word
            continue
        }
        shuffled := ShuffleWord(word, level)
        result .= (result ? " " : "") . shuffled
    }
    return result
}

ShuffleWord(word, level) {
    global ShuffleRandomMode, ShuffleLowProb, ShuffleMediumBehavior, ShuffleHighSuffixProb, ShuffleHighSuffixCount, ShuffleExtremeMode
    ; Нормализуем значения из GUI (DropDownList -> локальные числовые/флаговые переменные)
    ; ShuffleRandomMode: "Выключено"|"Включено"
    localRand := 0
    if (ShuffleRandomMode = "Включено" || ShuffleRandomMode = "1" || ShuffleRandomMode = 1)
        localRand := 1

    ; ShuffleLowProb: Редко|Обычно|Часто|Очень часто -> проценты
    lowProb := 30
    if (ShuffleLowProb = "Редко")
        lowProb := 10
    else if (ShuffleLowProb = "Обычно")
        lowProb := 30
    else if (ShuffleLowProb = "Часто")
        lowProb := 60
    else if (ShuffleLowProb = "Очень часто")
        lowProb := 90
    else
        lowProb := ShuffleLowProb + 0

    ; ShuffleMediumBehavior: Влево|Вправо|Дублировать первую букву
    medBehavior := 1
    if (ShuffleMediumBehavior = "Влево")
        medBehavior := 1
    else if (ShuffleMediumBehavior = "Вправо")
        medBehavior := 2
    else if (ShuffleMediumBehavior = "Дублировать первую букву")
        medBehavior := 3

    ; ShuffleHighSuffixProb: Никогда|Редко|Обычно|Часто -> проценты
    highProb := 30
    if (ShuffleHighSuffixProb = "Никогда")
        highProb := 0
    else if (ShuffleHighSuffixProb = "Редко")
        highProb := 20
    else if (ShuffleHighSuffixProb = "Обычно")
        highProb := 50
    else if (ShuffleHighSuffixProb = "Часто")
        highProb := 80
    else
        highProb := ShuffleHighSuffixProb + 0

    ; ShuffleHighSuffixCount: numeric string
    highCount := ShuffleHighSuffixCount + 0

    ; ShuffleExtremeMode: Реверс|Полная перестановка
    extMode := 1
    if (ShuffleExtremeMode = "Реверс")
        extMode := 1
    else if (ShuffleExtremeMode = "Полная перестановка")
        extMode := 2
    ; Собираем буквы и их позиции, сохраняя небуквенные символы на местах
    letters := []
    positions := []
    nonLetters := {}
    idx := 1
    Loop, Parse, word
    {
        ch := A_LoopField
        if (RegExMatch(ch, "[A-Za-zА-Яа-яЁё]")) {
            letters.Push(ch)
            positions.Push(idx)
        } else {
            nonLetters[idx] := ch
        }
        idx++
    }

    letterCount := letters.Length()
    if (letterCount <= 1)
        return word

    ; Сохраним информацию о капитализации для корректного восстановления
    firstIsUpper := RegExMatch(SubStr(word, 1, 1), "[A-ZА-ЯЁ]")
    onlyFirstUpper := RegExMatch(word, "^[A-ZА-ЯЁ][a-zа-яё]+$")

    ; Новый поведенческий набор уровней для перемешивателя (соответствует примерам пользователя)
    ; level mapping: 2=Низкий, 3=Средний, 4=Высокий, 5=Экстремальный

    ; Если включен режим случайного перемешивания — выполняем рандомные свапы
    if (localRand = 1) {
        swaps := 0
        if (level = 2)
            swaps := Max(1, Round(letterCount * (lowProb / 100.0)))
        else if (level = 3)
            swaps := Max(1, Round(letterCount * (lowProb / 100.0) * 1.5))
        else if (level = 4)
            swaps := Max(1, Round(letterCount * (lowProb / 100.0) * 2))
        else if (level = 5)
            swaps := Max(1, Round(letterCount * (lowProb / 100.0) * 3))

        Loop % swaps {
            start := (letterCount > 2) ? 2 : 1
            end := letterCount
            Random, i1, %start%, %end%
            Random, i2, %start%, %end%
            tmp := letters[i1]
            letters[i1] := letters[i2]
            letters[i2] := tmp
        }
    }
    else {
        if (level = 2) {
            ; Низкий: одна соседняя перестановка внутри слова с настраиваемой вероятностью
            Random, rchance, 1, 100
            if (letterCount <= 3 || rchance > lowProb)
                return word

            start := 2, end := letterCount - 1
            if (start > end)
                return word
            Random, idx, %start%, %end%
            i1 := idx
            i2 := (idx < letterCount ? idx + 1 : idx)
            tmp := letters[i1]
            letters[i1] := letters[i2]
            letters[i2] := tmp
        }
        else if (level = 3) {
            ; Средний: поведение определяется слайдером
            if (letterCount <= 3) {
                ; короткие слова: дублирование первой буквы если выбрано (3), иначе простая перестановка
                if (medBehavior = 3) {
                    first := letters[1]
                    letters.InsertAt(first, 2)
                } else {
                    Random, i1, 1, %letterCount%
                    Random, i2, 1, %letterCount%
                    tmp := letters[i1]
                    letters[i1] := letters[i2]
                    letters[i2] := tmp
                }
            } else {
                internal := []
                Loop % (letterCount - 2) {
                    internal.Push(letters[A_Index + 1])
                }
                if (medBehavior = 1) {
                    ; ротация влево
                    firstInternal := internal[1]
                    Loop % internal.Length()-1 {
                        internal[A_Index] := internal[A_Index + 1]
                    }
                    internal[internal.Length()] := firstInternal
                } else if (medBehavior = 2) {
                    ; ротация вправо
                    lastInternal := internal[internal.Length()]
                    Loop % internal.Length()-1 {
                        internal[internal.Length() - A_Index + 1] := internal[internal.Length() - A_Index]
                    }
                    internal[1] := lastInternal
                } else {
                    ; дублирование первой буквы внутренней части
                    firstInternal := internal[1]
                    internal.InsertAt(firstInternal, 2)
                }
                Loop % internal.Length() {
                    letters[A_Index + 1] := internal[A_Index]
                }
            }
        }
        else if (level = 4) {
            ; Высокий: частичная сильная перестановка внутренних букв
            if (letterCount <= 3) {
                Loop % letterCount {
                    i := A_Index
                    Random, j, %i%, % letterCount
                    tmp := letters[i]
                    letters[i] := letters[j]
                    letters[j] := tmp
                }
            } else {
                internal := []
                Loop % (letterCount - 2) {
                    internal.Push(letters[A_Index + 1])
                }
                ; перемешиваем внутренности
                Loop % internal.Length() {
                    i := A_Index
                    Random, j, %i%, % internal.Length()
                    tmp := internal[i]
                    internal[i] := internal[j]
                    internal[j] := tmp
                }
                Loop % internal.Length() {
                    letters[A_Index + 1] := internal[A_Index]
                }

                ; С вероятностью, заданной слайдером, перемещаем суффикс в начало
                Random, r, 1, 100
                if (r <= highProb && highCount > 0) {
                    cnt := Min(highCount, letterCount - 1)
                    moved := []
                    startMove := letterCount - cnt + 1
                    Loop % cnt {
                        moved.Push(letters[startMove + A_Index - 1])
                    }
                    newLetters := []
                    ; вставляем moved (сохраняя порядок)
                    Loop % moved.Length() {
                        newLetters.Push(moved[A_Index])
                    }
                    ; затем остаток
                    Loop % (letterCount - cnt) {
                        newLetters.Push(letters[A_Index])
                    }
                    letters := newLetters
                }
            }
        }
        else if (level = 5) {
            ; Экстремальный: выбор режима через слайдер
            if (letterCount <= 1)
                return word
            if (extMode = 1) {
                ; реверс
                rev := []
                Loop % letterCount {
                    rev.Push(letters[letterCount - A_Index + 1])
                }
                Loop % letterCount {
                    letters[A_Index] := rev[A_Index]
                }
            } else {
                ; полная случайная перестановка
                Loop % letterCount {
                    i := A_Index
                    Random, j, %i%, % letterCount
                    tmp := letters[i]
                    letters[i] := letters[j]
                    letters[j] := tmp
                }
            }
        }
    }

    ; Вставляем буквы обратно в исходные позиции
    newChars := {}
    for idx2, pos in positions {
        newChars[pos] := letters[idx2]
    }

    ; Собираем результат, вставляя небуквы на свои места
    out := ""
    totalLen := StrLen(word)
    Loop, % totalLen {
        pos := A_Index
        if (newChars.HasKey(pos))
            out .= newChars[pos]
        else if (nonLetters.HasKey(pos))
            out .= nonLetters[pos]
        else
            out .= SubStr(word, pos, 1)
    }

    ; Сохраняем капитализацию: если в оригинале только первая буква была заглавной — восстановим такую форму
    if (onlyFirstUpper) {
        firstChar := SubStr(out, 1, 1)
        rest := SubStr(out, 2)
        StringLower, rest, rest
        StringUpper, firstChar, firstChar
        out := firstChar . rest
    } else if (firstIsUpper) {
        ; если только первая была заглавной — но мы уже обработали above; здесь — сохраняем заглавную первую букву
        StringUpper, first, out, T
        out := first
    }

    return out
}

; Helpers for new error model
; Return integer random between min and max (inclusive)
Rand(min, max) {
    Random, _r, %min%, %max%
    return _r
}

; Reverse string (replacement for missing StrReverse)
StrReverse(s) {
    if (!s)
        return s
    res := ""
    Loop, % StrLen(s)
        res := SubStr(s, A_Index * -1 + StrLen(s) + 1, 1) . res
    return res
}

RandomTranspose(token, intensity := 1) {
    ; intensity controls how many transpositions (1..2)
    ; Preserve punctuation around word
    prefix := RegExReplace(token, "^([^[:alpha:]]*).*", "\1")
    suffix := RegExReplace(token, ".*([^[:alpha:]]*)$", "\1")
    core := RegExReplace(token, "^[^[:alpha:]]*(.*)[^[:alpha:]]*$", "\1")
    len := StrLen(core)
    if (len < 2)
        return token
    ops := (intensity >= 2) ? 2 : 1
    Loop % ops {
        pos := Rand(1, len - 1)
        core := SubStr(core, 1, pos - 1) . SubStr(core, pos + 1, 1) . SubStr(core, pos, 1) . (pos+2<=len ? SubStr(core, pos+2) : "")
    }
    return prefix . core . suffix
}

KeyboardSubstitute(token, force := 0) {
    ; Replace a character with nearby keyboard char (Cyrillic QWERTY mapping approximated)
    map := { "а":"ф", "б":"ю", "в":"ы", "г":"п", "д":"л", "е":"р", "ё":"е", "ж":"э", "з":"я", "и":"ш", "й":"й", "к":"о", "л":"д", "м":"ь", "н":"т", "о":"щ", "п":"з", "р":"к", "с":"ы", "т":"н", "у":"г", "ф":"а", "х":"й", "ц":"ц", "ч":"с", "ш":"и", "щ":"щ", "ъ":"ъ", "ы":"в", "ь":"м", "э":"ж", "ю":"б", "я":"з" }
    prefix := RegExReplace(token, "^([^[:alpha:]]*).*", "\1")
    suffix := RegExReplace(token, ".*([^[:alpha:]]*)$", "\1")
    core := RegExReplace(token, "^[^[:alpha:]]*(.*)[^[:alpha:]]*$", "\1")
    len := StrLen(core)
    if (len = 0)
        return token
    pos := Random(1, len)
    ch := SubStr(core, pos, 1)
    lower := ch
    if (map.HasKey(lower))
        newch := map[lower]
    else if (force)
        newch := SubStr("абвгдеёжзийклмнопрстуфхцчшщъыьэюя", Random(1, 33), 1)
    else
        return token
    core := SubStr(core, 1, pos - 1) . newch . SubStr(core, pos + 1)
    return prefix . core . suffix
}

MaybeInsertOrDelete(token) {
    ; randomly insert or delete a char inside token
    prefix := RegExReplace(token, "^([^[:alpha:]]*).*", "\1")
    suffix := RegExReplace(token, ".*([^[:alpha:]]*)$", "\1")
    core := RegExReplace(token, "^[^[:alpha:]]*(.*)[^[:alpha:]]*$", "\1")
    len := StrLen(core)
    if (len = 0)
        return token
    if (Random(1, 2) = 1) {
        ; delete
        pos := Random(1, len)
        core := SubStr(core, 1, pos - 1) . SubStr(core, pos + 1)
    } else {
        pos := Random(1, len)
        extra := SubStr("абвгдеёжзийклмнопрстуфхцчшщъыьэюя", Random(1, 33), 1)
        core := SubStr(core, 1, pos) . extra . SubStr(core, pos + 1)
    }
    return prefix . core . suffix
}

ShuffleInner(token, intensity := 0.5, preserveEnds := true) {
    ; Shuffle inner letters of token. intensity 0..1 controls randomness
    prefix := RegExReplace(token, "^([^[:alpha:]]*).*", "\1")
    suffix := RegExReplace(token, ".*([^[:alpha:]]*)$", "\1")
    core := RegExReplace(token, "^[^[:alpha:]]*(.*)[^[:alpha:]]*$", "\1")
    len := StrLen(core)
    if (len <= 2)
        return token
    first := SubStr(core,1,1)
    last := SubStr(core,len,1)
    middle := SubStr(core,2,len-2)
    arr := []
    Loop % StrLen(middle)
        arr.Push(SubStr(middle, A_Index, 1))
    ; shuffle according to intensity
    times := Ceil(arr.Length() * intensity)
    Loop % times {
        i := Random(1, arr.Length())
        j := Random(1, arr.Length())
        tmp := arr[i]
        arr[i] := arr[j]
        arr[j] := tmp
    }
    newMiddle := ""
    for k, v in arr
        newMiddle .= v
    if (preserveEnds)
        newCore := first . newMiddle . last
    else
        newCore := first . newMiddle . last
    return prefix . newCore . suffix
}

; Функция для расчета задержки буфера обмена
CalculateClipboardDelay() {
    Gui, 1:Submit, NoHide
    GuiControlGet, delayValue,, ClipboardDelayInput
    GuiControlGet, delayUnit,, ClipboardDelayUnit
    delayMs := delayValue ? delayValue : 0
    if (delayUnit = "сек")
        delayMs := delayValue * 1000
    else if (delayUnit = "мин")
        delayMs := delayValue * 60000
    return delayMs
}

ApplyReadability(text, level) {
    if (level = "Обычная читаемость")
        return text
    words := StrSplit(text, " ")
    out := ""
    for i, w in words {
        if (w = "") {
            out .= (out?" ":"") . w
            continue
        }
            if (level = "Средняя читаемость") {
                if (StrLen(RegExReplace(w,"[^[:alpha:]]","")) > 3 && Random(1,100) <= 30)
                nw := ShuffleInner(w, 0.4)
            else
                nw := w
        } else if (level = "Сложно читать") {
            nw := ShuffleInner(w, 0.6)
        } else if (level = "Очень сложно читать") {
            nw := ShuffleInner(w, 0.9, false)
        } else if (level = "Невозможно читать") {
            ; heavy: reverse and shuffle
            nw := StrReverse(w)
            nw := ShuffleInner(nw, 0.9, false)
        } else
            nw := w
        out .= (out?" ":"") . nw
    }
    return out
}

; === Изменение регистра текста ===
ChangeTextCase(text, case) {
    if (case = "Обычный")
        return text
    else if (case = "ВЕРХНИЙ")
    {
        StringUpper, text, text
        return text
    }
    else if (case = "нижний")
    {
        StringLower, text, text
        return text
    }
    else if (case = "Случайный")
    {
        result := ""
        Loop, Parse, text
        {
            if (Random(1, 2) = 1)
                result .= Format("{:U}", A_LoopField)
            else
                result .= Format("{:L}", A_LoopField)
        }
        return result
    }
    return text
}

; Применение пользовательских вставок к тексту
ApplyCustomInserts(text) {
    global customInserts
    static alternateIndex := 1
    static variationIndices := {}  ; Хранит текущие индексы вариаций для каждой вставки
    
    if (customInserts.Length() = 0)
        return text
    
    ; Разбиваем текст на слова
    words := StrSplit(text, " ")
    wordCount := words.Length()
    
    if (wordCount = 0)
        return text
    
    ; Применяем каждую вставку
    for index, insertObj in customInserts {
        ; Пропускаем временно отключённые вставки
        if (insertObj.enabled = 0)
            continue
        
        ; Пропускаем вставки с неизвестными или недопустимыми позициями
        position := insertObj.position
        if (position = "" || position = "Общие") {
            continue
        }
        ; Выбираем текст для вставки (вариация или основной текст)
        insertText := insertObj.text
        if (insertObj.variations && insertObj.variations.Length() > 0) {
            ; Используем вариации
            variations := insertObj.variations
            variationStartPos := insertObj.variationStartPosition ? insertObj.variationStartPosition : "С начала"
            
            ; Получаем или инициализируем индекс для этой вставки
            insertKey := "insert_" . index
            if (!variationIndices.HasKey(insertKey)) {
                ; Инициализируем индекс в зависимости от начальной позиции
                if (variationStartPos = "С конца") {
                    variationIndices[insertKey] := variations.Length()
                } else if (variationStartPos = "С середины") {
                    variationIndices[insertKey] := Floor(variations.Length() / 2) + 1
                    if (variationIndices[insertKey] > variations.Length())
                        variationIndices[insertKey] := variations.Length()
                } else {
                    ; С начала (по умолчанию)
                    variationIndices[insertKey] := 1
                }
            }
            
            ; Получаем текущую вариацию
            currentIdx := variationIndices[insertKey]
            insertText := variations[currentIdx]
            
            ; Переходим к следующей вариации (циклически)
            currentIdx++
            if (currentIdx > variations.Length())
                currentIdx := 1
            variationIndices[insertKey] := currentIdx
        }
        global TextCase, ErrorLevelSetting
        ; Apply global text case setting to the insert itself so inserts match main text settings
        insertText := ChangeTextCase(insertText, TextCase)
        ; Применяем ошибки к вставке только если включено для этой вставки и уровень ошибок установлен
        if (insertObj.applyErrors = 1 && ErrorLevelSetting != "Нет") {
            insertText := AddErrors(insertText, ErrorLevelSetting)
        }
        position := insertObj.position
        
        if (position = "В начале") {
            if (!IsIgnoredNearby(insertObj, words, 0, wordCount))
                text := insertText . " " . text
        }
        else if (position = "В конце") {
            if (!IsIgnoredNearby(insertObj, words, wordCount, wordCount))
                text := text . " " . insertText
        }
        else if (position = "В середине") {
            middlePos := Floor(wordCount / 2)
            newWords := []
            Loop % wordCount {
                newWords.Push(words[A_Index])
                if (A_Index = middlePos) {
                    if (!IsIgnoredNearby(insertObj, words, middlePos, wordCount))
                        newWords.Push(insertText)
                }
            }
            text := ""
            for i, word in newWords {
                text .= word
                if (i < newWords.Length())
                    text .= " "
            }
        }
        else if (position = "Случайно") {
            Random, randomPos, 1, % wordCount
            newWords := []
            Loop % wordCount {
                newWords.Push(words[A_Index])
                if (A_Index = randomPos) {
                    if (!IsIgnoredNearby(insertObj, words, randomPos, wordCount))
                        newWords.Push(insertText)
                }
            }
            text := ""
            for i, word in newWords {
                text .= word
                if (i < newWords.Length())
                    text .= " "
            }
        }
        else if (position = "Поочерёдно") {
            ; Вставляем после каждого alternateIndex слова
            if (alternateIndex > wordCount)
                alternateIndex := 1
            
            newWords := []
            Loop % wordCount {
                newWords.Push(words[A_Index])
                if (A_Index = alternateIndex) {
                    if (!IsIgnoredNearby(insertObj, words, alternateIndex, wordCount))
                        newWords.Push(insertText)
                }
            }
            text := ""
            for i, word in newWords {
                text .= word
                if (i < newWords.Length())
                    text .= " "
            }
            alternateIndex++
        }
            else {
            ; Сначала поддержка вставки после/перед определённого слова: "После слова <word>", "Перед слова <word>"
            ; И "ТОЛЬКО после слова <word>", "ТОЛЬКО перед слова <word>" - вставка только если слово найдено
            if RegExMatch(position, "ТОЛЬКО после слова\s+(.+)", match) {
                target := Trim(match1)
                if (target != "") {
                    targetNorm := NormalizeForCompare(target)
                    ; Проверяем, есть ли целевое слово в тексте
                    wordFound := false
                    for i, w in words {
                        if (NormalizeForCompare(w) = targetNorm) {
                            wordFound := true
                            break
                        }
                    }
                    ; Вставляем только если слово найдено
                    if (wordFound) {
                        newWords := []
                        Loop % wordCount {
                            w := words[A_Index]
                            newWords.Push(w)
                            if (NormalizeForCompare(w) = targetNorm) {
                                if (!IsIgnoredNearby(insertObj, words, A_Index, wordCount))
                                    newWords.Push(insertText)
                            }
                        }
                        text := ""
                        for i, word in newWords {
                            text .= word . (i < newWords.Length() ? " " : "")
                        }
                    }
                }
            }
            else if RegExMatch(position, "ТОЛЬКО перед слова\s+(.+)", match) {
                target := Trim(match1)
                if (target != "") {
                    targetNorm := NormalizeForCompare(target)
                    ; Проверяем, есть ли целевое слово в тексте
                    wordFound := false
                    for i, w in words {
                        if (NormalizeForCompare(w) = targetNorm) {
                            wordFound := true
                            break
                        }
                    }
                    ; Вставляем только если слово найдено
                    if (wordFound) {
                        newWords := []
                        Loop % wordCount {
                            w := words[A_Index]
                            if (NormalizeForCompare(w) = targetNorm) {
                                if (!IsIgnoredNearby(insertObj, words, A_Index-1, wordCount))
                                    newWords.Push(insertText)
                            }
                            newWords.Push(w)
                        }
                        text := ""
                        for i, word in newWords {
                            text .= word . (i < newWords.Length() ? " " : "")
                        }
                    }
                }
            }
            else if RegExMatch(position, "После слова\s+(.+)", match) {
                target := Trim(match1)
                if (target != "") {
                    targetNorm := NormalizeForCompare(target)
                    newWords := []
                    Loop % wordCount {
                        w := words[A_Index]
                        newWords.Push(w)
                        if (NormalizeForCompare(w) = targetNorm) {
                            if (!IsIgnoredNearby(insertObj, words, A_Index, wordCount))
                                newWords.Push(insertText)
                        }
                    }
                    text := ""
                    for i, word in newWords {
                        text .= word . (i < newWords.Length() ? " " : "")
                    }
                }
            }
            else if RegExMatch(position, "Перед слова\s+(.+)", match) {
                target := Trim(match1)
                if (target != "") {
                    targetNorm := NormalizeForCompare(target)
                    newWords := []
                    Loop % wordCount {
                        w := words[A_Index]
                        if (NormalizeForCompare(w) = targetNorm) {
                            if (!IsIgnoredNearby(insertObj, words, A_Index-1, wordCount))
                                newWords.Push(insertText)
                        }
                        newWords.Push(w)
                    }
                    text := ""
                    for i, word in newWords {
                        text .= word . (i < newWords.Length() ? " " : "")
                    }
                }
            }
            ; Anchored and sectioned N-word patterns: handle "В начале/В середине/В конце (после|перед) N слов"
            else if RegExMatch(position, "В (начале|середине|конце) после (\d+) слов", m) {
                anchor := m1
                n := m2
                middlePos := Floor(wordCount / 2)
                if (anchor = "начале")
                    target := n
                else if (anchor = "середине")
                    target := middlePos + n
                else if (anchor = "конце")
                    target := wordCount - n + 1

                if (target < 1)
                    target := 1
                if (target > wordCount)
                    target := wordCount

                newWords := []
                Loop % wordCount {
                    newWords.Push(words[A_Index])
                    if (A_Index = target) {
                        if (!IsIgnoredNearby(insertObj, words, target, wordCount))
                            newWords.Push(insertText)
                    }
                }
                text := ""
                for i, word in newWords {
                    text .= word . (i < newWords.Length() ? " " : "")
                }
            }
            else if RegExMatch(position, "В (начале|середине|конце) перед (\d+) слов", m) {
                anchor := m1
                n := m2
                middlePos := Floor(wordCount / 2)
                if (anchor = "начале")
                    target := n
                else if (anchor = "середине")
                    target := middlePos - n + 1
                else if (anchor = "конце")
                    target := wordCount - n + 1

                if (target < 1)
                    target := 1
                if (target > wordCount)
                    target := wordCount

                newWords := []
                Loop % wordCount {
                    if (A_Index = target) {
                        if (!IsIgnoredNearby(insertObj, words, target-1, wordCount))
                            newWords.Push(insertText)
                    }
                    newWords.Push(words[A_Index])
                }
                text := ""
                for i, word in newWords {
                    text .= word . (i < newWords.Length() ? " " : "")
                }
            }
            ; Поддержка вариаций с N: "После N слов", "Перед N слов", и варианты "... с конца"
            else if RegExMatch(position, "После (\d+) слов( с конца)?", match) {
                n := match1
                fromEnd := (match2 != "")
                if (n > 0) {
                    if (fromEnd)
                        target := wordCount - n + 1
                    else
                        target := n

                    if (target >= 1 && target <= wordCount) {
                        newWords := []
                        Loop % wordCount {
                            newWords.Push(words[A_Index])
                            if (A_Index = target) {
                                ; insert after target
                                if (!IsIgnoredNearby(insertObj, words, target, wordCount))
                                    newWords.Push(insertText)
                            }
                        }
                        text := ""
                        for i, word in newWords {
                            text .= word . (i < newWords.Length() ? " " : "")
                        }
                    }
                }
            }
            else if RegExMatch(position, "Перед (\d+) слов( с конца)?", match) {
                n := match1
                fromEnd := (match2 != "")
                if (n > 0) {
                    if (fromEnd)
                        target := wordCount - n + 1
                    else
                        target := n

                    if (target >= 1 && target <= wordCount) {
                        newWords := []
                        Loop % wordCount {
                            if (A_Index = target) {
                                if (!IsIgnoredNearby(insertObj, words, target-1, wordCount))
                                    newWords.Push(insertText)
                            }
                            newWords.Push(words[A_Index])
                        }
                        text := ""
                        for i, word in newWords {
                            text .= word . (i < newWords.Length() ? " " : "")
                        }
                    }
                }
            }
        }
        
        ; Обновляем массив слов для следующей вставки
        words := StrSplit(text, " ")
        wordCount := words.Length()
    }
    
    ; Применяем правила вставки слов
    text := ApplyInsertRules(text)
    
    return text
}

; Вспомогательные функции
NormalizeForCompare(s) {
    s := Trim(s)
    if (s = "")
        return ""
    ; Remove common punctuation
    chars := [".", ",", "!", "?", ":", ";", Chr(34), "'", "(", ")", "-", "_"]
    for index, ch in chars
        StringReplace, s, s, %ch%, , All
    StringLower, s, s
    return s
}

IsIgnoredNearby(insertObj, words, insertAfterIndex, wordCount) {
    if (!insertObj || !insertObj.ignoreWords)
        return false
    ignoreStr := insertObj.ignoreWords
    if (Trim(ignoreStr) = "")
        return false
    ignores := StrSplit(ignoreStr, ",")
    left := ""
    right := ""
    if (insertAfterIndex >= 1 && insertAfterIndex <= wordCount)
        left := words[insertAfterIndex]
    if (insertAfterIndex + 1 <= wordCount && insertAfterIndex + 1 >= 1)
        right := words[insertAfterIndex + 1]
    left := NormalizeForCompare(left)
    right := NormalizeForCompare(right)
    for i, v in ignores {
        w := NormalizeForCompare(Trim(v))
        if (w = "")
            continue
        if (left != "" && left = w)
            return true
        if (right != "" && right = w)
            return true
    }
    return false
}

; === ПРИМЕНЕНИЕ ПРАВИЛ ВСТАВКИ СЛОВ ===
ApplyInsertRules(text) {
    global insertRules, TextCase, ErrorLevelSetting
    
    if (!insertRules || insertRules.Length() = 0)
        return text
    
    ; Разбиваем текст на слова
    words := StrSplit(text, " ")
    wordCount := words.Length()
    
    if (wordCount = 0)
        return text
    
    ; Применяем каждое правило
    for index, rule in insertRules {
        ; Пропускаем отключённые правила
        if (!rule.enabled)
            continue
        
        ; Проверяем вероятность срабатывания
        Random, chance, 1, 100
        if (chance > rule.probability)
            continue
        
        insertText := rule.text
        ruleType := rule.type
        param1 := rule.param1
        param2 := rule.param2
        param3 := rule.param3
        
        ; Применяем регистр к вставке
        insertText := ChangeTextCase(insertText, TextCase)
        
        ; Применяем ошибки если включено
        if (rule.applyErrors && ErrorLevelSetting != "Нет") {
            insertText := AddErrors(insertText, ErrorLevelSetting)
        }
        
        ; Применяем правило в зависимости от типа
        if (ruleType = "Вставка перед словом") {
            targetWord := param1
            if (targetWord != "") {
                targetNorm := NormalizeForCompare(targetWord)
                newWords := []
                for i, w in words {
                    if (NormalizeForCompare(w) = targetNorm)
                        newWords.Push(insertText)
                    newWords.Push(w)
                }
                words := newWords
            }
        }
        else if (ruleType = "Вставка после слова") {
            targetWord := param1
            if (targetWord != "") {
                targetNorm := NormalizeForCompare(targetWord)
                newWords := []
                for i, w in words {
                    newWords.Push(w)
                    if (NormalizeForCompare(w) = targetNorm)
                        newWords.Push(insertText)
                }
                words := newWords
            }
        }
        else if (ruleType = "Вставка перед каждым N-словом") {
            n := param1
            if (n > 0) {
                newWords := []
                for i, w in words {
                    if (Mod(i, n) = 0)
                        newWords.Push(insertText)
                    newWords.Push(w)
                }
                words := newWords
            }
        }
        else if (ruleType = "Вставка после каждого N-слова") {
            n := param1
            if (n > 0) {
                newWords := []
                for i, w in words {
                    newWords.Push(w)
                    if (Mod(i, n) = 0)
                        newWords.Push(insertText)
                }
                words := newWords
            }
        }
        else if (ruleType = "Вставка в начало текста") {
            words.InsertAt(1, insertText)
        }
        else if (ruleType = "Вставка в конец текста") {
            words.Push(insertText)
        }
        else if (ruleType = "Вставка в середину текста") {
            middlePos := Floor(words.Length() / 2)
            words.InsertAt(middlePos, insertText)
        }
        else if (ruleType = "Вставка перед словами из списка") {
            wordList := StrSplit(param1, ",")
            newWords := []
            for i, w in words {
                shouldInsert := false
                for j, targetWord in wordList {
                    if (NormalizeForCompare(w) = NormalizeForCompare(Trim(targetWord))) {
                        shouldInsert := true
                        break
                    }
                }
                if (shouldInsert)
                    newWords.Push(insertText)
                newWords.Push(w)
            }
            words := newWords
        }
        else if (ruleType = "Вставка после слов из списка") {
            wordList := StrSplit(param1, ",")
            newWords := []
            for i, w in words {
                newWords.Push(w)
                shouldInsert := false
                for j, targetWord in wordList {
                    if (NormalizeForCompare(w) = NormalizeForCompare(Trim(targetWord))) {
                        shouldInsert := true
                        break
                    }
                }
                if (shouldInsert)
                    newWords.Push(insertText)
            }
            words := newWords
        }
        else if (ruleType = "Вставка перед длинными словами") {
            minLength := param1
            if (minLength > 0) {
                newWords := []
                for i, w in words {
                    if (StrLen(w) >= minLength)
                        newWords.Push(insertText)
                    newWords.Push(w)
                }
                words := newWords
            }
        }
        else if (ruleType = "Вставка после длинных слов") {
            minLength := param1
            if (minLength > 0) {
                newWords := []
                for i, w in words {
                    newWords.Push(w)
                    if (StrLen(w) >= minLength)
                        newWords.Push(insertText)
                }
                words := newWords
            }
        }
        else if (ruleType = "Вставка перед короткими словами") {
            maxLength := param1
            if (maxLength > 0) {
                newWords := []
                for i, w in words {
                    if (StrLen(w) <= maxLength)
                        newWords.Push(insertText)
                    newWords.Push(w)
                }
                words := newWords
            }
        }
        else if (ruleType = "Вставка после коротких слов") {
            maxLength := param1
            if (maxLength > 0) {
                newWords := []
                for i, w in words {
                    newWords.Push(w)
                    if (StrLen(w) <= maxLength)
                        newWords.Push(insertText)
                }
                words := newWords
            }
        }
        else if (ruleType = "Вставка перед заглавными словами") {
            newWords := []
            for i, w in words {
                firstChar := SubStr(w, 1, 1)
                if (firstChar != "" && firstChar = Format("{:U}", firstChar))
                    newWords.Push(insertText)
                newWords.Push(w)
            }
            words := newWords
        }
        else if (ruleType = "Вставка после заглавных слов") {
            newWords := []
            for i, w in words {
                newWords.Push(w)
                firstChar := SubStr(w, 1, 1)
                if (firstChar != "" && firstChar = Format("{:U}", firstChar))
                    newWords.Push(insertText)
            }
            words := newWords
        }
        else if (ruleType = "Вставка случайно (N раз)") {
            n := param1
            if (n > 0 && words.Length() > 0) {
                Loop, %n% {
                    Random, randomPos, 1, % words.Length()
                    words.InsertAt(randomPos, insertText)
                }
            }
        }
        else if (ruleType = "Вставка перед словами определённой длины") {
            targetLength := param1
            if (targetLength > 0) {
                newWords := []
                for i, w in words {
                    if (StrLen(w) = targetLength)
                        newWords.Push(insertText)
                    newWords.Push(w)
                }
                words := newWords
            }
        }
        else if (ruleType = "Вставка после слов определённой длины") {
            targetLength := param1
            if (targetLength > 0) {
                newWords := []
                for i, w in words {
                    newWords.Push(w)
                    if (StrLen(w) = targetLength)
                        newWords.Push(insertText)
                }
                words := newWords
            }
        }
        else if (ruleType = "Вставка перед словами на букву") {
            targetLetter := SubStr(param1, 1, 1)
            if (targetLetter != "") {
                StringLower, targetLetterLower, targetLetter
                newWords := []
                for i, w in words {
                    firstChar := SubStr(w, 1, 1)
                    StringLower, firstCharLower, firstChar
                    if (firstCharLower = targetLetterLower)
                        newWords.Push(insertText)
                    newWords.Push(w)
                }
                words := newWords
            }
        }
        else if (ruleType = "Вставка после слов на букву") {
            targetLetter := SubStr(param1, 1, 1)
            if (targetLetter != "") {
                StringLower, targetLetterLower, targetLetter
                newWords := []
                for i, w in words {
                    newWords.Push(w)
                    firstChar := SubStr(w, 1, 1)
                    StringLower, firstCharLower, firstChar
                    if (firstCharLower = targetLetterLower)
                        newWords.Push(insertText)
                }
                words := newWords
            }
        }
        else if (ruleType = "Вставка перед словами заканчивающимися на") {
            suffix := param1
            if (suffix != "") {
                StringLower, suffixLower, suffix
                newWords := []
                for i, w in words {
                    StringLower, wLower, w
                    if (InStr(wLower, suffixLower, false, 0) = StrLen(wLower) - StrLen(suffixLower) + 1)
                        newWords.Push(insertText)
                    newWords.Push(w)
                }
                words := newWords
            }
        }
        else if (ruleType = "Вставка после слов заканчивающихся на") {
            suffix := param1
            if (suffix != "") {
                StringLower, suffixLower, suffix
                newWords := []
                for i, w in words {
                    newWords.Push(w)
                    StringLower, wLower, w
                    if (InStr(wLower, suffixLower, false, 0) = StrLen(wLower) - StrLen(suffixLower) + 1)
                        newWords.Push(insertText)
                }
                words := newWords
            }
        }
        else if (ruleType = "Вставка перед словами содержащими") {
            substring := param1
            if (substring != "") {
                StringLower, substringLower, substring
                newWords := []
                for i, w in words {
                    StringLower, wLower, w
                    if (InStr(wLower, substringLower))
                        newWords.Push(insertText)
                    newWords.Push(w)
                }
                words := newWords
            }
        }
        else if (ruleType = "Вставка после слов содержащих") {
            substring := param1
            if (substring != "") {
                StringLower, substringLower, substring
                newWords := []
                for i, w in words {
                    newWords.Push(w)
                    StringLower, wLower, w
                    if (InStr(wLower, substringLower))
                        newWords.Push(insertText)
                }
                words := newWords
            }
        }
        else if (ruleType = "Вставка через N слов") {
            n := param1
            if (n > 0) {
                newWords := []
                for i, w in words {
                    newWords.Push(w)
                    if (Mod(i, n) = 0 && i < words.Length())
                        newWords.Push(insertText)
                }
                words := newWords
            }
        }
        else if (ruleType = "Вставка в начало каждой строки") {
            ; Разбиваем на строки
            lines := StrSplit(text, "`n")
            newLines := []
            for i, line in lines {
                newLines.Push(insertText . " " . line)
            }
            text := ""
            for i, line in newLines {
                text .= line . (i < newLines.Length() ? "`n" : "")
            }
            return text
        }
        else if (ruleType = "Вставка в конец каждой строки") {
            ; Разбиваем на строки
            lines := StrSplit(text, "`n")
            newLines := []
            for i, line in lines {
                newLines.Push(line . " " . insertText)
            }
            text := ""
            for i, line in newLines {
                text .= line . (i < newLines.Length() ? "`n" : "")
            }
            return text
        }
    }
    
    ; Собираем текст обратно
    text := ""
    for i, word in words {
        text .= word . (i < words.Length() ? " " : "")
    }
    
    return text
}

Max(a, b) {
    return a > b ? a : b
}

Min(a, b) {
    return a < b ? a : b
}

Random(min, max) {
    Random, result, min, max
    return result
}

; ============================================
; === SPEED ENGINE (150+ параметров) ===
; ============================================

SpeedCfgBuildDefs() {
    ; Def fields:
    ; - key: ini key
    ; - group: common|input|event|play|clip
    ; - name: param name
    ; - type: bool|int|float|text
    ; - def: default (for common) / "" (for overrides)
    ; - label: UI label
    ; - desc: short description
    defs := []

    groups := ["common", "input", "event", "play", "clip"]
    groupTitle := {}
    groupTitle["common"] := "Общее"
    groupTitle["input"] := "SendInput"
    groupTitle["event"] := "SendEvent"
    groupTitle["play"] := "SendPlay"
    groupTitle["clip"] := "Буфер"

    params := []
    ; Core toggles / clamps
    params.Push({name:"enabled", type:"bool", def:1, label:"Включено", desc:"Главный выключатель движка скорости"})
    params.Push({name:"min_sleep_ms", type:"int", def:0, label:"Мин. Sleep (мс)", desc:"Нижняя граница для любых Sleep после ускорения"})
    params.Push({name:"max_sleep_ms", type:"int", def:0, label:"Макс. Sleep (мс)", desc:"Верхняя граница для Sleep (0 = без лимита)"})
    ; Segment delays
    params.Push({name:"pre_segment_ms", type:"int", def:0, label:"Перед сегментом (мс)", desc:"Пауза перед отправкой сегмента текста"})
    params.Push({name:"post_segment_ms", type:"int", def:0, label:"После сегмента (мс)", desc:"Пауза после отправки сегмента текста"})
    ; Extra per-char delay (accelerates with multiplier)
    params.Push({name:"per_char_extra_min_ms", type:"int", def:0, label:"Экстра/симв мин (мс)", desc:"Доп. задержка на символ (минимум)"})
    params.Push({name:"per_char_extra_max_ms", type:"int", def:0, label:"Экстра/симв макс (мс)", desc:"Доп. задержка на символ (максимум)"})
    ; Jitter / smoothing
    params.Push({name:"jitter_enabled", type:"bool", def:0, label:"Джиттер", desc:"Случайный джиттер к задержкам (видимое ускорение/замедление)"})
    params.Push({name:"jitter_min_ms", type:"int", def:0, label:"Джиттер мин (мс)", desc:"Минимальный джиттер"})
    params.Push({name:"jitter_max_ms", type:"int", def:0, label:"Джиттер макс (мс)", desc:"Максимальный джиттер"})
    params.Push({name:"smooth_enabled", type:"bool", def:0, label:"Сглаживание", desc:"Сглаживать задержки между символами (анти-дерганье)"})
    params.Push({name:"smooth_strength_pct", type:"int", def:50, label:"Сила сглаживания (%)", desc:"0..100; больше = сильнее тянется к предыдущей задержке"})
    ; Burst words
    params.Push({name:"burst_enabled", type:"bool", def:1, label:"Burst-слова", desc:"Вводить указанные слова мгновенно"})
    params.Push({name:"burst_word_delay_ms", type:"int", def:0, label:"Пауза после burst (мс)", desc:"Пауза после burst-слова"})
    ; Chunking
    params.Push({name:"chunk_enabled", type:"bool", def:0, label:"Чанкование", desc:"Разбивать длинные сегменты на части"})
    params.Push({name:"chunk_chars", type:"int", def:400, label:"Размер чанка (симв)", desc:"Сколько символов в одном чанке"})
    params.Push({name:"chunk_pause_ms", type:"int", def:0, label:"Пауза между чанками (мс)", desc:"Пауза после каждого чанка"})
    ; Message-level scaling/floors
    params.Push({name:"between_messages_min_ms", type:"int", def:0, label:"Мин. между сообщ. (мс)", desc:"Нижняя граница для MessageDelay после ускорения"})
    params.Push({name:"after_send_min_ms", type:"int", def:0, label:"Мин. после отправки (мс)", desc:"Нижняя граница для MainDelay после ускорения"})
    ; Special tag pause scaling (kept stable by default)
    params.Push({name:"pause_tag_scale_pct", type:"int", def:100, label:"{PAUSE} масштаб (%)", desc:"100 = без изменений, 50 = в 2 раза быстрее"})
    params.Push({name:"pause_tag_min_ms", type:"int", def:0, label:"{PAUSE} мин (мс)", desc:"Минимум паузы из меток"})
    ; Clipboard pipeline
    params.Push({name:"clip_clear_ms", type:"int", def:20, label:"Clip: очистка (мс)", desc:"Пауза после Clipboard := """""})
    params.Push({name:"clip_settle_ms", type:"int", def:50, label:"Clip: стабилизация (мс)", desc:"Пауза после установки Clipboard"})
    params.Push({name:"clip_post_paste_ms", type:"int", def:100, label:"Clip: после Ctrl+V (мс)", desc:"Пауза после вставки"})
    params.Push({name:"clip_wait_timeout_s", type:"float", def:2.0, label:"ClipWait таймаут (с)", desc:"Таймаут ClipWait до ускорения"})
    params.Push({name:"clip_wait_min_s", type:"float", def:0.05, label:"ClipWait минимум (с)", desc:"Нижняя граница таймаута ClipWait"})
    params.Push({name:"clip_before_paste_ms", type:"int", def:0, label:"Clip: перед Ctrl+V (мс)", desc:"Доп. пауза перед Ctrl+V"})
    params.Push({name:"clip_restore_clipboard", type:"bool", def:1, label:"Восст. буфер", desc:"Восстанавливать буфер обмена после вставки"})
    params.Push({name:"clip_retry_count", type:"int", def:0, label:"Clip: повторы", desc:"Повторить вставку N раз при проблемах (0 = нет)"})
    params.Push({name:"clip_retry_pause_ms", type:"int", def:30, label:"Clip: пауза повтора (мс)", desc:"Пауза между повторами"})

    for gi, g in groups {
        for pi, p in params {
            key := g . "__" . p.name
            isCommon := (g = "common")
            defVal := isCommon ? p.def : ""  ; overrides inherit by default
            defs.Push({key:key, group:g, name:p.name, type:p.type, def:defVal, label:groupTitle[g] . " • " . p.label, desc:p.desc})
        }
    }
    return defs
}

SpeedCfgInit() {
    global speedCfg, speedCfgDefs, appDataDir
    if (!IsObject(speedCfgDefs) || speedCfgDefs.Length() = 0)
        speedCfgDefs := SpeedCfgBuildDefs()

    ini := appDataDir . "\\AutoTyper.ini"
    for i, d in speedCfgDefs {
        IniRead, v, %ini%, SpeedEngineParams, % d.key, % d.def
        if (v = "ERROR")
            v := d.def
        speedCfg[d.key] := v
    }
}

SpeedCfgKey(group, name) {
    return group . "__" . name
}

SpeedCfgGet(group, name) {
    global speedCfg
    key := SpeedCfgKey(group, name)
    return speedCfg.HasKey(key) ? speedCfg[key] : ""
}

SpeedCfgEff(group, name) {
    ; group override -> common fallback
    v := SpeedCfgGet(group, name)
    if (v != "")
        return v
    return SpeedCfgGet("common", name)
}

SpeedCfgNum(group, name, defNum := 0) {
    v := SpeedCfgEff(group, name)
    if (v = "")
        return defNum
    ; allow float strings
    if RegExMatch(v, "^-?\\d+(?:\\.\\d+)?$")
        return v + 0
    return defNum
}

SpeedCfgBool(group, name, defBool := false) {
    v := SpeedCfgEff(group, name)
    if (v = "")
        return defBool
    return (v = 1 || v = "1" || v = "true" || v = "True")
}

SpeedClampSleepMs(ms, group) {
    minMs := SpeedCfgNum(group, "min_sleep_ms", 0)
    maxMs := SpeedCfgNum(group, "max_sleep_ms", 0)
    if (ms < minMs)
        ms := minMs
    if (maxMs > 0 && ms > maxMs)
        ms := maxMs
    return ms
}

SpeedSleepScaled(ms, speedFactor, group) {
    global isTyping
    if (!isTyping)
        return
    if (ms <= 0)
        return
    sf := speedFactor + 0
    if (sf < 1)
        sf := 1
    eff := Floor(ms / sf)
    eff := SpeedClampSleepMs(eff, group)
    if (eff > 0)
        Sleep, %eff%
}

SpeedGroupForEngine(engineName) {
    if (engineName = "SendEvent")
        return "event"
    if (engineName = "SendPlay")
        return "play"
    return "input"
}

SendTextByEngine(engineName, text) {
    ; text should be plain text for {Text} mode
    if (engineName = "SendEvent") {
        SendEvent, {Text}%text%
        return
    }
    if (engineName = "SendPlay") {
        SendPlay, {Text}%text%
        return
    }
    SendInput, {Text}%text%
}

SendKeysByEngine(engineName, keys) {
    ; keys: e.g. "^v", "{Enter}"
    if (engineName = "SendEvent") {
        SendEvent, %keys%
        return
    }
    if (engineName = "SendPlay") {
        SendPlay, %keys%
        return
    }
    SendInput, %keys%
}

SpeedTokenizeText(text) {
    tokens := []
    pos := 1
    len := StrLen(text)
    while (pos <= len) {
        if (RegExMatch(text, "O)([A-Za-zА-Яа-яЁё0-9_]+)", m, pos)) {
            if (m.Pos(0) > pos) {
                tokens.Push({t:"sep", v: SubStr(text, pos, m.Pos(0) - pos)})
            }
            tokens.Push({t:"word", v: m.Value(1)})
            pos := m.Pos(0) + m.Len(0)
        } else {
            tokens.Push({t:"sep", v: SubStr(text, pos)})
            break
        }
    }
    return tokens
}

SpeedSplitChunks(text, chunkSize) {
    out := []
    if (chunkSize <= 0 || StrLen(text) <= chunkSize) {
        out.Push(text)
        return out
    }
    pos := 1
    len := StrLen(text)
    while (pos <= len) {
        out.Push(SubStr(text, pos, chunkSize))
        pos += chunkSize
    }
    return out
}

SpeedCfgSave() {
    global speedCfg, speedCfgDefs, appDataDir
    ini := appDataDir . "\\AutoTyper.ini"
    for i, d in speedCfgDefs {
        key := d.key
        val := speedCfg[key]
        if (d.group != "common" && val = "") {
            IniDelete, %ini%, SpeedEngineParams, %key%
        } else {
            IniWrite, %val%, %ini%, SpeedEngineParams, %key%
        }
    }
}

SpeedCfgResetAll() {
    global speedCfg, speedCfgDefs
    for i, d in speedCfgDefs {
        if (d.group = "common")
            speedCfg[d.key] := d.def
        else
            speedCfg[d.key] := ""  ; inherit
    }
}

SpeedCfgDefByKey(key) {
    global speedCfgDefs
    for i, d in speedCfgDefs {
        if (d.key = key)
            return d
    }
    return ""
}

GetSpeedMultiplierNum() {
    GuiControlGet, t,, SpeedMultiplier
    m := RegExReplace(t, "[^0-9]", "")
    if (m = "" || m <= 0)
        return 1
    return m + 0
}

; === Transliterate Cyrillic -> Latin (basic Russian translit) ===
Transliterate(text) {
    if (text = "")
        return ""

    from := ["а","б","в","г","д","е","ё","ж","з","и","й","к","л","м","н","о","п","р","с","т","у","ф","х","ц","ч","ш","щ","ъ","ы","ь","э","ю","я"]
    to   := ["a","b","v","g","d","e","yo","zh","z","i","y","k","l","m","n","o","p","r","s","t","u","f","kh","ts","ch","sh","shch","","y","","e","yu","ya"]

    for i, ch in from {
        repl := to[i]
        ; lower-case replacement
        text := StrReplace(text, ch, repl)
        ; upper-case replacement
        StringUpper, chU, ch
        StringUpper, replU, repl
        text := StrReplace(text, chU, replU)
    }
    return text
}

; === Новая функция: Отправка сообщения ===
SendMessage(message, speed) {
    global AutoEnterMode, MaxWordsInput, TimeInput, TimeUnit
    global ErrorGenLevel, ErrorLocation, CustomErrorCount
    global TextShuffleLevel
    global MainDelayMode, MainDelayValue
    global SpeedType, SpeedInput
    global MessageDelay
    global clipboardDelayValue, clipboardDelayUnit
    global stealthBlockReason
    global StealthModeEnabled
    global SpeedSendEngine
    global PrintTranslit, letterReplacementsEnabled
    global AutoEnterInsertPerChunk
    global randomSpacesEnabled, doubleLettersEnabled, caseWords, letterInserts, autoCorrectEnabled
    global translatorEnabled, translatorSourceLang, translatorTargetLang
    global printTimeDeadline, printTimeLimitHit
    
    Gui, 1:Submit, NoHide
    
    ; Используем SpeedInput из GUI, если speed не передан или равен 0
    if (!speed || speed = 0) {
        speed := SpeedInput
    }
    
    ; Получаем множитель скорости
    global SpeedMultiplier
    GuiControlGet, speedMultiplierText,, SpeedMultiplier
    ; Извлекаем число из текста (например, "10x" -> 10)
    multiplier := RegExReplace(speedMultiplierText, "[^0-9]", "")
    if (multiplier = "" || multiplier <= 0)
        multiplier := 1
    
    ; Определяем тип скорости и рассчитываем задержку
    charDelay := 0
    useClipboard := false
    
    if (SpeedType = "Букв в секунду") {
        ; Букв в секунду (текущий режим)
        if (speed > 0) {
            ; Применяем множитель: увеличиваем скорость = уменьшаем задержку
            charDelay := Floor(1000 / (speed * multiplier))
        }
    }
    else if (SpeedType = "Слов в минуту") {
        ; Слов в минуту: среднее слово = 5 символов, WPM = слов/мин
        ; Задержка на символ = (60 / (WPM * 5)) * 1000 мс
        if (speed > 0) {
            charDelay := Floor((60 / (speed * multiplier * 5)) * 1000)
        }
    }
    else if (SpeedType = "Интервал" || SpeedType = "Задержка") {
        ; Интервал/Задержка: прямая задержка в мс, делим на множитель
        charDelay := Floor(speed / multiplier)
    }
    else if (SpeedType = "Вставка через буфер обмена") {
        ; Вставка через буфер обмена - без задержки между символами
        useClipboard := true
    }

    ; Stealth: скорость может немного варьироваться (видимо и безопасно).
    if (StealthModeEnabled && StealthOpt(53) && charDelay > 0) {
        pct := Random(80, 120)
        charDelay := Floor(charDelay * (pct / 100.0))
        if (charDelay < 0)
            charDelay := 0
    }
    
    ; Применяем генератор ошибок если включен
    if (ErrorGenLevel > 1) {
        message := GenerateErrors(message, ErrorGenLevel, ErrorLocation, CustomErrorCount)
    }

    ; Применяем перемешиватель текста (независимо от генератора ошибок)
    if (TextShuffleLevel != "" && TextShuffleLevel != "Отключено") {
        shuffleNum := 1
        if (TextShuffleLevel = "Низкий")
            shuffleNum := 2
        else if (TextShuffleLevel = "Средний")
            shuffleNum := 3
        else if (TextShuffleLevel = "Высокий")
            shuffleNum := 4
        else if (TextShuffleLevel = "Экстремальный")
            shuffleNum := 5

        if (shuffleNum > 1)
            message := ShuffleText(message, shuffleNum)
    }

    ; Применяем транслитерацию если включена
    if (PrintTranslit = "Включено") {
        message := Transliterate(message)
    }

    ; Применяем замену букв (Letter Changer) ПОСЛЕ транслитерации, чтобы замены были финальными
    if (letterReplacementsEnabled) {
        message := ApplyLetterReplacements(message)
    }
    
    ; Применяем ограничения букв (удаляем запрещённые символы)
    message := ApplyLetterRestrictions(message)
    
    ; === НОВЫЕ ЭФФЕКТЫ ===
    ; Применяем случайные пробелы
    global randomSpacesEnabled
    if (randomSpacesEnabled) {
        message := ApplyRandomSpaces(message)
    }
    
    ; Применяем double/triple буквы
    global doubleLettersEnabled
    if (doubleLettersEnabled) {
        message := ApplyDoubleLetters(message)
    }
    
    ; Применяем регистр слов
    global caseWords
    if (caseWords && caseWords.Length() > 0) {
        message := ApplyCaseWords(message)
    }
    
    ; Применяем вставку букв внутри слов
    global letterInserts
    if (letterInserts && letterInserts.Length() > 0) {
        ; Обрабатываем каждое слово
        words := StrSplit(message, " ")
        newWords := []
        for i, word in words {
            newWords.Push(ApplyLetterInserts(word))
        }
        message := ""
        for i, word in newWords {
            message .= (message != "" ? " " : "") . word
        }
    }
    
    ; Применяем авто-коррекцию
    global autoCorrectEnabled
    if (autoCorrectEnabled) {
        words := StrSplit(message, " ")
        newWords := []
        for i, word in words {
            newWords.Push(ApplyAutoCorrect(word))
        }
        message := ""
        for i, word in newWords {
            message .= (message != "" ? " " : "") . word
        }
    }
    
    ; Применяем переводчик
    global translatorEnabled
    if (translatorEnabled) {
        message := TranslateText(message, translatorSourceLang, translatorTargetLang)
    }
    
    ; Multi-window removed: отправка сообщений будет происходить в текущем активном окне
    
    ; Рассчитываем задержку
    delay := CalculateDelay(MainDelayMode, MainDelayValue)

    ; Реальное ускорение: множитель ускоряет не только ввод, но и задержки.
    sleepGroup := useClipboard ? "clip" : SpeedGroupForEngine(SpeedSendEngine)
    effAfterSendDelay := delay > 0 ? Floor(delay / multiplier) : 0
    minAfter := SpeedCfgNum(sleepGroup, "after_send_min_ms", 0)
    if (effAfterSendDelay < minAfter)
        effAfterSendDelay := minAfter
    if (effAfterSendDelay < 0)
        effAfterSendDelay := 0

    effMsgDelay := MessageDelay > 0 ? Floor(MessageDelay / multiplier) : 0
    minBetween := SpeedCfgNum(sleepGroup, "between_messages_min_ms", 0)
    if (effMsgDelay < minBetween)
        effMsgDelay := minBetween
    if (effMsgDelay < 0)
        effMsgDelay := 0
    
    ; Режим Auto-Enter: Максимум слов
    if (AutoEnterMode = 2 && MaxWordsInput > 0) {
        words := StrSplit(message, " ")
        currentMessage := ""
        wordCount := 0
        
        for i, word in words {
            currentMessage .= (currentMessage ? " " : "") . word
            wordCount++
            
            if (wordCount >= MaxWordsInput) {
                ; Если включена опция применять позицию вставки для Auto-Enter — применяем вставки к каждому фрагменту
                if (AutoEnterInsertPerChunk)
                    chunkToSend := ApplyCustomInserts(currentMessage)
                else
                    chunkToSend := currentMessage
                
                chunkToSend := ApplyStealthMode(chunkToSend, "SendMessage")
                if (chunkToSend = "") {
                    SB_SetText("Stealth: отправка отменена (" . stealthBlockReason . ")", 3)
                    return
                }

                ; Отправляем текущее сообщение (фрагмент)
                if (!SendTextWithSpecialTags(chunkToSend, useClipboard, charDelay, multiplier))
                    return
                if (printTimeDeadline > 0 && printTimeLimitHit) {
                    if (isTyping)
                        SendInput, {Enter}
                    return
                }
                if (isTyping)
                    SendInput, {Enter}
                
                ; Применяем задержку между сообщениями
                if (effAfterSendDelay > 0 && isTyping)
                    Sleep, %effAfterSendDelay%
                
                ; Сбрасываем для следующего сообщения
                currentMessage := ""
                wordCount := 0
                
                ; Пауза между сообщениями
                if (effMsgDelay > 0)
                    Sleep, %effMsgDelay%
            }
        }
        
        ; Отправляем оставшийся текст
        if (currentMessage != "") {
            if (AutoEnterInsertPerChunk)
                chunkToSend := ApplyCustomInserts(currentMessage)
            else
                chunkToSend := currentMessage
            
            chunkToSend := ApplyStealthMode(chunkToSend, "SendMessage")
            if (chunkToSend = "") {
                SB_SetText("Stealth: отправка отменена (" . stealthBlockReason . ")", 3)
                return
            }

            if (!SendTextWithSpecialTags(chunkToSend, useClipboard, charDelay, multiplier))
                return
            if (printTimeDeadline > 0 && printTimeLimitHit) {
                if (isTyping)
                    SendInput, {Enter}
                return
            }
            if (isTyping)
                SendInput, {Enter}
            
            ; Применяем задержку после последнего сообщения
            if (effAfterSendDelay > 0 && isTyping)
                Sleep, %effAfterSendDelay%
        }
    }
    ; Режим Auto-Enter: Enter через время
    else if (AutoEnterMode = 3 && TimeInput > 0) {
        message := ApplyStealthMode(message, "SendMessage")
        if (message = "") {
            SB_SetText("Stealth: отправка отменена (" . stealthBlockReason . ")", 3)
            return
        }

        ; Конвертируем время в миллисекунды
        timeMs := TimeInput
        if (TimeUnit = "сек") {
            timeMs := TimeInput * 1000
        }
        
        ; Запускаем таймер для автозавершения
        SetTimer, AutoEnterTimer, %timeMs%
        
        ; Печатаем сообщение (с поддержкой спец-меток)
        if (!SendTextWithSpecialTags(message, useClipboard, charDelay, multiplier))
            return
        if (printTimeDeadline > 0 && printTimeLimitHit) {
            SetTimer, AutoEnterTimer, Off
            if (isTyping)
                SendInput, {Enter}
            return
        }
        
        ; Отключаем таймер и отправляем Enter
        SetTimer, AutoEnterTimer, Off
        if (isTyping)
            SendInput, {Enter}
        
        ; Применяем задержку после сообщения
        if (effAfterSendDelay > 0 && isTyping)
            Sleep, %effAfterSendDelay%
    }
    ; Режим Auto-Enter: По циклам
    else if (AutoEnterMode = 4) {
        global autoEnterCycles, autoEnterCurrentCycle
        
        ; Проверяем что циклы настроены
        if (!autoEnterCycles || autoEnterCycles.Length() = 0) {
            ; Если циклов нет, отправляем как обычное сообщение
            message := ApplyStealthMode(message, "SendMessage")
            if (message = "") {
                SB_SetText("Stealth: отправка отменена (" . stealthBlockReason . ")", 3)
                return
            }
            if (!SendTextWithSpecialTags(message, useClipboard, charDelay, multiplier))
                return
            if (isTyping)
                SendInput, {Enter}
            if (effAfterSendDelay > 0 && isTyping)
                Sleep, %effAfterSendDelay%
            return
        }
        
        ; Получаем количество слов для текущего цикла
        if (autoEnterCurrentCycle > autoEnterCycles.Length())
            autoEnterCurrentCycle := 1
        
        currentCycleWords := autoEnterCycles[autoEnterCurrentCycle].words
        
        ; Разбиваем сообщение на слова
        words := StrSplit(message, " ")
        currentMessage := ""
        wordCount := 0
        
        ; Отправляем N слов согласно текущему циклу
        for i, word in words {
            currentMessage .= (currentMessage ? " " : "") . word
            wordCount++
            
            ; Когда достигли нужного количества слов для текущего цикла
            if (wordCount >= currentCycleWords) {
                ; Применяем вставки если нужно
                if (AutoEnterInsertPerChunk)
                    chunkToSend := ApplyCustomInserts(currentMessage)
                else
                    chunkToSend := currentMessage
                
                chunkToSend := ApplyStealthMode(chunkToSend, "SendMessage")
                if (chunkToSend = "") {
                    SB_SetText("Stealth: отправка отменена (" . stealthBlockReason . ")", 3)
                    return
                }
                
                ; Отправляем фрагмент
                if (!SendTextWithSpecialTags(chunkToSend, useClipboard, charDelay, multiplier))
                    return
                
                ; Отправляем Enter
                if (printTimeDeadline > 0 && printTimeLimitHit) {
                    if (isTyping)
                        SendInput, {Enter}
                    return
                }
                if (isTyping)
                    SendInput, {Enter}
                
                ; Применяем задержку
                if (effAfterSendDelay > 0 && isTyping)
                    Sleep, %effAfterSendDelay%
                
                ; Переходим к следующему циклу
                autoEnterCurrentCycle++
                if (autoEnterCurrentCycle > autoEnterCycles.Length())
                    autoEnterCurrentCycle := 1
                
                ; Обновляем количество слов для следующего цикла
                currentCycleWords := autoEnterCycles[autoEnterCurrentCycle].words
                
                ; Сбрасываем счетчики
                currentMessage := ""
                wordCount := 0
                
                ; Пауза между сообщениями
                if (effMsgDelay > 0)
                    Sleep, %effMsgDelay%
            }
        }
        
        ; Отправляем оставшийся текст (если есть)
        if (currentMessage != "") {
            if (AutoEnterInsertPerChunk)
                chunkToSend := ApplyCustomInserts(currentMessage)
            else
                chunkToSend := currentMessage
            
            chunkToSend := ApplyStealthMode(chunkToSend, "SendMessage")
            if (chunkToSend = "") {
                SB_SetText("Stealth: отправка отменена (" . stealthBlockReason . ")", 3)
                return
            }
            
            if (!SendTextWithSpecialTags(chunkToSend, useClipboard, charDelay, multiplier))
                return
            
            if (printTimeDeadline > 0 && printTimeLimitHit) {
                if (isTyping)
                    SendInput, {Enter}
                return
            }
            if (isTyping)
                SendInput, {Enter}
            
            if (effAfterSendDelay > 0 && isTyping)
                Sleep, %effAfterSendDelay%
            
            ; Переходим к следующему циклу после отправки остатка
            autoEnterCurrentCycle++
            if (autoEnterCurrentCycle > autoEnterCycles.Length())
                autoEnterCurrentCycle := 1
        }
    }
    ; Обычный режим
    else {
        message := ApplyStealthMode(message, "SendMessage")
        if (message = "") {
            SB_SetText("Stealth: отправка отменена (" . stealthBlockReason . ")", 3)
            return
        }
        if (!SendTextWithSpecialTags(message, useClipboard, charDelay, multiplier))
            return
        if (printTimeDeadline > 0 && printTimeLimitHit) {
            SetTimer, AutoEnterTimer, Off
            if (isTyping)
                SendInput, {Enter}
            return
        }
        
        ; Отключаем таймер и отправляем Enter
        SetTimer, AutoEnterTimer, Off
        if (isTyping)
            SendInput, {Enter}
        
        ; Применяем задержку после сообщения
        if (effAfterSendDelay > 0 && isTyping)
            Sleep, %effAfterSendDelay%
    }
}

; === Таймер для автозавершения ===
AutoEnterTimer:
    global isTyping
    ; Проверяем, идет ли еще печать
    if (isTyping) {
        SendInput, {Enter}
    }
    SetTimer, AutoEnterTimer, Off
return

; === Запуск ===
StartTyping:
    Gui, 1:Submit, NoHide

    if (TypeText = "" && TypingMode != "Генератор текста" && TypingMode != "По слотам" && TypingMode != "Legit-режим" && TypingMode != "Rage-режим" && TypingMode != "Печать через нейросеть") {
        MsgBox Пожалуйста, введите текст!
        return
    }
    
    if (TypingMode = "По слотам" && slots.Length() = 0) {
        MsgBox Пожалуйста, создайте хотя бы один слот!
        return
    }

    if (TypingMode = "Генератор текста") {
        global currentTemplate, genCurrentTemplate, genCurrentCategory, genCurrentSubcategory
        ; Проверяем новую систему шаблонов
        if (genCurrentTemplate != "" && genCurrentCategory != "" && genCurrentSubcategory != "") {
            ; Новая система - всё ок
        } else {
            ; Старая система
            if (currentTemplate = "") {
                currentTemplate := GetSelectedTemplates()
            }
            if (currentTemplate = "") {
                MsgBox Пожалуйста, выберите шаблон для генерации!
                return
            }
        }
    }

    ; Проверка скорости в зависимости от типа
    if (SpeedType != "Вставка через буфер обмена") {
        if (!RegExMatch(SpeedInput, "^\d+$") || SpeedInput <= 0) {
            MsgBox Укажи корректное значение скорости!
            return
        }
    }

    if (!RegExMatch(RepeatInput, "^\d+$")) {
        MsgBox Повторы должны быть числом!
        return
    }

    if (AutoEnterMode = 2 && (!RegExMatch(MaxWordsInput, "^\d+$"))) {
        MsgBox Макс. количество слов должно быть числом!
        return
    }
    
    if (AutoEnterMode = 3 && (!RegExMatch(TimeInput, "^\d+$") || TimeInput <= 0)) {
        MsgBox Укажите корректное время!
        return
    }
    
    if (ErrorGenLevel = 7 && (!RegExMatch(CustomErrorCount, "^\d+$") || CustomErrorCount <= 0)) {
        MsgBox Укажите корректное количество ошибок!
        return
    }

    ; Словарь: запоминаем текущий TypeText при старте (только внутри AutoTyper)
    if (dictEnabled && dictCaptureOnStart && TypeText != "")
        DictCapture(TypeText, "TypeTextStart")

    global stealthMessageCounter, stealthLongConfirmGiven
    global stealthRecentCanonicals, stealthRecentSet, stealthLastCanonical, stealthLastSentText
    stealthMessageCounter := 0
    stealthLongConfirmGiven := false
    stealthRecentCanonicals := []
    stealthRecentSet := {}
    stealthLastCanonical := ""
    stealthLastSentText := ""

    repeatCount := RepeatInput
    isTyping := true
    global printTimeDeadline, printTimeLimitHit
    printTimeDeadline := 0
    printTimeLimitHit := false
    usedLines := []  ; Очищаем список использованных строк при старте
    SetTimer, DoAutoType, -50
return

; === Остановка ===
StopTyping:
    isTyping := false
    global printTimeDeadline, printTimeLimitHit
    printTimeDeadline := 0
    printTimeLimitHit := false
    SetTimer, AutoEnterTimer, Off
return

; === Экстренная остановка печати (на случай зависаний/непредвиденных отправок) ===
EmergencyStopTyping:
    global isTyping, printTimeDeadline, printTimeLimitHit
    isTyping := false
    printTimeDeadline := 0
    printTimeLimitHit := false
    SetTimer, AutoEnterTimer, Off
    SetTimer, DoAutoType, Off
    ; На всякий случай "отпускаем" модификаторы
    SendInput, {Ctrl up}{Shift up}{Alt up}{LWin up}{RWin up}
    try SB_SetText("ЭКСТРЕННАЯ ОСТАНОВКА", 1)
return

; === Смена режима печати ===
TypingModeChanged:
    Gui, 1:Submit, NoHide
    SB_SetText("Режим: " . TypingMode, 1)
return

; === Автотайп логика ===
DoAutoType:
    global isTyping
    loopCount := 0
    isPaused := false

    Loop {
        if (!isTyping)
            break

        Gui, 1:Submit, NoHide
        
        ; === LEGIT-РЕЖИМ ===
        if (TypingMode = "Legit-режим") {
            global legitModeEnabled
            SB_SetText("Legit-режим...", 3)
            
            ; Получаем текст для печати
            legitText := TypeText
            if (legitText = "") {
                ; Пробуем генератор
                global genCurrentTemplate, genCurrentCategory, genCurrentSubcategory
                if (genCurrentTemplate != "" && genCurrentCategory != "" && genCurrentSubcategory != "") {
                    legitText := GenerateTextNew()
                }
            }
            
            if (legitText = "") {
                MsgBox, 48, Ошибка, Введите текст или выберите шаблон для Legit-режима!
                isTyping := false
                break
            }
            
            ; Используем Legit-печать
            LegitTypeTextFull(legitText)
            
            ; Нажимаем Enter после печати
            Send, {Enter}
            
            loopCount++
            SB_SetText("Цикл: " . loopCount . " из " . (repeatCount = 0 ? "∞" : repeatCount), 2)
            
            if (repeatCount != 0 && loopCount >= repeatCount)
                break
            
            continue
        }
        
        ; === RAGE-РЕЖИМ ===
        global rageModeEnabled
        if (rageModeEnabled || TypingMode = "Rage-режим") {
            SB_SetText("🔥 RAGE-режим...", 3)
            rageText := BuildRageMessageText()
            if (rageText = "") {
                MsgBox, 48, Ошибка, Не удалось собрать текст для Rage-режима!`nПроверьте вкладку "Текст" и шаблоны TreeView.
                isTyping := false
                break
            }
            
            if (rageDispatchEnabled && rageDispatchMessageCount > 0) {
                rageBurstSentCounter := 0
                lastBurstMessage := ""
                totalMs := RageDispatchToMs(rageDispatchTimeValue, rageDispatchTimeUnit)
                if (totalMs < 0)
                    totalMs := 0
                msgDelay := totalMs > 0 ? (totalMs / rageDispatchMessageCount) : 0
                forceInstantMode := RageBurstOptForceInstant && (totalMs > 0) && (totalMs <= RageBurstForceThresholdMs)
                uniqueMap := {}
                burstStartTick := A_TickCount
                
                Loop, % rageDispatchMessageCount {
                    if (!isTyping)
                        break
                    
                    if (RageBurstOptAutoRebuild) {
                        currentRageText := BuildRageMessageText()
                    } else {
                        currentRageText := rageText
                    }
                    if (currentRageText = "")
                        currentRageText := rageText
                    
                    if (RageBurstOptRetry && currentRageText = "") {
                        retryTry := RageBurstRetryCount + 0
                        while (retryTry > 0 && currentRageText = "") {
                            Sleep, % (RageBurstRetryDelay + 0)
                            currentRageText := BuildRageMessageText()
                            retryTry--
                        }
                    }
                    
                    if (RageBurstOptDedupe && currentRageText = lastBurstMessage) {
                        dedupeTry := RageBurstDedupeAttempts + 0
                        while (dedupeTry > 0 && currentRageText = lastBurstMessage) {
                            currentRageText := BuildRageMessageText()
                            dedupeTry--
                        }
                    }
                    
                    if (RageBurstOptStrictUnique) {
                        uniqueTry := Max(1, RageBurstUniqueAttempts + 0)
                        while (uniqueTry > 0 && uniqueMap.HasKey(currentRageText)) {
                            currentRageText := BuildRageMessageText()
                            uniqueTry--
                        }
                        if (uniqueMap.HasKey(currentRageText) && RageBurstUniqueSuffix) {
                            currentRageText .= " [u" . A_TickCount . "-" . A_Index . "]"
                        }
                        uniqueMap[currentRageText] := 1
                    }
                    
                    if (RageBurstOptRandomCase)
                        currentRageText := ApplyBurstRandomCase(currentRageText, RageBurstRandomCaseChance)
                    if (RageBurstOptRandomPunct)
                        currentRageText := ApplyBurstRandomPunctuation(currentRageText, RageBurstRandomPunctChance)
                    
                    if (RageBurstOptPrefixCounter) {
                        counterMsgNum := rageBurstSentCounter + 1
                        currentRageText := ApplyBurstCounterPrefix(currentRageText, counterMsgNum, RageBurstCounterFormat)
                    }

                    if (dictEnabled && dictCaptureSentMessages)
                        DictCapture(currentRageText, "BurstSend")
                    
                    RageTypeText(currentRageText)
                    lastBurstMessage := currentRageText
                    rageBurstSentCounter++
                    Send, {Enter}
                    
                    dynamicDelay := forceInstantMode ? 0 : msgDelay
                    
                    if (!RageOverrideRateLimit && RageBurstOptAdaptiveRate && RageBurstRateLimit > 0) {
                        minByRate := 1000 / (RageBurstRateLimit + 0)
                        if (dynamicDelay < minByRate)
                            dynamicDelay := minByRate
                    }
                    
                    if (RageBurstOptWarmup && RageBurstWarmupCount > 0 && A_Index <= RageBurstWarmupCount) {
                        warmPart := (RageBurstWarmupCount - A_Index + 1) / RageBurstWarmupCount
                        dynamicDelay += Round((RageBurstWarmupStartMs + 0) * warmPart)
                    }
                    
                    if (RageBurstOptJitter) {
                        jMin := RageBurstJitterMin + 0
                        jMax := RageBurstJitterMax + 0
                        if (jMax < jMin) {
                            tmp := jMin
                            jMin := jMax
                            jMax := tmp
                        }
                        Random, jitterVal, %jMin%, %jMax%
                        dynamicDelay += jitterVal
                    }
                    
                    if (!RageOverrideFloodProtection && RageBurstOptPacketPause && RageBurstPacketSize2 > 0 && Mod(A_Index, RageBurstPacketSize2) = 0)
                        dynamicDelay += RageBurstPacketPauseMs + 0
                    if (!RageOverrideFloodProtection && RageAdvEnablePacketDelay && RageAdvBurstPacketSize > 0 && Mod(A_Index, RageAdvBurstPacketSize) = 0)
                        dynamicDelay += RageAdvBurstPacketDelay + 0
                    if (!RageOverrideFloodProtection && RageBurstOptCooldown && RageBurstCooldownEvery > 0 && Mod(A_Index, RageBurstCooldownEvery) = 0)
                        dynamicDelay += RageBurstCooldownMs + 0
                    
                    if (RageBurstOptStats && RageBurstStatsInterval > 0 && Mod(A_Index, RageBurstStatsInterval) = 0) {
                        SB_SetText("Burst: " . A_Index . "/" . rageDispatchMessageCount . " | Задержка " . Round(dynamicDelay) . " мс", 3)
                    }
                    
                    ; Стратегии отправки влияют на итоговую задержку между отправками
                    if (RageAdvBurstStrategy2) {
                        dynamicDelay := dynamicDelay / Max(1, RageAdvBurstThreads + 0)
                    } else if (RageAdvBurstStrategy3) {
                        dynamicDelay := dynamicDelay * 0.75
                    } else if (RageAdvBurstStrategy4) {
                        dynamicDelay := dynamicDelay / Max(1, (RageAdvBurstThreads + 0) / 2)
                    }
                    
                    if (RageOverrideAll || RageOverrideSpeed || RageOverrideDelay)
                        dynamicDelay := 0
                    
                    if (dynamicDelay >= 1)
                        Sleep, % Round(dynamicDelay)
                }
                burstElapsed := A_TickCount - burstStartTick
                SB_SetText("Burst отправлено: " . rageBurstSentCounter . " / " . rageDispatchMessageCount . " за " . burstElapsed . " мс", 3)
            } else {
                if (dictEnabled && dictCaptureSentMessages)
                    DictCapture(rageText, "RageSend")
                RageTypeText(rageText)
                Send, {Enter}
            }
            
            loopCount++
            SB_SetText("🔥 Цикл: " . loopCount . " из " . (repeatCount = 0 ? "∞" : repeatCount), 2)
            
            if (repeatCount != 0 && loopCount >= repeatCount)
                break
            
            continue
        }

        if (TypingMode = "Печать через нейросеть") {
            SB_SetText("🤖 Нейросеть...", 3)
            if (NeuroApiKey = "") {
                MsgBox, 48, Ошибка, Укажите API ключ во вкладке "Нейросеть".
                isTyping := false
                break
            }
            effUser := NeuroEffectiveUserPrompt(NeuroUserPrompt)
            if (effUser = "") {
                MsgBox, 48, Ошибка, Введите запрос во вкладке "Нейросеть" или включите "Разрешить пустой запрос" и выберите контекст (TreeView).
                isTyping := false
                break
            }
            effSys := NeuroEffectiveSystemPrompt(NeuroSystemPrompt)
            genText := NeuroOpenRouterChatCompletion(NeuroApiKey, NeuroModel, effSys, effUser)
            wc := NeuroGenWordCount + 0
            if (wc > 0) {
                if (NeuroCountWords(genText) < wc)
                    genText := NeuroFixUpToWordCount(NeuroApiKey, NeuroModel, effSys, genText, wc)
                genText := NeuroTrimToWordCount(genText, wc)
            }
            if (genText = "") {
                MsgBox, 48, Ошибка, Не удалось получить ответ нейросети.
                isTyping := false
                break
            }
            messages := [genText]
            SB_SetText("🤖 Нейросеть: печать...", 3)
        }
        else if (TypingMode = "Генератор текста") {
            global genCurrentTemplate, genCurrentCategory, genCurrentSubcategory
            ; Пробуем новую систему генерации
            if (genCurrentTemplate != "" && genCurrentCategory != "" && genCurrentSubcategory != "") {
                genText := GenerateTextNew()
            } else {
                genText := GenerateFromTemplate()
            }
            if (genText = "") {
                MsgBox, 48, Ошибка, Не удалось сгенерировать текст! Проверьте шаблон.
                isTyping := false
                break
            }
            messages := [genText]
            SB_SetText("Генерация из шаблона...", 3)
        }
        else if (TypingMode = "По слотам") {
            ; Режим по слотам - обрабатываем каждый слот отдельно
            SB_SetText("Режим по слотам...", 3)
            global slotsRepeatCount, slotsErrorLevel, slotsCapitalizeFirst, slotsPrintTranslit, slotsStartPosition
            
            ; Определяем порядок слотов в зависимости от настройки
            slotsToProcess := []
            if (slotsStartPosition = "С начала") {
                slotsToProcess := slots
            } else if (slotsStartPosition = "С середины") {
                totalSlots := slots.Length()
                midIndex := Floor(totalSlots / 2)
                Loop % totalSlots {
                    idx := Mod(midIndex + A_Index - 1, totalSlots) + 1
                    slotsToProcess.Push(slots[idx])
                }
            } else if (slotsStartPosition = "С конца") {
                Loop % slots.Length() {
                    slotsToProcess.Push(slots[slots.Length() - A_Index + 1])
                }
            } else if (slotsStartPosition = "Случайно") {
                ; Создаем случайный порядок слотов
                indices := []
                Loop % slots.Length() {
                    indices.Push(A_Index)
                }
                ; Перемешиваем индексы
                Loop % indices.Length() {
                    Random, randIdx, %A_Index%, % indices.Length()
                    temp := indices[A_Index]
                    indices[A_Index] := indices[randIdx]
                    indices[randIdx] := temp
                }
                for i, idx in indices {
                    slotsToProcess.Push(slots[idx])
                }
            } else {
                slotsToProcess := slots
            }
            
            ; Повторяем цикл указанное количество раз
            Loop, %slotsRepeatCount% {
                if (!isTyping)
                    break
                
                for slotIndex, slot in slotsToProcess {
                    if (!isTyping)
                        break
                    
                    ; Обрабатываем текст слота
                    slotText := slot.text
                    
                    ; Применяем ошибки если указано
                    if (slotsErrorLevel != "Нет") {
                        slotText := AddErrors(slotText, slotsErrorLevel)
                    }
                    
                    ; Первая буква всегда заглавная
                    if (slotsCapitalizeFirst) {
                        if (RegExMatch(slotText, "^[a-zа-яё]", firstChar)) {
                            StringUpper, firstChar, firstChar
                            slotText := firstChar . SubStr(slotText, 2)
                        }
                    }
                    
                    ; Печать транслитом
                    if (slotsPrintTranslit = "Включено") {
                        slotText := Transliterate(slotText)
                    }
                    
                    ; Отправляем текст слота с его собственной скоростью
                    SendMessage(slotText, slot.speed)
                    
                    ; Если это не последний слот, делаем задержку
                    if (slotIndex < slotsToProcess.Length()) {
                        delayMs := 0
                        if (slot.delayUnit = "Секунды") {
                            delayMs := slot.delay * 1000
                        } else if (slot.delayUnit = "Минуты") {
                            delayMs := slot.delay * 60000
                        }
                        
                        if (delayMs > 0) {
                            SB_SetText("Задержка перед следующим слотом: " . slot.delay . " " . slot.delayUnit, 3)
                            Sleep, %delayMs%
                        }
                    }
                }
            }
            ; После обработки всех слотов завершаем цикл
            isTyping := false
            break
        }
        else {
            messages := StrSplit(TypeText, "`n")
            SB_SetText("Режим текста...", 3)
        }

        if (RandomizeMessages && TypingMode != "Генератор текста") {
            ; Случайный выбор строки с учетом "Не повторять текст" + опциональные веса (верх/середина/низ/случайно)
            rIndex := PickRandomLineIndex(messages, usedLines, NoRepeatText)
            if (!rIndex)
                rIndex := 1
            selectedMessage := messages[rIndex]
            messageList := [selectedMessage]
        } else {
            ; Обработка начальной позиции при последовательном выборе
            if (StartPosition != "С начала" && GenerationMode != "Трансформер (AI)") {
                totalLines := messages.Length()
                if (StartPosition = "С середины") {
                    startIdx := Floor(totalLines / 2)
                    newMessages := []
                    Loop % totalLines {
                        idx := Mod(startIdx + A_Index - 1, totalLines) + 1
                        newMessages.Push(messages[idx])
                    }
                    messages := newMessages
                } else if (StartPosition = "С конца") {
                    reversedMessages := []
                    Loop % totalLines {
                        reversedMessages.Push(messages[totalLines - A_Index + 1])
                    }
                    messages := reversedMessages
                } else if (StartPosition = "Начать со строки") {
                    ; Use StartLineNumber to rotate messages starting from that line
                    if (!StartLineNumber || StartLineNumber < 1)
                        StartLineNumber := 1
                    if (StartLineNumber > totalLines)
                        StartLineNumber := totalLines
                    newMessages := []
                    Loop % totalLines {
                        idx := Mod(StartLineNumber - 1 + A_Index - 1, totalLines) + 1
                        newMessages.Push(messages[idx])
                    }
                    messages := newMessages
                }
            }
            
            messageList := messages
        }

        ; === ПРИМЕНЕНИЕ ОГРАНИЧЕНИЙ (слова/строки/время) ===
        global printTimeDeadline, printTimeLimitHit, PrintLimitCyclesEnabled, printLimitCycles
        printTimeDeadline := 0
        printTimeLimitHit := false
        
        cycleNum := loopCount + 1
        limitType := PrintLimitType
        wordLimit := PrintWordLimit + 0
        lineLimit := PrintLineLimit + 0
        timeMs := 0
        timeDisplay := ""
        
        ; Если включены циклы - берём лимит из списка (по кругу)
        if (PrintLimitCyclesEnabled) {
            if (IsObject(printLimitCycles) && printLimitCycles.Length() > 0) {
                idx := Mod(cycleNum - 1, printLimitCycles.Length()) + 1
                c := printLimitCycles[idx]
                if (IsObject(c)) {
                    if (c.type = "words") {
                        limitType := 2
                        wordLimit := c.value + 0
                    } else if (c.type = "lines") {
                        limitType := 3
                        lineLimit := c.value + 0
                    } else if (c.type = "time") {
                        limitType := 4
                        timeMs := PrintLimitTimeToMs(c.value, c.unit)
                        timeDisplay := PrintLimitCycleLimitText(c)
                    } else {
                        limitType := 1
                    }
                }
            } else {
                ; Циклы включены, но список пуст — считаем как "без ограничений"
                limitType := 1
            }
        } else if (PrintLimitType = 4) {
            timeMs := PrintLimitTimeToMs(PrintTimeLimit, PrintTimeUnit)
            timeDisplay := PrintLimitCycleLimitText({type: "time", value: PrintTimeLimit, unit: PrintTimeUnit})
        }
        
        if (limitType = 2 && wordLimit > 0) {
            ; Ограничение по словам - собираем все слова из всех строк
            allWords := []
            for index, msg in messageList {
                words := StrSplit(msg, " `t", " `t")
                for i, word in words {
                    trimmedWord := Trim(word)
                    if (trimmedWord != "")
                        allWords.Push(trimmedWord)
                }
            }
            
            ; Берем только нужное количество слов
            limitedWords := []
            Loop % Min(wordLimit, allWords.Length()) {
                limitedWords.Push(allWords[A_Index])
            }
            
            ; Объединяем слова в одну строку
            resultText := ""
            for i, word in limitedWords {
                if (i > 1)
                    resultText .= " "
                resultText .= word
            }
            
            messageList := [resultText]
            SB_SetText("Ограничение: " . limitedWords.Length() . " из " . wordLimit . " слов", 3)
        } else if (limitType = 3 && lineLimit > 0) {
            ; Ограничение по строкам - берем N СЛУЧАЙНЫХ строк и объединяем их в одну
            limitedMessages := []
            maxLines := Min(lineLimit, messageList.Length())
            
            ; ВСЕГДА берем случайные строки (независимо от RandomizeMessages)
            usedIndices := []
            Loop % maxLines {
                Loop {
                    Random, randIdx, 1, % messageList.Length()
                    alreadyUsed := false
                    for i, usedIdx in usedIndices {
                        if (usedIdx = randIdx) {
                            alreadyUsed := true
                            break
                        }
                    }
                    if (!alreadyUsed) {
                        usedIndices.Push(randIdx)
                        limitedMessages.Push(messageList[randIdx])
                        break
                    }
                }
            }
            
            ; Объединяем все строки в одну через пробел
            combinedText := ""
            for idx, line in limitedMessages {
                if (idx > 1)
                    combinedText .= " "
                combinedText .= line
            }
            
            ; Заменяем messageList на одно объединённое сообщение
            messageList := [combinedText]
            SB_SetText("Ограничение: " . limitedMessages.Length() . " случайных строк из " . lineLimit, 3)
        } else if (limitType = 4 && timeMs > 0) {
            printTimeDeadline := A_TickCount + timeMs
            if (timeDisplay = "")
                timeDisplay := timeMs . " мс"
            SB_SetText("Ограничение: " . timeDisplay . " (цикл " . cycleNum . ")", 3)
        }

        for index, msg in messageList {
            if (!isTyping)
                break

            ; Добавляем ошибки в текст (старый генератор)
            msg := AddErrors(msg, ErrorLevelSetting)
            
            ; Изменяем регистр текста
            msg := ChangeTextCase(msg, TextCase)
            
            ; Применяем пользовательские вставки
            ; Если включена опция "Позиция вставки для Auto-Enter", и режим Auto-Enter — максимум слов,
            ; то отложим применение вставок на уровне фрагментов (в SendMessage), чтобы каждая часть
            ; получала вставку в указанной позиции. В противном случае применяем как раньше.
            if !(AutoEnterMode = 2 && AutoEnterInsertPerChunk)
                msg := ApplyCustomInserts(msg)

            ; Добавление префиксов
            fullMessage := ""
            if (PrefixInput != "")
                fullMessage .= PrefixInput . " "
            
            fullMessage .= msg
            
            if (MidfixInput != "")
                fullMessage .= " " . MidfixInput
            
            if (PostfixInput != "")
                fullMessage .= " " . PostfixInput

            ; Отправка сообщения
            SB_SetText("Отправка: " . SubStr(fullMessage, 1, 30) . "...", 3)
            if (dictEnabled && dictCaptureSentMessages)
                DictCapture(fullMessage, "SendMessage")
            SendMessage(fullMessage, SpeedInput)
            if (printTimeDeadline > 0 && printTimeLimitHit)
                break

            ; Сохраняем отправленное сообщение в память предыдущих сообщений для контекста
            if (!previousMessages)
                previousMessages := []
            previousMessages.Push(fullMessage)
            ; Ограничим длину памяти (например, 50 сообщений)
            if (previousMessages.Length() > 50)
                previousMessages.RemoveAt(1)

            ; Пауза между сообщениями (только если не в режиме Auto-Enter по словам)
            if (MessageDelay > 0 && A_Index < messageList.Length() && AutoEnterMode != 2) {
                m := GetSpeedMultiplierNum()
                sg := (SpeedType = "Вставка через буфер обмена") ? "clip" : SpeedGroupForEngine(SpeedSendEngine)
                eff := Floor(MessageDelay / m)
                minBetween := SpeedCfgNum(sg, "between_messages_min_ms", 0)
                if (eff < minBetween)
                    eff := minBetween
                if (eff > 0)
                    Sleep, %eff%
            }
        }

        loopCount++
        SB_SetText("Цикл: " . loopCount . " из " . (repeatCount = 0 ? "∞" : repeatCount), 2)
        
        if (repeatCount != 0 && loopCount >= repeatCount)
            break
    }

    isTyping := false
    SB_SetText("Завершено", 3)
return

; === Обновленная функция: Закрытие + сохранение ===
GuiClose:
GuiEscape:
    Gui, 1:Submit, NoHide
    
    if (AutoSave) {
        IniWrite, %TypeText%, %appDataDir%\AutoTyper.ini, Data, Text
        IniWrite, %SpeedInput%, %appDataDir%\AutoTyper.ini, Data, Speed
        IniWrite, %SpeedType%, %appDataDir%\AutoTyper.ini, Data, SpeedType
        IniWrite, %SpeedMultiplier%, %appDataDir%\AutoTyper.ini, Data, SpeedMultiplier
        Gui, 1:Submit, NoHide
        IniWrite, %ClipboardDelayInput%, %appDataDir%\AutoTyper.ini, Clipboard, DelayValue
        IniWrite, %ClipboardDelayUnit%, %appDataDir%\AutoTyper.ini, Clipboard, DelayUnit
        IniWrite, %RepeatInput%, %appDataDir%\AutoTyper.ini, Data, Repeat
        IniWrite, %PrefixInput%, %appDataDir%\AutoTyper.ini, Data, Prefix
        IniWrite, %MidfixInput%, %appDataDir%\AutoTyper.ini, Data, Midfix
        IniWrite, %PostfixInput%, %appDataDir%\AutoTyper.ini, Data, Postfix
        IniWrite, %MaxWordsInput%, %appDataDir%\AutoTyper.ini, Data, MaxWords
        IniWrite, %GenerateLength%, %appDataDir%\AutoTyper.ini, Data, GenLength
        IniWrite, %TypingMode%, %appDataDir%\AutoTyper.ini, Data, GenMode
        
        ; Сохраняем выбранные шаблоны из ListView
        checkedTemplates := GetSelectedTemplates()
        IniWrite, %checkedTemplates%, %appDataDir%\AutoTyper.ini, Generator, Template
        
        IniWrite, %GenerationMode%, %appDataDir%\AutoTyper.ini, Generator, Mode
        IniWrite, %GenLineCount%, %appDataDir%\AutoTyper.ini, Generator, LineCount
        IniWrite, %GenByLines%, %appDataDir%\AutoTyper.ini, Generator, ByLines
        IniWrite, %GenByWords%, %appDataDir%\AutoTyper.ini, Generator, ByWords
        IniWrite, %GenWordCount%, %appDataDir%\AutoTyper.ini, Generator, WordCount
        IniWrite, %GenCapitalize%, %appDataDir%\AutoTyper.ini, Generator, Capitalize
        IniWrite, %GenPunctuation%, %appDataDir%\AutoTyper.ini, Generator, Punctuation
        IniWrite, %GenTranslit%, %appDataDir%\AutoTyper.ini, Generator, Translit
        ; Сохраняем игнорируемые слова
        ignoredWordsStr := ""
        for i, word in ignoredWords {
            if (i > 1)
                ignoredWordsStr .= ","
            ignoredWordsStr .= word
        }
        IniWrite, %ignoredWordsStr%, %appDataDir%\AutoTyper.ini, Generator, IgnoredWords
        
        ; Сохраняем собственные слова
        customWordsStr := ""
        for i, item in customWords {
            if (i > 1)
                customWordsStr .= "|"
            ; Формат: слово:статус (1=включено, 0=выключено)
            status := item.enabled ? 1 : 0
            customWordsStr .= item.word . ":" . status
        }
        IniWrite, %customWordsStr%, %appDataDir%\AutoTyper.ini, Generator, CustomWords
        IniWrite, %ModelCapitalize%, %appDataDir%\AutoTyper.ini, Model, Capitalize
        IniWrite, %ModelPunctuation%, %appDataDir%\AutoTyper.ini, Model, Punctuation
        IniWrite, %ModelCommas%, %appDataDir%\AutoTyper.ini, Model, Commas
        IniWrite, %ErrorLevelSetting%, %appDataDir%\AutoTyper.ini, Settings, ErrorLevel
        ; Сохраняем настройки ошибок
        SaveErrorSettings()
        IniWrite, %Readability%, %appDataDir%\AutoTyper.ini, Settings, Readability
        IniWrite, %TextCase%, %appDataDir%\AutoTyper.ini, Settings, TextCase
        IniWrite, %CreativityLevel%, %appDataDir%\AutoTyper.ini, AI, Creativity
        IniWrite, %ContextWindow%, %appDataDir%\AutoTyper.ini, AI, ContextWindow
        IniWrite, %MessageDelay%, %appDataDir%\AutoTyper.ini, Settings, MessageDelay
        ; LineSeparator removed from UI — not saving this value
        IniWrite, %AutoCorrect%, %appDataDir%\AutoTyper.ini, Settings, AutoCorrect
        IniWrite, %AutoSave%, %appDataDir%\AutoTyper.ini, Settings, AutoSave
        IniWrite, %AutoBackup%, %appDataDir%\AutoTyper.ini, Settings, AutoBackup
        IniWrite, %AutoEnterMode%, %appDataDir%\AutoTyper.ini, AutoEnter, Mode
        IniWrite, %TimeInput%, %appDataDir%\AutoTyper.ini, AutoEnter, TimeInput
        IniWrite, %AutoEnterInsertPerChunk%, %appDataDir%\AutoTyper.ini, AutoEnter, InsertPerChunk
        IniWrite, %TimeUnit%, %appDataDir%\AutoTyper.ini, AutoEnter, TimeUnit
        IniWrite, %ErrorGenLevel%, %appDataDir%\AutoTyper.ini, ErrorGenerator, Level
        IniWrite, %CustomErrorCount%, %appDataDir%\AutoTyper.ini, ErrorGenerator, CustomCount
        IniWrite, %ErrorLocation%, %appDataDir%\AutoTyper.ini, ErrorGenerator, Location
        IniWrite, %ErrorWordsCount%, %appDataDir%\AutoTyper.ini, ErrorGenerator, WordsCount
        IniWrite, %ErrorWordsCustom%, %appDataDir%\AutoTyper.ini, ErrorGenerator, WordsCustom
        IniWrite, %RecordFileName%, %appDataDir%\AutoTyper.ini, Recording, FileName
        IniWrite, %RecordFolder%, %appDataDir%\AutoTyper.ini, Recording, Folder
        IniWrite, %RecordIncludeTimestamps%, %appDataDir%\AutoTyper.ini, Recording, IncludeTimestamps
        IniWrite, %RecordAutoSave%, %appDataDir%\AutoTyper.ini, Recording, AutoSave
        IniWrite, %RecordRemoveDuplicates%, %appDataDir%\AutoTyper.ini, Recording, RemoveDuplicates
        IniWrite, %RecordMaxChars%, %appDataDir%\AutoTyper.ini, Recording, MaxChars
        IniWrite, %MainDelayMode%, %appDataDir%\AutoTyper.ini, Delays, MainDelayMode
        IniWrite, %MainDelayValue%, %appDataDir%\AutoTyper.ini, Delays, MainDelayValue
        IniWrite, %PlaybackDelayMode%, %appDataDir%\AutoTyper.ini, Delays, PlaybackDelayMode
        IniWrite, %PlaybackDelayValue%, %appDataDir%\AutoTyper.ini, Delays, PlaybackDelayValue
        IniWrite, %NoRepeatText%, %appDataDir%\AutoTyper.ini, Data, NoRepeatText
        IniWrite, %StartPosition%, %appDataDir%\AutoTyper.ini, Data, StartPosition
        IniWrite, %PrintLimitType%, %appDataDir%\AutoTyper.ini, Data, PrintLimitType
        IniWrite, %PrintWordLimit%, %appDataDir%\AutoTyper.ini, Data, PrintWordLimit
        IniWrite, %PrintLineLimit%, %appDataDir%\AutoTyper.ini, Data, PrintLineLimit
        IniWrite, %PrintTimeLimit%, %appDataDir%\AutoTyper.ini, Data, PrintTimeLimit
        IniWrite, %PrintTimeUnit%, %appDataDir%\AutoTyper.ini, Data, PrintTimeUnit
        IniWrite, %PrintLimitCyclesEnabled%, %appDataDir%\AutoTyper.ini, Data, PrintLimitCyclesEnabled
        IniWrite, %RandomLineBiasEnabled%, %appDataDir%\AutoTyper.ini, Data, RandomLineBiasEnabled
	        IniWrite, %RandomLineChanceTop%, %appDataDir%\AutoTyper.ini, Data, RandomLineChanceTop
	        IniWrite, %RandomLineChanceMiddle%, %appDataDir%\AutoTyper.ini, Data, RandomLineChanceMiddle
	        IniWrite, %RandomLineChanceBottom%, %appDataDir%\AutoTyper.ini, Data, RandomLineChanceBottom
	        IniWrite, %RandomLineChanceRandom%, %appDataDir%\AutoTyper.ini, Data, RandomLineChanceRandom
	        IniWrite, %OpenTelegramOnStart%, %appDataDir%\AutoTyper.ini, Help, OpenTelegramOnStart
	        IniWrite, %ControlStartHotkey%, %appDataDir%\AutoTyper.ini, ControlHotkeys, Start
	        IniWrite, %ControlStopHotkey%, %appDataDir%\AutoTyper.ini, ControlHotkeys, Stop
	        IniWrite, %ControlPauseHotkey%, %appDataDir%\AutoTyper.ini, ControlHotkeys, Pause
	        IniWrite, %ControlEmergencyHotkey%, %appDataDir%\AutoTyper.ini, ControlHotkeys, Emergency
	    IniWrite, %TextShuffleLevel%, %appDataDir%\AutoTyper.ini, Settings, TextShuffle
    IniWrite, %ShuffleRandomMode%, %appDataDir%\AutoTyper.ini, Settings, ShuffleRandom
    IniWrite, %ShuffleLowProb%, %appDataDir%\AutoTyper.ini, Settings, ShuffleLowProb
    IniWrite, %ShuffleMediumBehavior%, %appDataDir%\AutoTyper.ini, Settings, ShuffleMediumBehavior
    IniWrite, %ShuffleHighSuffixProb%, %appDataDir%\AutoTyper.ini, Settings, ShuffleHighSuffixProb
    IniWrite, %ShuffleHighSuffixCount%, %appDataDir%\AutoTyper.ini, Settings, ShuffleHighSuffixCount
    IniWrite, %ShuffleExtremeMode%, %appDataDir%\AutoTyper.ini, Settings, ShuffleExtremeMode
    IniWrite, %savedSplitCustomList%, %appDataDir%\AutoTyper.ini, Split, CustomList
    IniWrite, %SplitSize%, %appDataDir%\AutoTyper.ini, Split, Size
    IniWrite, %SplitSource%, %appDataDir%\AutoTyper.ini, Split, Source
    IniWrite, %SplitManualInput%, %appDataDir%\AutoTyper.ini, Split, Manual
    ; Сохраняем настройки разделителя текста
    splitMethod := 1
    if (SplitMethodParagraphs)
        splitMethod := 2
    else if (SplitMethodCustom)
        splitMethod := 3
    IniWrite, %splitMethod%, %appDataDir%\AutoTyper.ini, TextSplitter, Method
    IniWrite, %SplitCharLimitSlider%, %appDataDir%\AutoTyper.ini, TextSplitter, CharLimit
    IniWrite, %SplitCustomDelimiter%, %appDataDir%\AutoTyper.ini, TextSplitter, Delimiter
    SaveSlots()
    IniWrite, %slotsRepeatCount%, %appDataDir%\AutoTyper.ini, Slots, RepeatCount
    IniWrite, %slotsErrorLevel%, %appDataDir%\AutoTyper.ini, Slots, ErrorLevel
    IniWrite, %slotsCapitalizeFirst%, %appDataDir%\AutoTyper.ini, Slots, CapitalizeFirst
    IniWrite, %slotsPrintTranslit%, %appDataDir%\AutoTyper.ini, Slots, PrintTranslit
    IniWrite, %slotsStartPosition%, %appDataDir%\AutoTyper.ini, Slots, StartPosition
    SaveLetterReplacements()  ; Сохраняем настройки замены букв
    SaveLetterRestrictions()  ; Сохраняем ограничения букв
    IniWrite, %PrintTranslit%, %appDataDir%\AutoTyper.ini, Settings, PrintTranslit
        IniWrite, %PlaybackRepeats%, %appDataDir%\AutoTyper.ini, Playback, Repeats
        IniWrite, %PlaybackDelayMode%, %appDataDir%\AutoTyper.ini, Delays, PlaybackDelayMode
        IniWrite, %PlaybackDelayValue%, %appDataDir%\AutoTyper.ini, Delays, PlaybackDelayValue
        
        ; Сохраняем новые данные
        Gosub, SaveLetterInsertsOnExit
        Gosub, SaveBindTemplatesOnExit
        Gosub, SavePrintLimitCyclesOnExit
        Gosub, SaveAutoEnterCyclesOnExit
        Gosub, SaveAutoEnterBindsOnExit
        Gosub, SaveInsertRulesOnExit
        
	        ; Multi-window feature removed — не сохраняем целевые окна
		    }
		    
		    ; Эти настройки должны сохраняться независимо от AutoSave
		    IniWrite, %OpenTelegramOnStart%, %appDataDir%\AutoTyper.ini, Help, OpenTelegramOnStart
		    IniWrite, %ControlStartHotkey%, %appDataDir%\AutoTyper.ini, ControlHotkeys, Start
		    IniWrite, %ControlStopHotkey%, %appDataDir%\AutoTyper.ini, ControlHotkeys, Stop
		    IniWrite, %ControlPauseHotkey%, %appDataDir%\AutoTyper.ini, ControlHotkeys, Pause
		    IniWrite, %ControlEmergencyHotkey%, %appDataDir%\AutoTyper.ini, ControlHotkeys, Emergency
		    IniWrite, %NeuroSystemPrompt%, %appDataDir%\AutoTyper.ini, Neuro, SystemPrompt
		    IniWrite, %NeuroUseTemplatesContext%, %appDataDir%\AutoTyper.ini, Neuro, UseTemplatesContext
		    IniWrite, %NeuroAllowEmptyPrompt%, %appDataDir%\AutoTyper.ini, Neuro, AllowEmptyPrompt
		    IniWrite, %NeuroGenWordCount%, %appDataDir%\AutoTyper.ini, Neuro, GenWordCount
		    
		    ; Словарь: финальная запись json + отключение таймера
		    DictWriteJsonSummary()
		    DictSaveSettingsToIni()
	    SetTimer, DictAutosaveTimer, Off
	    
	    ExitApp

; === Функции для разделителя текста ===
UpdateTextSplitterCharCount:
    Gui, 1:Submit, NoHide
    charCount := StrLen(TextSplitterInput)
    GuiControl,, TextSplitterCharCount, %charCount% Символы (UTF-8)
return

UpdateSplitMethod:
    Gui, 1:Submit, NoHide
    if (SplitMethodCustom) {
        GuiControl, Show, SplitCustomDelimiter
    } else {
        GuiControl, Hide, SplitCustomDelimiter
    }
return

UpdateSplitCharLimit:
    Gui, 1:Submit, NoHide
    GuiControl,, SplitCharLimitInput, %SplitCharLimitSlider%
    GuiControl,, SplitCharLimit, %SplitCharLimitSlider%
return

SplitTextButton:
    Gui, 1:Submit, NoHide
    
    if (TextSplitterInput = "") {
        MsgBox, 48, Ошибка, Введите текст для разделения!
        return
    }
    
    ; Получаем лимит символов
    charLimit := SplitCharLimitSlider
    
    ; Определяем метод разделения
    if (SplitMethodChars) {
        ; Разделение по символам
        result := SplitTextByChars(TextSplitterInput, charLimit)
    } else if (SplitMethodParagraphs) {
        ; Разделение по абзацам
        result := SplitTextByParagraphs(TextSplitterInput, charLimit)
    } else if (SplitMethodCustom) {
        ; Разделение по пользовательскому разделителю
        if (SplitCustomDelimiter = "") {
            MsgBox, 48, Ошибка, Введите разделитель!
            return
        }
        result := SplitTextByDelimiter(TextSplitterInput, SplitCustomDelimiter, charLimit)
    }
    
    ; Показываем результаты
    GuiControl,, TextSplitterOutput, %result%
return

; === Разделение текста по символам ===
SplitTextByChars(text, limit) {
    result := ""
    textLen := StrLen(text)
    
    if (textLen <= limit) {
        return text
    }
    
    pos := 1
    partNum := 1
    while (pos <= textLen) {
        part := SubStr(text, pos, limit)
        result .= "=== Часть " . partNum . " ===" . "`n" . part . "`n`n"
        pos += limit
        partNum++
    }
    
    return result
}

; === Разделение текста по абзацам ===
SplitTextByParagraphs(text, limit) {
    result := ""
    paragraphs := StrSplit(text, "`n`n")
    
    currentPart := ""
    partNum := 1
    
    for i, paragraph in paragraphs {
        if (paragraph = "")
            continue
        
        ; Проверяем, поместится ли абзац
        if (StrLen(currentPart) + StrLen(paragraph) + 2 > limit && currentPart != "") {
            result .= "=== Часть " . partNum . " ===" . "`n" . currentPart . "`n`n"
            currentPart := paragraph
            partNum++
        } else {
            if (currentPart != "")
                currentPart .= "`n`n"
            currentPart .= paragraph
        }
    }
    
    if (currentPart != "") {
        result .= "=== Часть " . partNum . " ===" . "`n" . currentPart
    }
    
    return result
}

; === Разделение текста по пользовательскому разделителю ===
SplitTextByDelimiter(text, delimiter, limit) {
    result := ""
    parts := StrSplit(text, delimiter)
    
    currentPart := ""
    partNum := 1
    
    for i, part in parts {
        if (part = "")
            continue
        
        ; Проверяем, поместится ли часть
        if (StrLen(currentPart) + StrLen(part) + StrLen(delimiter) > limit && currentPart != "") {
            result .= "=== Часть " . partNum . " ===" . "`n" . currentPart . "`n`n"
            currentPart := part
            partNum++
        } else {
            if (currentPart != "")
                currentPart .= delimiter
            currentPart .= part
        }
    }
    
    if (currentPart != "") {
        result .= "=== Часть " . partNum . " ===" . "`n" . currentPart
    }
    
    return result
}

; ============================================
; === ОБРАБОТЧИКИ ИСТОРИИ РАЗДЕЛЕНИЙ ===
; ============================================

LoadSplitHistory:
    MsgBox, 64, История разделений, Функция загрузки истории разделений в разработке.
    SB_SetText("История разделений загружена", 1)
return

ClearSplitHistory:
    MsgBox, 36, Подтверждение, Очистить историю разделений?
    IfMsgBox, No
        return
    
    Gui, 1:Default
    Gui, 1:ListView, SplitHistoryList
    LV_Delete()
    
    ; Сбрасываем статистику
    GuiControl,, SplitStatsBlocks, Блоков: 0
    GuiControl,, SplitStatsChars, Символов: 0
    GuiControl,, SplitStatsWords, Слов: 0
    
    SB_SetText("История разделений очищена", 1)
return

SplitTextCopy:
    Gui, 1:Submit, NoHide
    Clipboard := TextSplitterOutput
    SB_SetText("Результат скопирован в буфер обмена", 1)
return

SplitTextToMain:
    Gui, 1:Submit, NoHide
    GuiControl,, TypeText, %TextSplitterOutput%
    SB_SetText("Результат добавлен в основной текст", 1)
return

SplitTextClear:
    GuiControl,, TextSplitterInput,
    GuiControl,, TextSplitterOutput,
    GuiControl,, TextSplitterCharCount, 0 Символов (UTF-8)
    SB_SetText("Разделитель очищен", 1)
return

; ============================================
; === СЛОВАРЬ (локальный, внутри AutoTyper) ===
; ============================================

DictNowDate() {
    return A_YYYY "-" SubStr("0" . A_MM, -1) "-" SubStr("0" . A_DD, -1)
}

DictNowTime() {
    return A_Hour ":" A_Min ":" A_Sec
}

JsonEscape(s) {
    s := StrReplace(s, "\", "\\")
    s := StrReplace(s, """", "\""")
    s := StrReplace(s, "`r", "\r")
    s := StrReplace(s, "`n", "\n")
    s := StrReplace(s, "`t", "\t")
    return s
}

DictNormalizeText(text) {
    global dictNormalizeLower, dictStripPunct, dictCollapseSpaces, dictIgnoreNumbers
    global dictStripUrls, dictStripEmails, dictStripMentions, dictStripHashtags, dictStripEmojis
    global dictKeepCyrillicOnly, dictKeepLatinOnly, dictMaxCharsPerEvent
    
    t := text
    if (dictMaxCharsPerEvent > 0 && StrLen(t) > dictMaxCharsPerEvent)
        t := SubStr(t, 1, dictMaxCharsPerEvent)
    
    if (dictStripUrls)
        t := RegExReplace(t, "i)\bhttps?://\S+|\bwww\.\S+", "")
    if (dictStripEmails)
        t := RegExReplace(t, "i)\b[\w\.\-\+]+@[\w\.\-]+\.\w+\b", "")
    if (dictStripMentions)
        t := RegExReplace(t, "(@\w+)", "")
    if (dictStripHashtags)
        t := RegExReplace(t, "(#\w+)", "")
    if (dictStripEmojis)
        t := RegExReplace(t, "[^\x00-\x7F]", "") ; грубо, но быстро
    
    if (dictIgnoreNumbers)
        t := RegExReplace(t, "\d+", "")
    
    if (dictStripPunct)
        t := RegExReplace(t, "[^\w\sА-Яа-яЁё]+", " ")
    
    if (dictNormalizeLower) {
        StringLower, t, t
    }
    
    if (dictKeepCyrillicOnly)
        t := RegExReplace(t, "[^А-Яа-яЁё\s]+", " ")
    if (dictKeepLatinOnly)
        t := RegExReplace(t, "[^A-Za-z\s]+", " ")
    
    if (dictCollapseSpaces) {
        t := RegExReplace(t, "\s+", " ")
        t := Trim(t)
    }
    
    return t
}

DictStopWordsSet() {
    global dictStopWordsText
    set := {}
    if (Trim(dictStopWordsText) = "")
        return set
    arr := StrSplit(dictStopWordsText, ["`n", "`r", ",", ";"])
    for i, w in arr {
        w := Trim(w)
        if (w != "")
            set[w] := 1
    }
    return set
}

DictCapture(text, source := "unknown") {
    global dictEnabled, dictDir
    global dictStoreEvents, dictStoreWords, dictStoreLines, dictNoRepeatEvents
    global dictStoreJsonl, dictJsonlMaxMB
    global dictDayEvents, dictWordFreq, dictLineFreq
    global dictMinWordLen, dictMaxWordLen, dictTopWordsOnlyLetters
    global dictEnableBigrams, dictEnableTrigrams, dictBigramsFreq, dictTrigramsFreq
    global dictMaxEventsPerDay, dictAppendSourceTag, dictAppendTimestamp, dictAppendNewline
    static lastEventText := ""
    
    if (!dictEnabled)
        return
    
    raw := Trim(text, "`r`n`t ")
    if (raw = "")
        return
    
    if (dictNoRepeatEvents && raw = lastEventText)
        return
    
    day := DictNowDate()
    ts := DictNowTime()
    
    if (dictStoreEvents) {
        if (dictDayEvents.Length() < dictMaxEventsPerDay) {
            dictDayEvents.Push({ts: ts, source: source, text: raw})
        }
    }
    
    norm := DictNormalizeText(raw)
    if (norm = "")
        return
    
    stop := DictStopWordsSet()
    
    if (dictStoreLines) {
        lines := StrSplit(norm, "`n", "`r")
        for i, ln in lines {
            ln := Trim(ln)
            if (ln = "")
                continue
            dictLineFreq[ln] := dictLineFreq.HasKey(ln) ? (dictLineFreq[ln] + 1) : 1
        }
    }
    
    if (dictStoreWords) {
        words := StrSplit(norm, " ")
        prev1 := ""
        prev2 := ""
        for i, w in words {
            w := Trim(w)
            if (w = "")
                continue
            if (dictTopWordsOnlyLetters && !RegExMatch(w, "^[A-Za-zА-Яа-яЁё]+$"))
                continue
            if (StrLen(w) < dictMinWordLen)
                continue
            if (dictMaxWordLen > 0 && StrLen(w) > dictMaxWordLen)
                continue
            if (stop.HasKey(w))
                continue
            
            dictWordFreq[w] := dictWordFreq.HasKey(w) ? (dictWordFreq[w] + 1) : 1
            
            if (dictEnableBigrams && prev1 != "") {
                bi := prev1 . " " . w
                dictBigramsFreq[bi] := dictBigramsFreq.HasKey(bi) ? (dictBigramsFreq[bi] + 1) : 1
            }
            if (dictEnableTrigrams && prev2 != "" && prev1 != "") {
                tri := prev2 . " " . prev1 . " " . w
                dictTrigramsFreq[tri] := dictTrigramsFreq.HasKey(tri) ? (dictTrigramsFreq[tri] + 1) : 1
            }
            prev2 := prev1
            prev1 := w
        }
    }
    
    ; Пишем в ежедневный txt сразу (чтобы не потерять при краше)
    txtPath := dictDir . "\" . day . ".txt"
    prefix := ""
    if (dictAppendTimestamp)
        prefix .= "[" . day . " " . ts . "] "
    if (dictAppendSourceTag)
        prefix .= "(" . source . ") "
    lineOut := prefix . raw . (dictAppendNewline ? "`r`n" : "")
    FileAppend, %lineOut%, %txtPath%, UTF-8

    ; Под датасет: отдельный JSONL (с raw+norm)
    if (dictStoreJsonl)
        DictAppendJsonlEvent(day, ts, source, raw, norm, dictJsonlMaxMB)
    
    lastEventText := raw
}

DictAppendJsonlEvent(day, ts, source, raw, norm, maxMB := 50) {
    global dictDir, TypingMode
    path := dictDir . "\" . day . ".events.jsonl"

    ; Ротация при превышении лимита (простая)
    if (maxMB > 0) {
        maxBytes := maxMB * 1024 * 1024
        if (FileExist(path)) {
            FileGetSize, sz, %path%
            if (sz >= maxBytes) {
                Loop, 20 {
                    rotated := dictDir . "\" . day . ".events-" . A_Index . ".jsonl"
                    if (!FileExist(rotated)) {
                        FileMove, %path%, %rotated%, 1
                        break
                    }
                }
            }
        }
    }

    chars := StrLen(raw)
    words := CountWords(raw)
    lines := CountLines(raw)

    j := "{"
    j .= """date"":""" . day . ""","
    j .= """ts"":""" . JsonEscape(ts) . ""","
    j .= """source"":""" . JsonEscape(source) . ""","
    j .= """mode"":""" . JsonEscape(TypingMode) . ""","
    j .= """chars"":" . (chars + 0) . ","
    j .= """words"":" . (words + 0) . ","
    j .= """lines"":" . (lines + 0) . ","
    j .= """raw"":""" . JsonEscape(raw) . ""","
    j .= """norm"":""" . JsonEscape(norm) . """"
    j .= "}`r`n"

    FileAppend, %j%, %path%, UTF-8
}

DictBuildTopList(freqObj, limit := 100) {
    tmp := ""
    for k, v in freqObj {
        tmp .= v . "`t" . k . "`n"
    }
    Sort, tmp, N R
    out := []
    Loop, Parse, tmp, `n, `r
    {
        if (A_LoopField = "")
            continue
        parts := StrSplit(A_LoopField, "`t")
        if (parts.Length() < 2)
            continue
        count := parts[1] + 0
        val := parts[2]
        out.Push({v: val, c: count})
        if (out.Length() >= limit)
            break
    }
    return out
}

DictWriteJsonSummary() {
    global dictDir, dictDayEvents, dictWordFreq, dictLineFreq
    global dictTopWordsLimit, dictTopLinesLimit, dictCollectTopLines
    
    day := DictNowDate()
    jsonPath := dictDir . "\" . day . ".json"
    
    topWords := DictBuildTopList(dictWordFreq, dictTopWordsLimit)
    topLines := dictCollectTopLines ? DictBuildTopList(dictLineFreq, dictTopLinesLimit) : []
    
    json := "{"
    json .= """date"":""" . day . ""","
    json .= """events"":" . dictDayEvents.Length() . ","
    json .= """unique_words"":" . dictWordFreq.Count() . ","
    json .= """unique_lines"":" . dictLineFreq.Count() . ","
    json .= """top_words"":["
    for i, it in topWords {
        if (i > 1)
            json .= ","
        json .= "{""w"":""" . JsonEscape(it.v) . """,""c"":" . it.c . "}"
    }
    json .= "],"
    json .= """top_lines"":["
    for i, it in topLines {
        if (i > 1)
            json .= ","
        json .= "{""l"":""" . JsonEscape(it.v) . """,""c"":" . it.c . "}"
    }
    json .= "]"
    json .= "}"
    
    FileDelete, %jsonPath%
    FileAppend, %json%, %jsonPath%, UTF-8
}

DictUpdateTimer() {
    global dictAutosaveEnabled, dictAutosaveIntervalSec
    if (dictAutosaveEnabled && dictAutosaveIntervalSec > 0) {
        SetTimer, DictAutosaveTimer, % (dictAutosaveIntervalSec * 1000)
    } else {
        SetTimer, DictAutosaveTimer, Off
    }
}

DictAutosaveTimer:
    DictWriteJsonSummary()
return

DictRefreshTree:
    RefreshDictTree()
return

DictTreeSelect:
    global dictTreeData
    Gui, 1:Default
    Gui, 1:TreeView, DictTree
    item := TV_GetSelection()
    if (!item)
        return
    if (!dictTreeData.HasKey(item))
        return
    path := dictTreeData[item]
    if (FileExist(path)) {
        FileRead, content, %path%
        if (StrLen(content) > 4000)
            content := SubStr(content, 1, 4000) . "`n... [обрезано]"
        GuiControl,, DictPreview, %content%
    }
return

DictSaveSnapshot:
    global dictDir
    day := DictNowDate()
    InputBox, snapName, Снимок словаря, Имя снимка:, , 320, 130
    if (ErrorLevel || snapName = "")
        return
    savedDir := dictDir . "\saved"
    if (!FileExist(savedDir))
        FileCreateDir, %savedDir%
    srcTxt := dictDir . "\" . day . ".txt"
    srcJson := dictDir . "\" . day . ".json"
    srcEvents := dictDir . "\" . day . ".events.jsonl"
    DictWriteJsonSummary()
    dstTxt := savedDir . "\" . snapName . "-" . day . ".txt"
    dstJson := savedDir . "\" . snapName . "-" . day . ".json"
    dstEvents := savedDir . "\" . snapName . "-" . day . ".events.jsonl"
    if (FileExist(srcTxt))
        FileCopy, %srcTxt%, %dstTxt%, 1
    if (FileExist(srcJson))
        FileCopy, %srcJson%, %dstJson%, 1
    if (FileExist(srcEvents))
        FileCopy, %srcEvents%, %dstEvents%, 1
    RefreshDictTree()
return

DictDeleteSelected:
    global dictTreeData
    Gui, 1:Default
    Gui, 1:TreeView, DictTree
    item := TV_GetSelection()
    if (!item)
        return
    if (!dictTreeData.HasKey(item))
        return
    path := dictTreeData[item]
    MsgBox, 36, Подтверждение, Удалить файл?`n%path%
    IfMsgBox, No
        return
    FileDelete, %path%
    RefreshDictTree()
    GuiControl,, DictPreview,
return

RefreshDictTree() {
    global dictDir, dictTreeData
    Gui, 1:Default
    Gui, 1:TreeView, DictTree
    TV_Delete()
    dictTreeData := {}
    
    rootDaily := TV_Add("Дни", 0, "Expand")
    Loop, Files, %dictDir%\*.txt
    {
        name := StrReplace(A_LoopFileName, ".txt", "")
        dayItem := TV_Add(name, rootDaily)
        txtItem := TV_Add("TXT", dayItem)
        dictTreeData[txtItem] := dictDir . "\" . A_LoopFileName
        jsonPath := dictDir . "\" . name . ".json"
        if (FileExist(jsonPath)) {
            jsonItem := TV_Add("JSON", dayItem)
            dictTreeData[jsonItem] := jsonPath
        }
        eventsPath := dictDir . "\" . name . ".events.jsonl"
        if (FileExist(eventsPath)) {
            eventsItem := TV_Add("JSONL", dayItem)
            dictTreeData[eventsItem] := eventsPath
        }
    }
    
    savedDir := dictDir . "\saved"
    if (FileExist(savedDir)) {
        rootSaved := TV_Add("Снимки", 0, "Expand")
        Loop, Files, %savedDir%\*.txt
        {
            snapItem := TV_Add(A_LoopFileName, rootSaved)
            dictTreeData[snapItem] := savedDir . "\" . A_LoopFileName
        }
        Loop, Files, %savedDir%\*.json
        {
            snapItem := TV_Add(A_LoopFileName, rootSaved)
            dictTreeData[snapItem] := savedDir . "\" . A_LoopFileName
        }
        Loop, Files, %savedDir%\*.jsonl
        {
            snapItem := TV_Add(A_LoopFileName, rootSaved)
            dictTreeData[snapItem] := savedDir . "\" . A_LoopFileName
        }
    }
}

DictSettingsRefresh:
    RefreshDictSettingsTable()
return

DictSettingsTableClick:
    if (A_GuiEvent = "DoubleClick")
        Gosub, DictSettingsEdit
return

DictSettingsToggle:
    Gui, 1:Default
    Gui, ListView, DictSettingsTable
    row := LV_GetNext()
    if (!row)
        return
    meta := GetDictSettingMeta(row)
    if (!IsObject(meta) || meta.kind != "bool")
        return
    GuiControlGet, cur,, % meta.var
    GuiControl,, % meta.var, % (cur ? 0 : 1)
    SaveDictGuiToGlobals()
    RefreshDictSettingsTable()
return

DictSettingsEdit:
    Gui, 1:Default
    Gui, ListView, DictSettingsTable
    row := LV_GetNext()
    if (!row)
        return
    meta := GetDictSettingMeta(row)
    if (!IsObject(meta))
        return
    if (meta.kind = "num") {
        GuiControlGet, cur,, % meta.var
        InputBox, nv, Настройка словаря, % meta.name . ": ", , 340, 130, , , , , %cur%
        if (!ErrorLevel)
            GuiControl,, % meta.var, %nv%
    } else if (meta.kind = "text") {
        GuiControlGet, cur,, % meta.var
        InputBox, nv, Настройка словаря, % meta.name . ": ", , 480, 150, , , , , %cur%
        if (!ErrorLevel)
            GuiControl,, % meta.var, %nv%
    } else if (meta.kind = "bool") {
        Gosub, DictSettingsToggle
        return
    }
    SaveDictGuiToGlobals()
    RefreshDictSettingsTable()
return

GetDictSettingMeta(row) {
    ; 55 строк (часть влияет на обработку, часть на хранение/экспорт)
    if (row = 1)  return ({name:"Включить словарь", var:"DictEnabled", kind:"bool"})
    if (row = 2)  return ({name:"Запоминать TypeText при старте", var:"DictCaptureOnStart", kind:"bool"})
    if (row = 3)  return ({name:"Запоминать отправленные сообщения", var:"DictCaptureSentMessages", kind:"bool"})
    if (row = 4)  return ({name:"Запоминать генератор", var:"DictCaptureGenerator", kind:"bool"})
    if (row = 5)  return ({name:"Хранить события", var:"DictStoreEvents", kind:"bool"})
    if (row = 6)  return ({name:"Хранить слова", var:"DictStoreWords", kind:"bool"})
    if (row = 7)  return ({name:"Хранить строки", var:"DictStoreLines", kind:"bool"})
    if (row = 8)  return ({name:"Нижний регистр", var:"DictNormalizeLower", kind:"bool"})
    if (row = 9)  return ({name:"Убрать пунктуацию", var:"DictStripPunct", kind:"bool"})
    if (row = 10) return ({name:"Сжать пробелы", var:"DictCollapseSpaces", kind:"bool"})
    if (row = 11) return ({name:"Убрать URL", var:"DictStripUrls", kind:"bool"})
    if (row = 12) return ({name:"Убрать email", var:"DictStripEmails", kind:"bool"})
    if (row = 13) return ({name:"Убрать @mentions", var:"DictStripMentions", kind:"bool"})
    if (row = 14) return ({name:"Убрать #hashtags", var:"DictStripHashtags", kind:"bool"})
    if (row = 15) return ({name:"Убрать не-ASCII", var:"DictStripEmojis", kind:"bool"})
    if (row = 16) return ({name:"Игнорировать числа", var:"DictIgnoreNumbers", kind:"bool"})
    if (row = 17) return ({name:"Только буквы в топ-словах", var:"DictTopWordsOnlyLetters", kind:"bool"})
    if (row = 18) return ({name:"Только кириллица", var:"DictKeepCyrillicOnly", kind:"bool"})
    if (row = 19) return ({name:"Только латиница", var:"DictKeepLatinOnly", kind:"bool"})
    if (row = 20) return ({name:"Мин. длина слова", var:"DictMinWordLen", kind:"num"})
    if (row = 21) return ({name:"Макс. длина слова", var:"DictMaxWordLen", kind:"num"})
    if (row = 22) return ({name:"Макс. символов в событии", var:"DictMaxCharsPerEvent", kind:"num"})
    if (row = 23) return ({name:"Стоп-слова (csv/строки)", var:"DictStopWordsText", kind:"text"})
    if (row = 24) return ({name:"Макс. событий/день", var:"DictMaxEventsPerDay", kind:"num"})
    if (row = 25) return ({name:"Не повторять события подряд", var:"DictNoRepeatEvents", kind:"bool"})
    if (row = 26) return ({name:"Автосохранение", var:"DictAutosaveEnabled", kind:"bool"})
    if (row = 27) return ({name:"Интервал автосейва (сек)", var:"DictAutosaveIntervalSec", kind:"num"})
    if (row = 28) return ({name:"Лимит топ-слов", var:"DictTopWordsLimit", kind:"num"})
    if (row = 29) return ({name:"Собирать топ-строки", var:"DictCollectTopLines", kind:"bool"})
    if (row = 30) return ({name:"Лимит топ-строк", var:"DictTopLinesLimit", kind:"num"})
    if (row = 31) return ({name:"Биграммы", var:"DictEnableBigrams", kind:"bool"})
    if (row = 32) return ({name:"Триграммы", var:"DictEnableTrigrams", kind:"bool"})
    if (row = 33) return ({name:"Добавлять source тег", var:"DictAppendSourceTag", kind:"bool"})
    if (row = 34) return ({name:"Добавлять timestamp", var:"DictAppendTimestamp", kind:"bool"})
    if (row = 35) return ({name:"Добавлять перевод строки", var:"DictAppendNewline", kind:"bool"})
    ; Доп. параметры (реальные, для датасета/импорта/ввода)
    if (row = 36) return ({name:"Запоминать ввод TypeText (изменения)", var:"DictCaptureTypeTextEdits", kind:"bool"})
    if (row = 37) return ({name:"Пауза фиксации TypeText (мс)", var:"DictTypeTextDebounceMs", kind:"num"})
    if (row = 38) return ({name:"Мин. длина снимка TypeText (симв)", var:"DictTypeTextMinChars", kind:"num"})
    if (row = 39) return ({name:"Писать JSONL датасет", var:"DictStoreJsonl", kind:"bool"})
    if (row = 40) return ({name:"Лимит JSONL (МБ)", var:"DictJsonlMaxMB", kind:"num"})
    if (row = 41) return ({name:"Буфер: добавлять по строкам", var:"DictClipboardSplitLines", kind:"bool"})
    if (row = 42) return ({name:"Импорт: добавлять по строкам", var:"DictImportSplitLines", kind:"bool"})
    if (row = 43) return ({name:"Импорт: макс. строк", var:"DictImportMaxLines", kind:"num"})
    if (row = 44) return ({name:"Макс. символов в событии (повтор)", var:"DictMaxCharsPerEvent", kind:"num"})
    if (row = 45) return ({name:"Макс. событий/день (повтор)", var:"DictMaxEventsPerDay", kind:"num"})
    if (row = 46) return ({name:"Не повторять события подряд (повтор)", var:"DictNoRepeatEvents", kind:"bool"})
    if (row = 47) return ({name:"Импорт: макс. строк (повтор)", var:"DictImportMaxLines", kind:"num"})
    if (row = 48) return ({name:"Буфер: по строкам (повтор)", var:"DictClipboardSplitLines", kind:"bool"})
    if (row = 49) return ({name:"JSONL: лимит МБ (повтор)", var:"DictJsonlMaxMB", kind:"num"})
    if (row = 50) return ({name:"Автосейв summary (повтор)", var:"DictAutosaveEnabled", kind:"bool"})
    if (row = 51) return ({name:"Интервал автосейва (повтор)", var:"DictAutosaveIntervalSec", kind:"num"})
    if (row = 52) return ({name:"TypeText: debounce (повтор)", var:"DictTypeTextDebounceMs", kind:"num"})
    if (row = 53) return ({name:"TypeText: min chars (повтор)", var:"DictTypeTextMinChars", kind:"num"})
    if (row = 54) return ({name:"JSONL: включено (повтор)", var:"DictStoreJsonl", kind:"bool"})
    if (row = 55) return ({name:"TypeText edits (повтор)", var:"DictCaptureTypeTextEdits", kind:"bool"})
    return ""
}

SaveDictGuiToGlobals() {
    global dictEnabled, dictCaptureOnStart, dictCaptureTypeTextEdits, dictTypeTextDebounceMs, dictTypeTextMinChars
    global dictCaptureSentMessages, dictCaptureGenerator
    global dictStoreEvents, dictStoreWords, dictStoreLines, dictNormalizeLower, dictStripPunct
    global dictCollapseSpaces, dictIgnoreNumbers, dictMinWordLen, dictMaxWordLen, dictMaxCharsPerEvent
    global dictStopWordsText, dictMaxEventsPerDay, dictNoRepeatEvents, dictAutosaveEnabled, dictAutosaveIntervalSec
    global dictTopWordsLimit, dictCollectTopLines, dictTopLinesLimit, dictStripUrls, dictStripEmails, dictStripMentions
    global dictStripHashtags, dictStripEmojis, dictTopWordsOnlyLetters, dictKeepCyrillicOnly, dictKeepLatinOnly
    global dictEnableBigrams, dictEnableTrigrams, dictAppendSourceTag, dictAppendTimestamp, dictAppendNewline
    global dictStoreJsonl, dictJsonlMaxMB, dictClipboardSplitLines, dictImportMaxLines, dictImportSplitLines
    
    Gui, 1:Submit, NoHide
    dictEnabled := DictEnabled
    dictCaptureOnStart := DictCaptureOnStart
    dictCaptureTypeTextEdits := DictCaptureTypeTextEdits
    dictTypeTextDebounceMs := DictTypeTextDebounceMs + 0
    dictTypeTextMinChars := DictTypeTextMinChars + 0
    dictCaptureSentMessages := DictCaptureSentMessages
    dictCaptureGenerator := DictCaptureGenerator
    dictStoreEvents := DictStoreEvents
    dictStoreWords := DictStoreWords
    dictStoreLines := DictStoreLines
    dictNormalizeLower := DictNormalizeLower
    dictStripPunct := DictStripPunct
    dictCollapseSpaces := DictCollapseSpaces
    dictIgnoreNumbers := DictIgnoreNumbers
    dictMinWordLen := DictMinWordLen + 0
    dictMaxWordLen := DictMaxWordLen + 0
    dictMaxCharsPerEvent := DictMaxCharsPerEvent + 0
    dictStopWordsText := DictStopWordsText
    dictMaxEventsPerDay := DictMaxEventsPerDay + 0
    dictNoRepeatEvents := DictNoRepeatEvents
    dictAutosaveEnabled := DictAutosaveEnabled
    dictAutosaveIntervalSec := DictAutosaveIntervalSec + 0
    dictTopWordsLimit := DictTopWordsLimit + 0
    dictCollectTopLines := DictCollectTopLines
    dictTopLinesLimit := DictTopLinesLimit + 0
    dictStripUrls := DictStripUrls
    dictStripEmails := DictStripEmails
    dictStripMentions := DictStripMentions
    dictStripHashtags := DictStripHashtags
    dictStripEmojis := DictStripEmojis
    dictTopWordsOnlyLetters := DictTopWordsOnlyLetters
    dictKeepCyrillicOnly := DictKeepCyrillicOnly
    dictKeepLatinOnly := DictKeepLatinOnly
    dictEnableBigrams := DictEnableBigrams
    dictEnableTrigrams := DictEnableTrigrams
    dictAppendSourceTag := DictAppendSourceTag
    dictAppendTimestamp := DictAppendTimestamp
    dictAppendNewline := DictAppendNewline
    dictStoreJsonl := DictStoreJsonl
    dictJsonlMaxMB := DictJsonlMaxMB + 0
    dictClipboardSplitLines := DictClipboardSplitLines
    dictImportSplitLines := DictImportSplitLines
    dictImportMaxLines := DictImportMaxLines + 0
    
    DictUpdateTimer()
    DictSaveSettingsToIni()
}

DictSaveSettingsToIni() {
    global appDataDir
    global dictEnabled, dictCaptureOnStart, dictCaptureTypeTextEdits, dictTypeTextDebounceMs, dictTypeTextMinChars
    global dictCaptureSentMessages, dictCaptureGenerator, dictStoreJsonl, dictJsonlMaxMB
    global dictClipboardSplitLines, dictImportMaxLines, dictImportSplitLines, dictAutosaveEnabled, dictAutosaveIntervalSec

    ini := appDataDir . "\\AutoTyper.ini"
    IniWrite, %dictEnabled%, %ini%, Dictionary, Enabled
    IniWrite, %dictCaptureOnStart%, %ini%, Dictionary, CaptureOnStart
    IniWrite, %dictCaptureTypeTextEdits%, %ini%, Dictionary, CaptureTypeTextEdits
    IniWrite, %dictTypeTextDebounceMs%, %ini%, Dictionary, TypeTextDebounceMs
    IniWrite, %dictTypeTextMinChars%, %ini%, Dictionary, TypeTextMinChars
    IniWrite, %dictCaptureSentMessages%, %ini%, Dictionary, CaptureSentMessages
    IniWrite, %dictCaptureGenerator%, %ini%, Dictionary, CaptureGenerator
    IniWrite, %dictStoreJsonl%, %ini%, Dictionary, StoreJsonl
    IniWrite, %dictJsonlMaxMB%, %ini%, Dictionary, JsonlMaxMB
    IniWrite, %dictClipboardSplitLines%, %ini%, Dictionary, ClipboardSplitLines
    IniWrite, %dictImportMaxLines%, %ini%, Dictionary, ImportMaxLines
    IniWrite, %dictImportSplitLines%, %ini%, Dictionary, ImportSplitLines
    IniWrite, %dictAutosaveEnabled%, %ini%, Dictionary, AutosaveEnabled
    IniWrite, %dictAutosaveIntervalSec%, %ini%, Dictionary, AutosaveIntervalSec
}

DictScheduleTypeTextCapture(text) {
    global dictTypeTextPending, dictTypeTextDebounceMs
    dictTypeTextPending := text
    delay := dictTypeTextDebounceMs + 0
    if (delay < 100)
        delay := 100
    SetTimer, DictTypeTextDebounceTimer, % "-" . delay
}

DictTypeTextDebounceTimer:
    global dictEnabled, dictCaptureTypeTextEdits, dictTypeTextPending, dictTypeTextLastSnapshot, dictTypeTextMinChars
    if (!dictEnabled || !dictCaptureTypeTextEdits)
        return
    snap := Trim(dictTypeTextPending, "`r`n`t ")
    if (snap = "")
        return
    if (StrLen(snap) < (dictTypeTextMinChars + 0))
        return
    if (snap = dictTypeTextLastSnapshot)
        return
    dictTypeTextLastSnapshot := snap
    DictCapture(snap, "TypeTextEdit")
return

RefreshDictSettingsTable() {
    Gui, 1:Default
    Gui, ListView, DictSettingsTable
    LV_Delete()
    Loop, 55 {
        meta := GetDictSettingMeta(A_Index)
        if (!IsObject(meta))
            continue
        GuiControlGet, v,, % meta.var
        en := "-"
        val := "-"
        if (meta.kind = "bool") {
            en := v ? "Да" : "Нет"
        } else {
            en := ""
            val := v
        }
        LV_Add("", meta.name, en, val)
    }
}

DictCreateTemplateFromDict:
    global dictDir, presetDir
    day := DictNowDate()
    defaultPath := dictDir . "\\" . day . ".txt"
    InputBox, dictPath, Шаблон из словаря, Путь к .txt словаря (можно оставить пустым = сегодня):, , 520, 150, , , , , %defaultPath%
    if (ErrorLevel)
        return
    if (Trim(dictPath) = "")
        dictPath := defaultPath
    if (!FileExist(dictPath)) {
        MsgBox, 48, Ошибка, Файл не найден:`n%dictPath%
        return
    }
    InputBox, cat, Категория, Категория (папка в пресетах):, , 320, 130, , , , , Dictionary
    if (ErrorLevel || cat = "")
        return
    InputBox, name, Имя шаблона, Имя .txt шаблона:, , 320, 130
    if (ErrorLevel || name = "")
        return
    dstDir := presetDir . "\\" . cat
    if (!FileExist(dstDir))
        FileCreateDir, %dstDir%
    dst := dstDir . "\\" . name . ".txt"
    ; Создаем "чистый" шаблон: убираем префиксы вида [YYYY-MM-DD HH:MM:SS] (Source)
    FileRead, dictContent, %dictPath%
    out := ""
    lines := StrSplit(dictContent, "`n", "`r")
    for i, ln in lines {
        ln := Trim(ln, "`r`n")
        if (ln = "")
            continue
        out .= DictStripLogPrefix(ln) . "`r`n"
    }
    FileDelete, %dst%
    FileAppend, %out%, %dst%, UTF-8
    if (IsFunc("LoadMainTextTree"))
        LoadMainTextTree()
    MsgBox, 64, Готово, Шаблон создан:`n%dst%
return

; ============================================
; === STEALTH MODE (safe text processing) ===
; ============================================

StealthOpt(n) {
    global
    var := "StealthOpt" . n
    val := %var%
    return val ? 1 : 0
}

StealthTimestamp() {
    FormatTime, ts,, yyyy-MM-dd HH:mm:ss
    return ts
}

StealthStripInvisible(text) {
    ; Removes common zero-width/invisible codepoints and control chars (keeps \t,\n,\r).
    static inv := ""
    if (!IsObject(inv)) {
        inv := []
        inv.Push(Chr(0x00AD)) ; soft hyphen
        inv.Push(Chr(0x034F)) ; combining grapheme joiner
        inv.Push(Chr(0x061C)) ; arabic letter mark
        inv.Push(Chr(0x180E)) ; mongolian vowel separator (deprecated)
        inv.Push(Chr(0x200B)) ; zero width space
        inv.Push(Chr(0x200C)) ; zero width non-joiner
        inv.Push(Chr(0x200D)) ; zero width joiner
        inv.Push(Chr(0x200E)) ; LRM
        inv.Push(Chr(0x200F)) ; RLM
        inv.Push(Chr(0x202A)) ; LRE
        inv.Push(Chr(0x202B)) ; RLE
        inv.Push(Chr(0x202C)) ; PDF
        inv.Push(Chr(0x202D)) ; LRO
        inv.Push(Chr(0x202E)) ; RLO
        inv.Push(Chr(0x2060)) ; word joiner
        inv.Push(Chr(0x2066)) ; LRI
        inv.Push(Chr(0x2067)) ; RLI
        inv.Push(Chr(0x2068)) ; FSI
        inv.Push(Chr(0x2069)) ; PDI
        inv.Push(Chr(0xFEFF)) ; BOM / ZWNBSP
    }
    for i, ch in inv
        text := StrReplace(text, ch, "")
    ; Strip ASCII control chars except Tab(09), LF(0A), CR(0D).
    text := RegExReplace(text, "[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]", "")
    return text
}

StealthNormalizeNewlines(text) {
    text := StrReplace(text, "`r`n", "`n")
    text := StrReplace(text, "`r", "`n")
    return text
}

StealthTrimLines(text) {
    text := StealthNormalizeNewlines(text)
    lines := StrSplit(text, "`n")
    out := ""
    for i, ln in lines {
        ln := Trim(ln, " `t")
        out .= (i > 1 ? "`n" : "") . ln
    }
    return out
}

StealthCollapseBlankLines(text) {
    text := StealthNormalizeNewlines(text)
    ; Max 1 empty line in a row.
    text := RegExReplace(text, "(\n\s*){3,}", "`n`n")
    return text
}

StealthUnifyQuotes(text) {
    ; Replace common quote variants with ".
    q := """"
    text := StrReplace(text, "«", q)
    text := StrReplace(text, "»", q)
    text := StrReplace(text, "„", q)
    text := StrReplace(text, "“", q)
    text := StrReplace(text, "”", q)
    text := StrReplace(text, "‟", q)
    return text
}

StealthUnifyDashes(text) {
    ; Replace dash variants with normal hyphen-minus.
    text := StrReplace(text, "—", "-")
    text := StrReplace(text, "–", "-")
    text := StrReplace(text, "−", "-")
    text := StrReplace(text, "‑", "-") ; non-breaking hyphen
    return text
}

StealthWrapLine(line, maxLen) {
    out := ""
    rest := Trim(line, " `t")
    if (maxLen < 10)
        maxLen := 10
    while (StrLen(rest) > maxLen) {
        cut := maxLen
        Loop, %maxLen% {
            if (cut <= 20)
                break
            if (SubStr(rest, cut, 1) = " ")
                break
            cut--
        }
        if (cut <= 20)
            cut := maxLen
        part := Trim(SubStr(rest, 1, cut), " `t")
        if (part = "")
            break
        out .= part . "`n"
        rest := Trim(SubStr(rest, cut + 1), " `t")
    }
    out .= rest
    return out
}

StealthWrapLines(text, maxLen) {
    text := StealthNormalizeNewlines(text)
    lines := StrSplit(text, "`n")
    out := ""
    for i, ln in lines {
        out .= (i > 1 ? "`n" : "") . StealthWrapLine(ln, maxLen)
    }
    return out
}

StealthCanonical(text) {
    t := StealthNormalizeNewlines(text)
    ; Remove URLs/emails for canonicalization, then strip punct and normalize spaces.
    t := RegExReplace(t, "i)\bhttps?://\S+|\bwww\.\S+", "")
    t := RegExReplace(t, "i)\b[\w\.\-\+]+@[\w\.\-]+\.\w+\b", "")
    t := RegExReplace(t, "[^\w\sА-Яа-яЁё]+", " ")
    StringLower, t, t
    t := RegExReplace(t, "\s+", " ")
    return Trim(t)
}

StealthWordSet(text) {
    set := {}
    canon := StealthCanonical(text)
    if (canon = "")
        return set
    words := StrSplit(canon, " ")
    for i, w in words {
        if (w != "")
            set[w] := 1
    }
    return set
}

StealthJaccardSimilarity(a, b) {
    sa := StealthWordSet(a)
    sb := StealthWordSet(b)
    if (sa.Count() = 0 || sb.Count() = 0)
        return 0.0
    inter := 0
    uni := 0
    for k, v in sa {
        uni++
        if (sb.HasKey(k))
            inter++
    }
    for k, v in sb {
        if (!sa.HasKey(k))
            uni++
    }
    if (uni <= 0)
        return 0.0
    return inter / uni
}

StealthLoadLinesFile(path) {
    arr := []
    if (!FileExist(path))
        return arr
    Loop, Read, %path%
    {
        ln := Trim(A_LoopReadLine)
        if (ln = "")
            continue
        if (SubStr(ln, 1, 1) = ";" || SubStr(ln, 1, 1) = "#")
            continue
        arr.Push(ln)
    }
    return arr
}

StealthEnsureForbiddenFile() {
    global appDataDir
    p := appDataDir . "\stealth_forbidden.txt"
    if (FileExist(p))
        return p
    FileAppend, % "; Добавьте сюда запрещенные фразы (по одной на строку).`n", %p%, UTF-8
    return p
}

StealthLoadSynonyms() {
    global appDataDir
    static cache := {mtime: "", map: ""}
    p := appDataDir . "\stealth_synonyms.ini"
    if (!FileExist(p)) {
        ; В expression-continuation секции строки с `;` могут ломать парсер.
        ; Поэтому пишем ini-шаблон как обычный continuation section.
        tpl =
        (LTrim
        ; Формат: слово=синоним1|синоним2|синоним3
        ; Пример:
        ; привет=здравствуйте|добрый день
        быстро=оперативно|скоренько
        кстати=между прочим|к слову
        важно=существенно|значимо
        привет=здравствуйте|добрый день
        спасибо=благодарю|спасибо большое
        )
        FileAppend, % tpl . "`n", %p%, UTF-8
    }
    FileGetTime, mt, %p%, M
    if (cache.mtime = mt && IsObject(cache.map))
        return cache.map
    m := {}
    Loop, Read, %p%
    {
        ln := Trim(A_LoopReadLine)
        if (ln = "" || SubStr(ln,1,1)=";" || SubStr(ln,1,1)="#")
            continue
        parts := StrSplit(ln, "=", , 2)
        if (parts.Length() < 2)
            continue
        key := Trim(parts[1])
        vals := Trim(parts[2])
        if (key = "" || vals = "")
            continue
        StringLower, keyL, key
        alts := []
        for i, v in StrSplit(vals, "|") {
            v := Trim(v)
            if (v != "")
                alts.Push(v)
        }
        if (alts.Length() > 0)
            m[keyL] := alts
    }
    cache.mtime := mt
    cache.map := m
    return m
}

StealthMatchCase(repl, sample) {
    if (repl = "")
        return repl
    if (RegExMatch(sample, "^[A-ZА-ЯЁ]{2,}$")) {
        StringUpper, out, repl
        return out
    }
    if (RegExMatch(sample, "^[A-ZА-ЯЁ]")) {
        first := SubStr(repl, 1, 1)
        rest := SubStr(repl, 2)
        StringUpper, firstU, first
        return firstU . rest
    }
    return repl
}

StealthApplySynonyms(text) {
    syn := StealthLoadSynonyms()
    if (!IsObject(syn) || syn.Count() = 0)
        return text
    pos := 1
    out := ""
    while RegExMatch(text, "O)([A-Za-zА-Яа-яЁё]+)", m, pos) {
        out .= SubStr(text, pos, m.Pos(1) - pos)
        w := m.Value(1)
        StringLower, wL, w
        if (syn.HasKey(wL)) {
            ; "rotation": do not replace every occurrence to keep text natural.
            if (Random(1, 100) <= 60) {
                alts := syn[wL]
                if (alts.Length() > 0) {
                    idx := Random(1, alts.Length())
                    rep := StealthMatchCase(alts[idx], w)
                    out .= rep
                } else {
                    out .= w
                }
            } else {
                out .= w
            }
        } else {
            out .= w
        }
        pos := m.Pos(1) + m.Len(1)
    }
    out .= SubStr(text, pos)
    return out
}

StealthApplyAbbreviations(text, aggressive := 0) {
    map := {}
    ; soft
    map["например"] := "напр."
    map["пожалуйста"] := "пжл."
    map["кстати"] := "кст."
    map["сегодня"] := "сег."
    map["потому"] := "птм"
    ; aggressive extras
    if (aggressive) {
        map["сейчас"] := "щас"
        map["спасибо"] := "спс"
        map["почему"] := "поч"
        map["окей"] := "ок"
    }
    pos := 1
    out := ""
    while RegExMatch(text, "O)([A-Za-zА-Яа-яЁё]+)", m, pos) {
        out .= SubStr(text, pos, m.Pos(1) - pos)
        w := m.Value(1)
        StringLower, wL, w
        if (map.HasKey(wL)) {
            rep := map[wL]
            out .= StealthMatchCase(rep, w)
        } else {
            out .= w
        }
        pos := m.Pos(1) + m.Len(1)
    }
    out .= SubStr(text, pos)
    return out
}

StealthApplyWordforms(text) {
    ; Light "wordform"/colloquial variations (visible).
    map := {}
    map["пожалуйста"] := ["плиз","пж"]
    map["сейчас"] := ["щас","сейчас"]
    map["просто"] := ["прям","просто"]
    pos := 1
    out := ""
    while RegExMatch(text, "O)([A-Za-zА-Яа-яЁё]+)", m, pos) {
        out .= SubStr(text, pos, m.Pos(1) - pos)
        w := m.Value(1)
        StringLower, wL, w
        if (map.HasKey(wL)) {
            alts := map[wL]
            idx := Random(1, alts.Length())
            rep := StealthMatchCase(alts[idx], w)
            out .= rep
        } else {
            out .= w
        }
        pos := m.Pos(1) + m.Len(1)
    }
    out .= SubStr(text, pos)
    return out
}

StealthChoose(arr) {
    if (!IsObject(arr) || arr.Length() = 0)
        return ""
    idx := Random(1, arr.Length())
    return arr[idx]
}

StealthApplySeparators(text) {
    joiners := []
    if (StealthOpt(39))
        joiners.Push(". ")
    if (StealthOpt(40))
        joiners.Push(", ")
    if (StealthOpt(41))
        joiners.Push(" - ")
    if (StealthOpt(42))
        joiners.Push("`n")
    if (joiners.Length() = 0)
        return text
    t := StealthNormalizeNewlines(text)
    linesRaw := StrSplit(t, "`n")
    lines := []
    for i, ln in linesRaw {
        ln := Trim(ln, " `t")
        if (ln != "")
            lines.Push(ln)
    }
    if (lines.Length() <= 1)
        return text
    j := StealthChoose(joiners)
    out := ""
    for i, ln in lines
        out .= (i > 1 ? j : "") . ln
    return out
}

StealthAddIntroOutro(text) {
    prefixes := ["", "Кстати,", "Если коротко,", "Важно:", "Небольшое уточнение:", "По сути,"]
    outros := ["", "Вот.", "В общем.", "Как-то так.", "Если что."]
    t := text
    if (StealthOpt(31)) {
        p := StealthChoose(prefixes)
        if (p != "")
            t := p . " " . t
    }
    if (StealthOpt(32)) {
        s := StealthChoose(outros)
        if (s != "")
            t := t . " " . s
    }
    if (StealthOpt(49)) {
        intro := StealthChoose(["", "Смотри:", "Поясню:", "Уточню:", "Коротко:"])
        if (intro != "")
            t := intro . " " . t
    }
    if (StealthOpt(50)) {
        outro := StealthChoose(["", "На этом все.", "Готово.", "Конец.", "Ок."])
        if (outro != "")
            t := t . " " . outro
    }
    return t
}

StealthMaybeVaryPunctuation(text) {
    t := Trim(text, " `t`r`n")
    if (t = "")
        return text
    if (!StealthOpt(46))
        return text
    last := SubStr(t, 0)
    if (last = "." || last = "!" || last = "?" || last = ";")
        return text
    marks := [".", "!", "?", "..."]
    m := StealthChoose(marks)
    return t . m
}

StealthRandomCaseTouch(text) {
    if (!StealthOpt(51))
        return text
    words := StrSplit(text, " ")
    if (words.Length() < 3)
        return text
    idx := Random(2, words.Length())
    w := words[idx]
    if (!RegExMatch(w, "^[A-Za-zА-Яа-яЁё]"))
        return text
    first := SubStr(w, 1, 1)
    rest := SubStr(w, 2)
    StringUpper, firstU, first
    words[idx] := firstU . rest
    out := ""
    for i, ww in words
        out .= (i > 1 ? " " : "") . ww
    return out
}

StealthVarySentenceLength(text) {
    if (!StealthOpt(47))
        return text
    t := StealthNormalizeNewlines(text)
    lines := StrSplit(t, "`n")
    out := ""
    for i, ln in lines {
        ln := Trim(ln, " `t")
        if (StrLen(ln) > 180) {
            len := StrLen(ln)
            target := Random(90, Min(140, len - 10))
            pos := target
            ; search backward for a space near target
            Loop, 50 {
                if (pos <= 20)
                    break
                if (SubStr(ln, pos, 1) = " ")
                    break
                pos--
            }
            ; if no space found, search forward
            if (SubStr(ln, pos, 1) != " ") {
                pos := target
                Loop, 50 {
                    if (pos >= len - 1)
                        break
                    if (SubStr(ln, pos, 1) = " ")
                        break
                    pos++
                }
            }
            if (SubStr(ln, pos, 1) = " ") {
                p1 := Trim(SubStr(ln, 1, pos), " `t")
                p2 := Trim(SubStr(ln, pos + 1), " `t")
                if (p1 != "" && p2 != "") {
                    p2 := RegExReplace(p2, "^(.)", "$U1")
                    ln := p1 . ". " . p2
                }
            }
        }
        out .= (i > 1 ? "`n" : "") . ln
    }
    return out
}

StealthVaryLineBreaks(text) {
    if (!StealthOpt(54))
        return text
    t := StealthNormalizeNewlines(text)
    if (InStr(t, "`n")) {
        ; 50% chance to flatten to a single line.
        if (Random(1, 100) <= 50) {
            lines := StrSplit(t, "`n")
            out := ""
            for i, ln in lines {
                ln := Trim(ln, " `t")
                if (ln = "")
                    continue
                out .= (out != "" ? " " : "") . ln
            }
            return out != "" ? out : text
        }
        return text
    }
    if (StrLen(t) < 120)
        return text
    len := StrLen(t)
    target := Random(50, Min(150, len - 5))
    pos := target
    Loop, 80 {
        if (pos <= 20)
            break
        if (SubStr(t, pos, 1) = " ")
            break
        pos--
    }
    if (SubStr(t, pos, 1) != " ")
        return text
    return Trim(SubStr(t, 1, pos), " `t") . "`n" . Trim(SubStr(t, pos + 1), " `t")
}

StealthStandardizeNumbers(text) {
    if (!StealthOpt(45))
        return text
    t := text
    ; Remove spaces inside digit groups: "1 000" -> "1000"
    Loop, 5 {
        t2 := RegExReplace(t, "(\d)[ \t]+(\d)", "$1$2")
        if (t2 = t)
            break
        t := t2
    }
    return t
}

StealthAppendLog(source, before, after, reason := "") {
    global appDataDir
    logPath := appDataDir . "\stealth.log"
    FileGetSize, sz, %logPath%
    if (!ErrorLevel && sz > 2000000) {
        FileDelete, % logPath . ".1"
        FileMove, %logPath%, % logPath . ".1", 1
    }
    b := before
    a := after
    if (StrLen(b) > 500)
        b := SubStr(b, 1, 500) . "...(trunc)"
    if (StrLen(a) > 500)
        a := SubStr(a, 1, 500) . "...(trunc)"
    ts := StealthTimestamp()
    FileAppend, [%ts%] src=%source% reason=%reason%`nBEFORE: %b%`nAFTER:  %a%`n`n, %logPath%, UTF-8
}

ToSmallCapsRU(text) {
    static map := ""
    if (!IsObject(map)) {
        map := {}
        ; Based on user-requested style. Letters without a reasonable small-cap substitute are left as-is.
        map["а"] := "ᴀ", map["А"] := "ᴀ"
        map["б"] := "б", map["Б"] := "б"
        map["в"] := "ʙ", map["В"] := "ʙ"
        map["г"] := "ᴦ", map["Г"] := "ᴦ"
        map["д"] := "д", map["Д"] := "д"
        map["е"] := "ᴇ", map["Е"] := "ᴇ"
        map["ё"] := "ё", map["Ё"] := "ё"
        map["ж"] := "ж", map["Ж"] := "ж"
        map["з"] := "з", map["З"] := "з"
        map["и"] := "и", map["И"] := "и"
        map["й"] := "й", map["Й"] := "й"
        map["к"] := "ᴋ", map["К"] := "ᴋ"
        map["л"] := "ᴧ", map["Л"] := "ᴧ"
        map["м"] := "ʍ", map["М"] := "ʍ"
        map["н"] := "н", map["Н"] := "н"
        map["о"] := "о", map["О"] := "о"
        map["п"] := "ᴨ", map["П"] := "ᴨ"
        map["р"] := "ᴩ", map["Р"] := "ᴩ"
        map["с"] := "ᴄ", map["С"] := "ᴄ"
        map["т"] := "ᴛ", map["Т"] := "ᴛ"
        map["у"] := "у", map["У"] := "у"
        map["ф"] := "ɸ", map["Ф"] := "ɸ"
        map["х"] := "х", map["Х"] := "х"
        map["ц"] := "ц", map["Ц"] := "ц"
        map["ч"] := "ч", map["Ч"] := "ч"
        map["ш"] := "ɯ", map["Ш"] := "ɯ"
        map["щ"] := "щ", map["Щ"] := "щ"
        map["ъ"] := "ъ", map["Ъ"] := "ъ"
        map["ы"] := "ы", map["Ы"] := "ы"
        map["ь"] := "ь", map["Ь"] := "ь"
        map["э"] := "϶", map["Э"] := "϶"
        map["ю"] := "ю", map["Ю"] := "ю"
        map["я"] := "я", map["Я"] := "я"
    }
    out := ""
    Loop, Parse, text
    {
        ch := A_LoopField
        out .= map.HasKey(ch) ? map[ch] : ch
    }
    return out
}

ApplyFinalTextStyle(text) {
    global SmallCapsEnabled
    if (SmallCapsEnabled)
        text := ToSmallCapsRU(text)
    return text
}

; ============================================
; === SPECIAL TAGS: {PAUSE 2s}, {time}, etc ===
; ============================================

GetNowMskTimestamp() {
    ts := A_NowUTC
    EnvAdd, ts, 3, Hours
    return ts
}

FormatTimeByTs(ts, fmt) {
    FormatTime, out, %ts%, %fmt%
    return out
}

ParseDurationMs(s) {
    s := Trim(s)
    if (s = "")
        return 0
    ; Accept: 200ms, 2s, 1sec, 3m, 1h. If no unit -> seconds.
    if (RegExMatch(s, "i)^\s*(\d+(?:\.\d+)?)\s*(ms|msec|миллисекунд[а-я]*|s|sec|секунд[а-я]*|m|min|минут[а-я]*|h|час[а-я]*)?\s*$", m)) {
        val := m1 + 0
        unit := m2
        if (unit = "")
            unit := "s"
        unit := Trim(unit)
        if (val < 0)
            val := 0
        if (RegExMatch(unit, "i)^(ms|msec|миллисекунд)"))
            return Round(val)
        if (RegExMatch(unit, "i)^(s|sec|секунд)"))
            return Round(val * 1000)
        if (RegExMatch(unit, "i)^(m|min|минут)"))
            return Round(val * 60000)
        if (RegExMatch(unit, "i)^(h|час)"))
            return Round(val * 3600000)
    }
    return 0
}

EvalSpecialTag(tagText) {
    ; Returns array of actions: {t:"text", v:"..."} or {t:"pause", ms:123}
    actions := []
    tag := Trim(tagText)
    if (tag = "")
        return ""

    ; PAUSE / SLEEP
    if (RegExMatch(tag, "i)^(pause|sleep|пауза)\s*[: ]\s*(.+)$", m)) {
        ms := ParseDurationMs(m2)
        if (ms > 0) {
            actions.Push({t: "pause", ms: ms})
            return actions
        }
    }

    ; TIME / DATE / DATETIME (default: MSK)
    if (RegExMatch(tag, "i)^(time|время)(?:\s*:\s*([a-zа-я]+))?$", m)) {
        mode := Trim(m2)
        ts := GetNowMskTimestamp()
        if (mode = "" || RegExMatch(mode, "i)^(msk|мск)$"))
            actions.Push({t: "text", v: FormatTimeByTs(ts, "HH:mm")})
        else if (RegExMatch(mode, "i)^(second|sec|s|сек|секунд)"))
            actions.Push({t: "text", v: FormatTimeByTs(ts, "HH:mm:ss")})
        else if (RegExMatch(mode, "i)^(full|datetime)$"))
            actions.Push({t: "text", v: FormatTimeByTs(ts, "dd.MM.yyyy HH:mm")})
        else
            actions.Push({t: "text", v: FormatTimeByTs(ts, "HH:mm")})
        return actions
    }
    if (RegExMatch(tag, "i)^(date|дата)(?:\s*:\s*([a-zа-я]+))?$", m)) {
        mode := Trim(m2)
        ts := GetNowMskTimestamp()
        if (RegExMatch(mode, "i)^(iso)$"))
            actions.Push({t: "text", v: FormatTimeByTs(ts, "yyyy-MM-dd")})
        else
            actions.Push({t: "text", v: FormatTimeByTs(ts, "dd.MM.yyyy")})
        return actions
    }
    if (RegExMatch(tag, "i)^(datetime|дт)(?:\s*:\s*([a-zа-я]+))?$", m)) {
        mode := Trim(m2)
        ts := GetNowMskTimestamp()
        if (RegExMatch(mode, "i)^(second|sec|s|сек)"))
            actions.Push({t: "text", v: FormatTimeByTs(ts, "dd.MM.yyyy HH:mm:ss")})
        else if (RegExMatch(mode, "i)^(iso)$"))
            actions.Push({t: "text", v: FormatTimeByTs(ts, "yyyy-MM-dd HH:mm")})
        else
            actions.Push({t: "text", v: FormatTimeByTs(ts, "dd.MM.yyyy HH:mm")})
        return actions
    }

    ; RAND / RANDOM: {rand 1-10}
    if (RegExMatch(tag, "i)^(rand|random|случайно)\s+(-?\d+)\s*-\s*(-?\d+)\s*$", m)) {
        a := m2 + 0
        b := m3 + 0
        if (b < a) {
            tmp := a, a := b, b := tmp
        }
        Random, r, %a%, %b%
        actions.Push({t: "text", v: r})
        return actions
    }

    ; UUID
    if (RegExMatch(tag, "i)^(uuid|guid)$")) {
        g := ComObjCreate("Scriptlet.TypeLib").Guid
        g := Trim(g, "{}")
        actions.Push({t: "text", v: g})
        return actions
    }

    ; COUNTER
    if (RegExMatch(tag, "i)^(counter|cnt|счетчик)$")) {
        global specialTagCounter
        if (specialTagCounter = "")
            specialTagCounter := 0
        specialTagCounter++
        actions.Push({t: "text", v: specialTagCounter})
        return actions
    }

    ; ADDITION (1..∞)
    ; {addition} -> 1,2,3...
    ; {addition:reset} -> resets to 0 and returns 0
    ; {addition:start=10} -> sets to 10 and returns 10
    if (RegExMatch(tag, "i)^addition(?::(.*))?$", m)) {
        arg := Trim(m1)
        global specialTagAddition
        if (specialTagAddition = "")
            specialTagAddition := 0
        if (RegExMatch(arg, "i)^reset$")) {
            specialTagAddition := 0
            actions.Push({t: "text", v: specialTagAddition})
            return actions
        }
        if (RegExMatch(arg, "i)^start\\s*=\\s*(-?\\d+)$", s)) {
            specialTagAddition := s1 + 0
            actions.Push({t: "text", v: specialTagAddition})
            return actions
        }
        specialTagAddition++
        actions.Push({t: "text", v: specialTagAddition})
        return actions
    }

    return ""
}

ParseSpecialTagsToActions(text) {
    actions := []
    pos := 1
    while RegExMatch(text, "O)\{([^{}]+)\}", m, pos) {
        pre := SubStr(text, pos, m.Pos(0) - pos)
        if (pre != "")
            actions.Push({t: "text", v: pre})

        token := m.Value(1)
        eval := EvalSpecialTag(token)
        if (IsObject(eval)) {
            for i, a in eval
                actions.Push(a)
        } else {
            ; unknown tag -> keep literal
            actions.Push({t: "text", v: "{" . token . "}"})
        }
        pos := m.Pos(0) + m.Len(0)
    }
    tail := SubStr(text, pos)
    if (tail != "")
        actions.Push({t: "text", v: tail})
    return actions
}

SendTextWithSpecialTags(text, useClipboard, charDelay, speedFactor := 1) {
    global isTyping
    global printTimeDeadline, printTimeLimitHit
    global SpeedSendEngine, SpeedClipboardEngine
    global speedBurstWords, arrhythmiaEnabled, arrhythmiaIntensity, smoothnessEnabled, smoothnessLevel
    global CharDelayMin, CharDelayMax
    if (text = "")
        return true

    ; Ограничение по времени (если выставлено на уровне "Ограничение печати")
    if (printTimeDeadline > 0 && A_TickCount >= printTimeDeadline) {
        printTimeLimitHit := true
        return isTyping
    }

    sf := speedFactor + 0
    if (sf < 1)
        sf := 1

    group := useClipboard ? "clip" : SpeedGroupForEngine(SpeedSendEngine)
    engine := useClipboard ? SpeedClipboardEngine : SpeedSendEngine

    if (!SpeedCfgBool(group, "enabled", true)) {
        ; fallback: old behavior
        if (useClipboard) {
            Clipboard := text
            Sleep, 10
            SendInput, ^v
            return isTyping
        }
        Loop, Parse, text
        {
            if (!isTyping)
                break
            if (printTimeDeadline > 0) {
                remaining := printTimeDeadline - A_TickCount
                if (remaining <= 0) {
                    printTimeLimitHit := true
                    break
                }
                d := charDelay + 0
                if (d > remaining)
                    d := remaining
                if (d > 0)
                    Sleep, %d%
            } else if (charDelay > 0) {
                Sleep, %charDelay%
            }
            if (printTimeDeadline > 0 && A_TickCount >= printTimeDeadline) {
                printTimeLimitHit := true
                break
            }
            SendInput, {Text}%A_LoopField%
        }
        return isTyping
    }

    actions := ParseSpecialTagsToActions(text)
    for i, a in actions {
        if (!isTyping)
            break
        if (printTimeDeadline > 0 && A_TickCount >= printTimeDeadline) {
            printTimeLimitHit := true
            break
        }
        if (a.t = "pause") {
            ms := a.ms + 0
            if (ms > 0) {
                scalePct := SpeedCfgNum(group, "pause_tag_scale_pct", 100)
                if (scalePct < 1)
                    scalePct := 1
                ms := Floor(ms * (scalePct / 100.0))
                minPause := SpeedCfgNum(group, "pause_tag_min_ms", 0)
                if (ms < minPause)
                    ms := minPause
                if (ms > 0) {
                    if (printTimeDeadline > 0) {
                        remaining := printTimeDeadline - A_TickCount
                        if (remaining <= 0) {
                            printTimeLimitHit := true
                            break
                        }
                        if (ms > remaining)
                            ms := remaining
                    }
                    if (ms > 0)
                        Sleep, %ms%
                }
            }
            continue
        }
        seg := a.v
        if (seg = "")
            continue

        seg := ApplyFinalTextStyle(seg)

        ; Optional: split long segments into chunks (affects both clipboard and per-char).
        chunkEnabled := SpeedCfgBool(group, "chunk_enabled", false)
        chunkChars := SpeedCfgNum(group, "chunk_chars", 400)
        chunkPause := SpeedCfgNum(group, "chunk_pause_ms", 0)
        chunks := chunkEnabled ? SpeedSplitChunks(seg, chunkChars) : [seg]

        preSeg := SpeedCfgNum(group, "pre_segment_ms", 0)
        postSeg := SpeedCfgNum(group, "post_segment_ms", 0)
        if (preSeg > 0)
            SpeedSleepScaled(preSeg, sf, group)

        for ci, chunk in chunks {
            if (!isTyping)
                break
            if (printTimeDeadline > 0 && A_TickCount >= printTimeDeadline) {
                printTimeLimitHit := true
                break
            }

            if (useClipboard) {
                restore := SpeedCfgBool(group, "clip_restore_clipboard", true)
                savedClip := ""
                if (restore)
                    savedClip := ClipboardAll

                Clipboard := ""
                SpeedSleepScaled(SpeedCfgNum(group, "clip_clear_ms", 20), sf, group)
                Clipboard := chunk

                timeout := SpeedCfgNum(group, "clip_wait_timeout_s", 2.0)
                minT := SpeedCfgNum(group, "clip_wait_min_s", 0.05)
                effT := timeout / sf
                if (effT < minT)
                    effT := minT
                ClipWait, %effT%

                SpeedSleepScaled(SpeedCfgNum(group, "clip_settle_ms", 50), sf, group)

                clipboardDelay := CalculateClipboardDelay()
                if (clipboardDelay > 0 && isTyping)
                    SpeedSleepScaled(clipboardDelay, sf, group)

                SpeedSleepScaled(SpeedCfgNum(group, "clip_before_paste_ms", 0), sf, group)
                if (isTyping)
                    SendKeysByEngine(engine, "^v")
                SpeedSleepScaled(SpeedCfgNum(group, "clip_post_paste_ms", 100), sf, group)

                retries := SpeedCfgNum(group, "clip_retry_count", 0)
                if (retries > 0 && isTyping) {
                    pauseRetry := SpeedCfgNum(group, "clip_retry_pause_ms", 30)
                    Loop, %retries% {
                        if (!isTyping)
                            break
                        SpeedSleepScaled(pauseRetry, sf, group)
                        SendKeysByEngine(engine, "^v")
                    }
                }

                if (restore) {
                    Clipboard := savedClip
                    ; no extra waits by default; user can add via post_segment_ms if needed
                }
            } else {
                ; Per-char typing with burst words + arrhythmia + smoothness
                burstOn := SpeedCfgBool(group, "burst_enabled", true)
                burstPause := SpeedCfgNum(group, "burst_word_delay_ms", 0)
                cfgExtraMin := SpeedCfgNum(group, "per_char_extra_min_ms", 0)
                cfgExtraMax := SpeedCfgNum(group, "per_char_extra_max_ms", 0)
                jitterOn := SpeedCfgBool(group, "jitter_enabled", false)
                jitterMin := SpeedCfgNum(group, "jitter_min_ms", 0)
                jitterMax := SpeedCfgNum(group, "jitter_max_ms", 0)
                smoothOn := SpeedCfgBool(group, "smooth_enabled", false) || smoothnessEnabled
                smoothPct := SpeedCfgNum(group, "smooth_strength_pct", 50)
                if (smoothPct < 0)
                    smoothPct := 0
                if (smoothPct > 100)
                    smoothPct := 100
                prevDelay := 0

                tokens := SpeedTokenizeText(chunk)
                for ti, tok in tokens {
                    if (!isTyping)
                        break
                    if (printTimeDeadline > 0 && A_TickCount >= printTimeDeadline) {
                        printTimeLimitHit := true
                        break
                    }
                    tval := tok.v
                    if (tval = "")
                        continue

                    if (tok.t = "word" && burstOn && IsObject(speedBurstWords) && speedBurstWords.Length() > 0 && IsBurstWord(tval)) {
                        SendTextByEngine(engine, tval)
                        if (burstPause > 0)
                            SpeedSleepScaled(burstPause, sf, group)
                        continue
                    }

                    Loop, Parse, tval
                    {
                        if (!isTyping)
                            break

                        d := charDelay + 0

                        ; GUI extra delay (min/max) accelerates with multiplier as well.
                        guiMin := CharDelayMin + 0
                        guiMax := CharDelayMax + 0
                        guiExtra := 0
                        if (guiMax > 0) {
                            if (guiMin < 0)
                                guiMin := 0
                            if (guiMax < guiMin) {
                                tmp := guiMin, guiMin := guiMax, guiMax := tmp
                            }
                            Random, guiExtra, %guiMin%, %guiMax%
                        }

                        cfgExtra := 0
                        if (cfgExtraMax > 0) {
                            cMin := cfgExtraMin
                            cMax := cfgExtraMax
                            if (cMin < 0)
                                cMin := 0
                            if (cMax < cMin) {
                                tmp := cMin, cMin := cMax, cMax := tmp
                            }
                            Random, cfgExtra, %cMin%, %cMax%
                        }

                        extraTotal := guiExtra + cfgExtra
                        if (extraTotal > 0)
                            extraTotal := Floor(extraTotal / sf)

                        if (jitterOn && jitterMax != 0) {
                            jMin := jitterMin
                            jMax := jitterMax
                            if (jMax < jMin) {
                                tmp := jMin, jMin := jMax, jMax := tmp
                            }
                            Random, j, %jMin%, %jMax%
                            j := Floor(j / sf)
                            extraTotal += j
                        }

                        delayTotal := d + extraTotal
                        if (delayTotal < 0)
                            delayTotal := 0

                        ; Arrhythmia/smoothness (existing SpeedSettings now реально применяется)
                        if (arrhythmiaEnabled && delayTotal > 0)
                            delayTotal := ApplyArrhythmia(delayTotal)
                        if (smoothOn && delayTotal > 0 && prevDelay > 0) {
                            ; local smoothness (uses global smoothnessLevel) or cfg pct
                            if (smoothnessEnabled)
                                delayTotal := ApplySmoothness(delayTotal, prevDelay)
                            else
                                delayTotal := Round(prevDelay * (smoothPct/100.0) + delayTotal * (1 - (smoothPct/100.0)))
                        }
                        prevDelay := delayTotal

                        if (delayTotal > 0) {
                            delayTotal := SpeedClampSleepMs(delayTotal, group)
                            if (printTimeDeadline > 0) {
                                remaining := printTimeDeadline - A_TickCount
                                if (remaining <= 0) {
                                    printTimeLimitHit := true
                                    break
                                }
                                if (delayTotal > remaining)
                                    delayTotal := remaining
                            }
                            if (delayTotal > 0)
                                Sleep, %delayTotal%
                        }

                        if (printTimeDeadline > 0 && A_TickCount >= printTimeDeadline) {
                            printTimeLimitHit := true
                            break
                        }
                        ch := A_LoopField
                        SendTextByEngine(engine, ch)
                    }
                }
            }

            if (chunkEnabled && chunkPause > 0 && ci < chunks.Length())
                SpeedSleepScaled(chunkPause, sf, group)
        }

        if (postSeg > 0)
            SpeedSleepScaled(postSeg, sf, group)
    }
    return isTyping
}

EncodeSpecialPausesForLegit(text, ByRef pauseList) {
    pauseList := []
    marker := Chr(30)
    actions := ParseSpecialTagsToActions(text)
    out := ""
    for i, a in actions {
        if (a.t = "pause") {
            ms := a.ms + 0
            if (ms > 0) {
                out .= marker
                pauseList.Push(ms)
            }
        } else {
            out .= a.v
        }
    }
    return out
}

ApplyStealthMode(text, source := "") {
    global StealthModeEnabled
    global stealthLastSentText, stealthLastCanonical, stealthMessageCounter
    global stealthLongConfirmGiven, stealthBlockReason
    global stealthRecentCanonicals, stealthRecentSet
    global appDataDir

    stealthBlockReason := ""
    if (!StealthModeEnabled)
        return text

    before := text
    out := text

    ; Safety toggles: if "disable obfuscation/bypass" is enabled, skip anything that tries to change meaning/structure.
    strictSafe := StealthOpt(57) || StealthOpt(58)

    ; Optional: strip invisible chars / keep only readable content.
    if (StealthOpt(56) || StealthOpt(59))
        out := StealthStripInvisible(out)

    ; Normalize newline style early if requested.
    if (StealthOpt(6))
        out := StealthNormalizeNewlines(out)

    ; Protect URLs/emails/markdown/code if requested (placeholder-based).
    protMap := {}
    protId := 0
    if (StealthOpt(14)) {
        while RegExMatch(out, "O)```[\s\S]*?```", m) {
            token := "[[#P" . protId . "#]]"
            protMap[token] := m.Value(0)
            out := SubStr(out, 1, m.Pos(0) - 1) . token . SubStr(out, m.Pos(0) + m.Len(0))
            protId++
        }
    }
    if (StealthOpt(15)) {
        while RegExMatch(out, "O)`[^`]*`", m) {
            token := "[[#P" . protId . "#]]"
            protMap[token] := m.Value(0)
            out := SubStr(out, 1, m.Pos(0) - 1) . token . SubStr(out, m.Pos(0) + m.Len(0))
            protId++
        }
    }
    if (StealthOpt(12)) {
        while RegExMatch(out, "Oi)\bhttps?://\S+|\bwww\.\S+", m) {
            token := "[[#P" . protId . "#]]"
            protMap[token] := m.Value(0)
            out := SubStr(out, 1, m.Pos(0) - 1) . token . SubStr(out, m.Pos(0) + m.Len(0))
            protId++
        }
    }
    if (StealthOpt(13)) {
        while RegExMatch(out, "Oi)\b[\w\.\-\+]+@[\w\.\-]+\.\w+\b", m) {
            token := "[[#P" . protId . "#]]"
            protMap[token] := m.Value(0)
            out := SubStr(out, 1, m.Pos(0) - 1) . token . SubStr(out, m.Pos(0) + m.Len(0))
            protId++
        }
    }
    if (StealthOpt(11)) {
        while RegExMatch(out, "O)\b[А-ЯЁA-Z]{2,}\b", m) {
            token := "[[#P" . protId . "#]]"
            protMap[token] := m.Value(0)
            out := SubStr(out, 1, m.Pos(0) - 1) . token . SubStr(out, m.Pos(0) + m.Len(0))
            protId++
        }
    }

    ; Text normalization
    if (StealthOpt(2))
        out := StrReplace(out, "`t", " ")
    if (StealthOpt(1))
        out := RegExReplace(out, "[ \t]{2,}", " ")
    else if (StealthOpt(5))
        out := RegExReplace(out, " {2,}", " ")
    if (StealthOpt(3))
        out := StealthTrimLines(out)
    if (StealthOpt(4))
        out := StealthCollapseBlankLines(out)
    if (StealthOpt(7))
        out := StealthUnifyQuotes(out)
    if (StealthOpt(8))
        out := StealthUnifyDashes(out)
    if (StealthOpt(9))
        out := AutoCorrectText(out)
    if (StealthOpt(10))
        out := RegExReplace(out, "(^|[.!?]\s+)([A-Za-zА-Яа-яЁё])", "$1$U2")

    ; Formatting / randomization (visible) - skipped in strict-safe mode.
    if (!strictSafe) {
        if (StealthOpt(47))
            out := StealthVarySentenceLength(out)
        if (StealthOpt(54))
            out := StealthVaryLineBreaks(out)
        if (StealthOpt(33) || StealthOpt(48)) {
            ; Mild: shuffle only if multi-line.
            if (InStr(out, "`n"))
                out := ShuffleTextLinesRandom(out)
        }
        if (StealthOpt(39) || StealthOpt(40) || StealthOpt(41) || StealthOpt(42))
            out := StealthApplySeparators(out)
        if (StealthOpt(34))
            out := StealthApplySynonyms(out)
        if (StealthOpt(43))
            out := StealthApplyAbbreviations(out, 0)
        if (StealthOpt(44))
            out := StealthApplyAbbreviations(out, 1)
        if (StealthOpt(55))
            out := StealthApplyWordforms(out)
        if (StealthOpt(35)) {
            tmpl := Random(1, 4)
            if (tmpl = 2)
                out := "(" . Trim(out) . ")"
            else if (tmpl = 3)
                out := "- " . Trim(out)
            else if (tmpl = 4)
                out := """" . Trim(out) . """"
        }
        out := StealthAddIntroOutro(out)
        out := StealthMaybeVaryPunctuation(out)
        out := StealthRandomCaseTouch(out)
    }

    out := StealthStandardizeNumbers(out)
    out := Trim(out, " `t`r`n")

    ; Restore protected segments
    if (IsObject(protMap) && protMap.Count() > 0) {
        for token, val in protMap
            out := StrReplace(out, token, val)
    }

    ; Constraints / checks (anti-accidental spam)
    if (StealthOpt(21) && out = "") {
        stealthBlockReason := "пустое сообщение"
        return ""
    }
    if (StealthOpt(20) && StrLen(out) > 2000)
        out := SubStr(out, 1, 2000)
    if (StealthOpt(19))
        out := StealthWrapLines(out, 120)

    ; Forbidden phrases (from file)
    if (StealthOpt(24)) {
        f := StealthEnsureForbiddenFile()
        bad := StealthLoadLinesFile(f)
        for i, ph in bad {
            if (ph != "" && InStr(out, ph, false)) {
                stealthBlockReason := "запрещенная фраза: " . ph
                return ""
            }
        }
    }

    wc := CountWords(out)
    if (StealthOpt(25) && wc < 2) {
        stealthBlockReason := "слишком мало слов (" . wc . ")"
        return ""
    }
    if (StealthOpt(26) && wc > 200) {
        stealthBlockReason := "слишком много слов (" . wc . ")"
        return ""
    }

    ; Risky patterns: huge repeats
    if (StealthOpt(60)) {
        if (RegExMatch(out, "([^\s])\1{30,}")) {
            stealthBlockReason := "подозрительный повтор символов"
            return ""
        }
    }

    canon := StealthCanonical(out)
    if (StealthOpt(22) && canon != "" && canon = stealthLastCanonical) {
        stealthBlockReason := "повтор подряд"
        return ""
    }
    if (StealthOpt(29) && canon != "" && canon = stealthLastCanonical) {
        stealthBlockReason := "полное совпадение (требуется правка текста)"
        return ""
    }
    if (StealthOpt(27) && stealthLastCanonical != "" && canon != "") {
        sim := StealthJaccardSimilarity(canon, stealthLastCanonical)
        if (sim >= 0.92) {
            stealthBlockReason := "слишком похоже (sim=" . Round(sim, 2) . ")"
            return ""
        }
    }
    if (StealthOpt(28) && canon != "") {
        if (stealthRecentSet.HasKey(canon)) {
            stealthBlockReason := "повтор в последних сообщениях"
            return ""
        }
    }

    ; Preview / confirm
    if (StealthOpt(18) && !stealthLongConfirmGiven && StrLen(out) > 800) {
        outLen := StrLen(out)
        preview := SubStr(out, 1, 800) . (StrLen(out) > 800 ? "`n... (trunc)" : "")
        MsgBox, 36, Stealth, Длинное сообщение (%outLen% символов). Продолжить?`n`n%preview%
        IfMsgBox, No
        {
            stealthBlockReason := "отмена (длинный текст)"
            return ""
        }
        stealthLongConfirmGiven := true
    }
    if (StealthOpt(17)) {
        preview := SubStr(out, 1, 900) . (StrLen(out) > 900 ? "`n... (trunc)" : "")
        MsgBox, 36, Stealth Preview, Отправить?`n`n%preview%
        IfMsgBox, No
        {
            stealthBlockReason := "отмена (preview)"
            return ""
        }
    }

    ; Pause on pattern match (visible throttling)
    if (StealthOpt(23)) {
        if (RegExMatch(out, "i)\bhttps?://|\bwww\.\S+|@everyone|@here")) {
            Sleep, % Random(250, 650)
        }
    }

    ; Timing jitter (visible throttling)
    if (StealthOpt(52)) {
        cap := Min(250, 20 + Round(StrLen(out) / 8))
        if (cap < 0)
            cap := 0
        Sleep, % Random(0, cap)
    }

    ; Numbering (visible)
    nextNum := stealthMessageCounter + 1
    if (StealthOpt(30))
        out := "[#" . nextNum . "] " . out

    stealthMessageCounter := nextNum
    stealthLastSentText := out
    stealthLastCanonical := canon
    if (StealthOpt(28) && canon != "") {
        stealthRecentCanonicals.Push(canon)
        stealthRecentSet[canon] := 1
        while (stealthRecentCanonicals.Length() > 50) {
            old := stealthRecentCanonicals.RemoveAt(1)
            if (old != "")
                stealthRecentSet.Delete(old)
        }
    }

    if (StealthOpt(16))
        StealthAppendLog(source, before, out, stealthBlockReason)

    return out
}

DictStripLogPrefix(line) {
    ; Поддержка разных конфигов словаря: timestamp/source могут быть включены/выключены.
    s := Trim(line, "`r`n")
    s := RegExReplace(s, "^[ \t]*\\[[0-9]{4}-[0-9]{2}-[0-9]{2}[ \t]+[0-9]{2}:[0-9]{2}:[0-9]{2}\\][ \t]*", "")
    s := RegExReplace(s, "^[ \t]*\\([^)]*\\)[ \t]*", "")
    return Trim(s, "`r`n`t ")
}

DictGuiChanged:
    SaveDictGuiToGlobals()
    RefreshDictSettingsTable()
return

DictOpenFolder:
    global dictDir
    Run, %dictDir%
return

DictManualAdd:
    Gui, 1:Submit, NoHide
    txt := Trim(DictManualInput, "`r`n`t ")
    if (txt = "")
        return
    DictCapture(txt, "Manual")
    GuiControl,, DictManualInput,
    SB_SetText("Добавлено в словарь (Manual)", 1)
return

DictAddFromClipboard:
    global dictClipboardSplitLines
    ClipWait, 0.5
    txt := Clipboard
    txt := Trim(txt, "`r`n`t ")
    if (txt = "") {
        SB_SetText("Буфер пуст", 1)
        return
    }
    if (dictClipboardSplitLines) {
        lines := StrSplit(txt, "`n", "`r")
        for i, ln in lines {
            ln := Trim(ln)
            if (ln != "")
                DictCapture(ln, "Clipboard")
        }
    } else {
        DictCapture(txt, "Clipboard")
    }
    SB_SetText("Добавлено из буфера", 1)
return

DictImportFiles:
    global dictImportMaxLines, dictImportSplitLines
    FileSelectFile, files, M3, , Импорт текстов (TXT/LOG/JSONL), Текст (*.txt;*.log;*.jsonl)
    if (ErrorLevel)
        return

    maxLines := dictImportMaxLines + 0
    if (maxLines <= 0)
        maxLines := 100000

    ; FileSelectFile в Multi возвращает список: первая строка = папка, далее имена
    if (InStr(files, "`n")) {
        arr := StrSplit(files, "`n")
        base := arr[1]
        Loop % arr.Length() - 1 {
            fp := base . "\\" . arr[A_Index + 1]
            DictImportOneFile(fp, maxLines, dictImportSplitLines)
        }
    } else {
        DictImportOneFile(files, maxLines, dictImportSplitLines)
    }
    RefreshDictTree()
    SB_SetText("Импорт завершен", 1)
return

DictImportOneFile(path, maxLines, splitLines := 1) {
    if (!FileExist(path))
        return
    FileRead, content, %path%
    if (content = "")
        return

    if (splitLines) {
        lines := StrSplit(content, "`n", "`r")
        n := 0
        for i, ln in lines {
            ln := Trim(ln)
            if (ln = "")
                continue
            DictCapture(ln, "ImportFile")
            n++
            if (n >= maxLines)
                break
        }
    } else {
        DictCapture(content, "ImportFile")
    }
}

; === Функции управления слотами ===
CreateSlot:
    Gui, SlotDialog:New, -Resize -MaximizeBox, Создать слот
    Gui, SlotDialog:Font, s9, Segoe UI
    Gui, SlotDialog:Add, Text, x10 y10, Текст:
    Gui, SlotDialog:Add, Edit, vSlotTextInput x10 y30 w400 h100 Multi
    Gui, SlotDialog:Add, Text, x10 y140, Задержка:
    Gui, SlotDialog:Add, Edit, vSlotDelayInput x80 y137 w80 h20 Number, 0
    Gui, SlotDialog:Add, DropDownList, vSlotDelayUnit x170 y135 w100, Секунды|Минуты
    Gui, SlotDialog:Add, Text, x10 y170, Скорость (букв/сек):
    Gui, SlotDialog:Add, Edit, vSlotSpeedInput x150 y167 w80 h20 Number, 10
    Gui, SlotDialog:Add, Button, x10 y200 w195 h30 gSlotDialogOK, ✓ Сохранить
    Gui, SlotDialog:Add, Button, x215 y200 w195 h30 gSlotDialogCancel, ✗ Отмена
    Gui, SlotDialog:Show
return

EditSlot:
    Gui, 1:Submit, NoHide
    Gui, ListView, SlotsList
    selectedRow := LV_GetNext()
    if (!selectedRow) {
        MsgBox, 48, Ошибка, Выберите слот для редактирования!
        return
    }
    
    slotIndex := selectedRow
    slot := slots[slotIndex]
    
    Gui, EditSlotDialog:New, -Resize -MaximizeBox, Редактировать слот
    Gui, EditSlotDialog:Font, s9, Segoe UI
    Gui, EditSlotDialog:Add, Text, x10 y10, Текст:
    Gui, EditSlotDialog:Add, Edit, vEditSlotTextInput x10 y30 w400 h100 Multi, % slot.text
    Gui, EditSlotDialog:Add, Text, x10 y140, Задержка:
    Gui, EditSlotDialog:Add, Edit, vEditSlotDelayInput x80 y137 w80 h20 Number, % slot.delay
    Gui, EditSlotDialog:Add, DropDownList, vEditSlotDelayUnit x170 y135 w100, Секунды|Минуты
    GuiControl, ChooseString, EditSlotDelayUnit, % slot.delayUnit
    Gui, EditSlotDialog:Add, Text, x10 y170, Скорость (букв/сек):
    Gui, EditSlotDialog:Add, Edit, vEditSlotSpeedInput x150 y167 w80 h20 Number, % slot.speed
    Gui, EditSlotDialog:Add, Button, x10 y200 w195 h30 gEditSlotDialogOK, ✓ Сохранить
    Gui, EditSlotDialog:Add, Button, x215 y200 w195 h30 gEditSlotDialogCancel, ✗ Отмена
    Gui, EditSlotDialog:Show
    global editingSlotIndex := slotIndex
return

DeleteSlot:
    Gui, 1:Submit, NoHide
    Gui, ListView, SlotsList
    selectedRow := LV_GetNext()
    if (!selectedRow) {
        MsgBox, 48, Ошибка, Выберите слот для удаления!
        return
    }
    
    slotIndex := selectedRow
    slots.RemoveAt(slotIndex)
    UpdateSlotsList()
    SaveSlots()
return

MoveSlotUp:
    Gui, 1:Submit, NoHide
    Gui, ListView, SlotsList
    selectedRow := LV_GetNext()
    if (!selectedRow || selectedRow = 1) {
        return
    }
    
    slotIndex := selectedRow
    temp := slots[slotIndex]
    slots[slotIndex] := slots[slotIndex - 1]
    slots[slotIndex - 1] := temp
    UpdateSlotsList()
    LV_Modify(selectedRow - 1, "Select")
    SaveSlots()
return

MoveSlotDown:
    Gui, 1:Submit, NoHide
    Gui, ListView, SlotsList
    selectedRow := LV_GetNext()
    if (!selectedRow || selectedRow >= slots.Length()) {
        return
    }
    
    slotIndex := selectedRow
    temp := slots[slotIndex]
    slots[slotIndex] := slots[slotIndex + 1]
    slots[slotIndex + 1] := temp
    UpdateSlotsList()
    LV_Modify(selectedRow + 1, "Select")
    SaveSlots()
return

SlotSelected:
    ; Обработка выбора слота в списке
    if (A_GuiEvent = "DoubleClick") {
        Gui, ListView, SlotsList
        selectedRow := LV_GetNext()
        if (selectedRow = 0)
            return
        
        ; Получаем координаты клика для определения колонки
        Gui, +LastFound
        GuiHwnd := WinExist()
        
        ; Получаем позицию ListView
        ControlGetPos, lvX, lvY, lvW, lvH, SysListView321, ahk_id %GuiHwnd%
        
        ; Получаем координаты мыши относительно экрана
        CoordMode, Mouse, Screen
        MouseGetPos, mouseScreenX, mouseScreenY
        
        ; Конвертируем в координаты относительно окна
        WinGetPos, winX, winY, , , ahk_id %GuiHwnd%
        mouseX := mouseScreenX - winX - lvX
        
        ; Определяем колонку по позиции
        ; Колонка 1 (Текст): 0-300
        ; Колонка 2 (Задержка): 300-420  
        ; Колонка 3 (Скорость): 420-520
        
        if (mouseX >= 0 && mouseX < 300) {
            ; Колонка 1 - Текст
            EditSlotTextQuick(selectedRow)
        } else if (mouseX >= 300 && mouseX < 420) {
            ; Колонка 2 - Задержка
            EditSlotDelayQuick(selectedRow)
        } else if (mouseX >= 420 && mouseX < 520) {
            ; Колонка 3 - Скорость
            EditSlotSpeedQuick(selectedRow)
        }
    }
return

; === БЫСТРОЕ РЕДАКТИРОВАНИЕ СЛОТОВ (по двойному клику) ===

; Редактирование текста слота
EditSlotTextQuick(rowIndex) {
    global slots
    if (rowIndex < 1 || rowIndex > slots.Length())
        return
    
    slot := slots[rowIndex]
    InputBox, newText, Редактировать текст, Введите новый текст:, , 500, 150, , , , , % slot.text
    if (!ErrorLevel && newText != "") {
        slots[rowIndex].text := newText
        UpdateSlotsList()
        SaveSlots()
        SB_SetText("Текст слота обновлен", 1)
    }
}

; Редактирование задержки слота
EditSlotDelayQuick(rowIndex) {
    global slots, quickDelayRowIndex
    quickDelayRowIndex := rowIndex
    if (rowIndex < 1 || rowIndex > slots.Length())
        return
    
    slot := slots[rowIndex]
    currentDelay := slot.delay
    currentUnit := slot.delayUnit
    
    ; Создаем диалог для редактирования задержки
    Gui, QuickDelayDialog:New, +Owner1 +AlwaysOnTop, Редактировать задержку
    Gui, QuickDelayDialog:Font, s9, Segoe UI
    Gui, QuickDelayDialog:Add, Text, x10 y10, Задержка:
    Gui, QuickDelayDialog:Add, Edit, vQuickDelayInput x80 y8 w80 h20 Number, %currentDelay%
    Gui, QuickDelayDialog:Add, DropDownList, vQuickDelayUnit x170 y6 w100, Секунды|Минуты
    GuiControl, QuickDelayDialog:ChooseString, QuickDelayUnit, %currentUnit%
    Gui, QuickDelayDialog:Add, Button, x10 y40 w130 h30 gQuickDelayOK, ✓ Сохранить
    Gui, QuickDelayDialog:Add, Button, x150 y40 w130 h30 gQuickDelayCancel, ✗ Отмена
    Gui, QuickDelayDialog:Show, w290 h80, Редактировать задержку
}

; Редактирование скорости слота
EditSlotSpeedQuick(rowIndex) {
    global slots
    if (rowIndex < 1 || rowIndex > slots.Length())
        return
    
    slot := slots[rowIndex]
    currentSpeed := slot.speed
    
    InputBox, newSpeed, Редактировать скорость, Введите новую скорость (букв/сек):, , 300, 140, , , , , %currentSpeed%
    if (!ErrorLevel && newSpeed != "") {
        if (!RegExMatch(newSpeed, "^\d+$") || newSpeed <= 0) {
            MsgBox, 48, Ошибка, Укажите корректную скорость (положительное число)!
            return
        }
        slots[rowIndex].speed := newSpeed
        UpdateSlotsList()
        SaveSlots()
        SB_SetText("Скорость слота обновлена", 1)
    }
}

SlotDialogOK:
    Gui, SlotDialog:Submit
    if (SlotTextInput = "") {
        MsgBox, 48, Ошибка, Введите текст слота!
        return
    }
    if (!RegExMatch(SlotSpeedInput, "^\d+$") || SlotSpeedInput <= 0) {
        MsgBox, 48, Ошибка, Укажите корректную скорость!
        return
    }
    
    newSlot := {text: SlotTextInput, delay: SlotDelayInput, delayUnit: SlotDelayUnit, speed: SlotSpeedInput}
    slots.Push(newSlot)
    Gui, SlotDialog:Destroy
    Gui, 1:Default
    UpdateSlotsList()
    SaveSlots()
return

SlotDialogCancel:
    Gui, SlotDialog:Destroy
return

SlotDialogGuiClose:
    Gui, SlotDialog:Destroy
return

EditSlotDialogOK:
    Gui, EditSlotDialog:Submit
    if (EditSlotTextInput = "") {
        MsgBox, 48, Ошибка, Введите текст слота!
        return
    }
    if (!RegExMatch(EditSlotSpeedInput, "^\d+$") || EditSlotSpeedInput <= 0) {
        MsgBox, 48, Ошибка, Укажите корректную скорость!
        return
    }
    
    slots[editingSlotIndex] := {text: EditSlotTextInput, delay: EditSlotDelayInput, delayUnit: EditSlotDelayUnit, speed: EditSlotSpeedInput}
    Gui, EditSlotDialog:Destroy
    global editingSlotIndex := ""
    Gui, 1:Default
    UpdateSlotsList()
    SaveSlots()
return

EditSlotDialogCancel:
    Gui, EditSlotDialog:Destroy
    global editingSlotIndex := ""
return

EditSlotDialogGuiClose:
    Gui, EditSlotDialog:Destroy
    global editingSlotIndex := ""
return

QuickDelayOK:
    Gui, QuickDelayDialog:Submit
    global slots, quickDelayRowIndex
    
    if (quickDelayRowIndex < 1 || quickDelayRowIndex > slots.Length())
        return
    
    slots[quickDelayRowIndex].delay := QuickDelayInput
    slots[quickDelayRowIndex].delayUnit := QuickDelayUnit
    UpdateSlotsList()
    SaveSlots()
    Gui, QuickDelayDialog:Destroy
    Gui, 1:Default
    SB_SetText("Задержка слота обновлена", 1)
return

QuickDelayCancel:
    Gui, QuickDelayDialog:Destroy
    Gui, 1:Default
return

QuickDelayDialogGuiClose:
    Gui, QuickDelayDialog:Destroy
    Gui, 1:Default
return

; === Импорт строк в слоты ===
ImportToSlots:
    Gui, 1:Submit, NoHide
    global slots, TypeText
    
    if (TypeText = "") {
        MsgBox, 48, Ошибка, Текстовое поле пусто! Введите текст для импорта.
        return
    }
    
    ; Подтверждение
    MsgBox, 4, Подтверждение, Импортировать каждую строку текста в новый слот?`n`nТекущие слоты будут очищены.
    IfMsgBox No
        return
    
    ; Очищаем текущие слоты
    slots := []
    
    ; Разбиваем текст на строки и создаем слоты
    lineCount := 0
    Loop, Parse, TypeText, `n, `r
    {
        line := Trim(A_LoopField)
        if (line != "") {
            ; Создаем слот с дефолтными параметрами
            newSlot := {text: line, delay: 0, delayUnit: "Секунды", speed: 10}
            slots.Push(newSlot)
            lineCount++
        }
    }
    
    if (lineCount = 0) {
        MsgBox, 48, Ошибка, Не найдено ни одной непустой строки для импорта!
        return
    }
    
    ; Обновляем список слотов
    UpdateSlotsList()
    SaveSlots()
    
    ; Переключаемся на вкладку "По слотам"
    GuiControl, Choose, SysTabControl321, 11
    
    SB_SetText("Импортировано " . lineCount . " строк в слоты", 1)
    MsgBox, 64, Успех, Успешно импортировано %lineCount% строк в слоты!
return

UpdateSlotsList() {
    global slots
    Gui, 1:Default
    Gui, ListView, SlotsList
    GuiControl, -Redraw, SlotsList
    LV_Delete()
    
    for i, slot in slots {
        delayText := slot.delay . " " . slot.delayUnit
        LV_Add("", slot.text, delayText, slot.speed)
    }
    
    GuiControl, +Redraw, SlotsList
}

SaveSlots() {
    global slots
    ; Удаляем старые записи
    IniDelete, %appDataDir%\AutoTyper.ini, Slots
    ; Сохраняем количество слотов
    IniWrite, % slots.Length(), %appDataDir%\AutoTyper.ini, Slots, Count
    ; Сохраняем каждый слот
    for i, slot in slots {
        section := "Slot" . i
        IniWrite, % slot.text, %appDataDir%\AutoTyper.ini, %section%, Text
        IniWrite, % slot.delay, %appDataDir%\AutoTyper.ini, %section%, Delay
        IniWrite, % slot.delayUnit, %appDataDir%\AutoTyper.ini, %section%, DelayUnit
        IniWrite, % slot.speed, %appDataDir%\AutoTyper.ini, %section%, Speed
    }
}

LoadSlots() {
    global slots
    slots := []
    IniRead, slotCount, %appDataDir%\AutoTyper.ini, Slots, Count, 0
    if (slotCount > 0) {
        Loop, %slotCount% {
            section := "Slot" . A_Index
            IniRead, slotText, %appDataDir%\AutoTyper.ini, %section%, Text,
            IniRead, slotDelay, %appDataDir%\AutoTyper.ini, %section%, Delay, 0
            IniRead, slotDelayUnit, %appDataDir%\AutoTyper.ini, %section%, DelayUnit, Секунды
            IniRead, slotSpeed, %appDataDir%\AutoTyper.ini, %section%, Speed, 10
            if (slotText != "") {
                slots.Push({text: slotText, delay: slotDelay, delayUnit: slotDelayUnit, speed: slotSpeed})
            }
        }
    }
    UpdateSlotsList()
}

; === ФУНКЦИИ РАБОТЫ С ШАБЛОНАМИ СЛОТОВ ===

; Загрузить список шаблонов слотов
LoadSlotsTemplates() {
    global slotsTemplatesDir
    
    ; Создаем папку для шаблонов если не существует
    if (!FileExist(slotsTemplatesDir))
        FileCreateDir, %slotsTemplatesDir%
    
    GuiControl,, SlotsTemplateList, |
    templateCount := 0
    Loop, Files, %slotsTemplatesDir%\*.ini
    {
        name := RegExReplace(A_LoopFileName, "\.ini$")
        GuiControl,, SlotsTemplateList, %name%
        templateCount++
    }
}

; Сохранить шаблон слотов
SaveSlotsTemplate:
    Gui, 1:Submit, NoHide
    global slots, slotsTemplatesDir
    
    if (slots.Length() = 0) {
        MsgBox, 48, Ошибка, Нет слотов для сохранения!
        return
    }
    
    InputBox, templateName, Сохранить шаблон слотов, Введите имя шаблона:, , 300, 140
    if (ErrorLevel || templateName = "")
        return
    
    ; Удаляем недопустимые символы из имени файла
    templateName := RegExReplace(templateName, "[<>:""/\\|?*]", "_")
    
    ; Создаем папку если не существует
    if (!FileExist(slotsTemplatesDir))
        FileCreateDir, %slotsTemplatesDir%
    
    ; Сохраняем шаблон в INI файл
    templatePath := slotsTemplatesDir . "\" . templateName . ".ini"
    FileDelete, %templatePath%
    
    ; Сохраняем количество слотов
    IniWrite, % slots.Length(), %templatePath%, Slots, Count
    
    ; Сохраняем каждый слот
    for i, slot in slots {
        section := "Slot" . i
        IniWrite, % slot.text, %templatePath%, %section%, Text
        IniWrite, % slot.delay, %templatePath%, %section%, Delay
        IniWrite, % slot.delayUnit, %templatePath%, %section%, DelayUnit
        IniWrite, % slot.speed, %templatePath%, %section%, Speed
    }
    
    LoadSlotsTemplates()
    GuiControl, ChooseString, SlotsTemplateList, %templateName%
    SB_SetText("Шаблон сохранен: " . templateName, 1)
return

; Загрузить шаблон слотов
LoadSlotsTemplate:
    Gui, 1:Submit, NoHide
    global slots, slotsTemplatesDir
    
    if (SlotsTemplateList = "") {
        MsgBox, 48, Ошибка, Выберите шаблон для загрузки!
        return
    }
    
    MsgBox, 4, Загрузить шаблон?, Загрузить шаблон "%SlotsTemplateList%"?`n`nТекущие слоты будут заменены.
    IfMsgBox, No
        return
    
    templatePath := slotsTemplatesDir . "\" . SlotsTemplateList . ".ini"
    if (!FileExist(templatePath)) {
        MsgBox, 16, Ошибка, Файл шаблона не найден!
        return
    }
    
    ; Загружаем слоты из шаблона
    slots := []
    IniRead, slotCount, %templatePath%, Slots, Count, 0
    if (slotCount > 0) {
        Loop, %slotCount% {
            section := "Slot" . A_Index
            IniRead, slotText, %templatePath%, %section%, Text,
            IniRead, slotDelay, %templatePath%, %section%, Delay, 0
            IniRead, slotDelayUnit, %templatePath%, %section%, DelayUnit, Секунды
            IniRead, slotSpeed, %templatePath%, %section%, Speed, 10
            if (slotText != "") {
                slots.Push({text: slotText, delay: slotDelay, delayUnit: slotDelayUnit, speed: slotSpeed})
            }
        }
    }
    
    ; Сохраняем загруженные слоты в основной конфиг
    SaveSlots()
    UpdateSlotsList()
    SB_SetText("Шаблон загружен: " . SlotsTemplateList, 1)
return

; Удалить шаблон слотов
DeleteSlotsTemplate:
    Gui, 1:Submit, NoHide
    global slotsTemplatesDir
    
    if (SlotsTemplateList = "") {
        MsgBox, 48, Ошибка, Выберите шаблон для удаления!
        return
    }
    
    MsgBox, 4, Удалить шаблон?, Удалить шаблон "%SlotsTemplateList%"?
    IfMsgBox, Yes
    {
        templatePath := slotsTemplatesDir . "\" . SlotsTemplateList . ".ini"
        FileDelete, %templatePath%
        LoadSlotsTemplates()
        GuiControl,, SlotsTemplateList,
        SB_SetText("Шаблон удалён", 1)
    }
return

; Обновить список шаблонов
RefreshSlotsTemplates:
    LoadSlotsTemplates()
    SB_SetText("Список обновлён", 1)
return

; Выбор шаблона (для предпросмотра)
SlotsTemplateSelected:
    ; Можно добавить предпросмотр, но пока просто обновляем список
return

; === МАССОВОЕ РЕДАКТИРОВАНИЕ СЛОТОВ ===

; Получить все выделенные строки
GetSelectedSlots() {
    Gui, ListView, SlotsList
    selectedRows := []
    row := 0
    Loop {
        row := LV_GetNext(row)
        if (!row)
            break
        selectedRows.Push(row)
    }
    return selectedRows
}

; Массовое редактирование задержки
BulkEditDelay:
    Gui, ListView, SlotsList
    selectedRows := GetSelectedSlots()
    
    if (selectedRows.Length() = 0) {
        MsgBox, 48, Ошибка, Выберите слоты для редактирования!
        return
    }
    
    global slots, bulkSelectedRows
    ; Сохраняем выделенные строки в глобальной переменной
    bulkSelectedRows := selectedRows
    selectedCount := selectedRows.Length()
    
    ; Берем задержку первого выделенного слота как пример
    firstSlot := slots[selectedRows[1]]
    currentDelay := firstSlot.delay
    currentUnit := firstSlot.delayUnit
    
    ; Создаем диалог для массового редактирования задержки
    Gui, BulkDelayDialog:New, +Owner1 +AlwaysOnTop, Массовое редактирование задержки
    Gui, BulkDelayDialog:Font, s9, Segoe UI
    Gui, BulkDelayDialog:Add, Text, x10 y10, Выбрано слотов: %selectedCount%
    Gui, BulkDelayDialog:Add, Text, x10 y35, Задержка:
    Gui, BulkDelayDialog:Add, Edit, vBulkDelayInput x80 y32 w80 h20 Number, %currentDelay%
    Gui, BulkDelayDialog:Add, DropDownList, vBulkDelayUnit x170 y30 w100, Секунды|Минуты
    GuiControl, BulkDelayDialog:ChooseString, BulkDelayUnit, %currentUnit%
    Gui, BulkDelayDialog:Add, Button, x10 y65 w130 h30 gBulkDelayOK, ✓ Применить
    Gui, BulkDelayDialog:Add, Button, x150 y65 w130 h30 gBulkDelayCancel, ✗ Отмена
    Gui, BulkDelayDialog:Show, w290 h105, Массовое редактирование задержки
return

BulkDelayOK:
    Gui, BulkDelayDialog:Submit
    global slots, bulkSelectedRows
    
    if (bulkSelectedRows.Length() = 0) {
        Gui, BulkDelayDialog:Destroy
        return
    }
    
    ; Сохраняем количество перед очисткой
    count := bulkSelectedRows.Length()
    
    ; Применяем задержку ко всем выделенным слотам
    for i, rowIndex in bulkSelectedRows {
        slots[rowIndex].delay := BulkDelayInput
        slots[rowIndex].delayUnit := BulkDelayUnit
    }
    
    UpdateSlotsList()
    SaveSlots()
    Gui, BulkDelayDialog:Destroy
    Gui, 1:Default
    bulkSelectedRows := []
    SB_SetText("Задержка изменена для " . count . " слотов", 1)
return

BulkDelayCancel:
    global bulkSelectedRows
    Gui, BulkDelayDialog:Destroy
    Gui, 1:Default
    bulkSelectedRows := []
return

BulkDelayDialogGuiClose:
    global bulkSelectedRows
    Gui, BulkDelayDialog:Destroy
    Gui, 1:Default
    bulkSelectedRows := []
return

; Массовое редактирование скорости
BulkEditSpeed:
    Gui, ListView, SlotsList
    selectedRows := GetSelectedSlots()
    
    if (selectedRows.Length() = 0) {
        MsgBox, 48, Ошибка, Выберите слоты для редактирования!
        return
    }
    
    global slots
    ; Берем скорость первого выделенного слота как пример
    firstSlot := slots[selectedRows[1]]
    currentSpeed := firstSlot.speed
    selectedCount := selectedRows.Length()
    
    InputBox, newSpeed, Массовое редактирование скорости, Выбрано слотов: %selectedCount%`n`nВведите новую скорость (букв/сек):, , 300, 160, , , , , %currentSpeed%
    if (!ErrorLevel && newSpeed != "") {
        if (!RegExMatch(newSpeed, "^\d+$") || newSpeed <= 0) {
            MsgBox, 48, Ошибка, Укажите корректную скорость (положительное число)!
            return
        }
        
        ; Применяем скорость ко всем выделенным слотам
        for i, rowIndex in selectedRows {
            slots[rowIndex].speed := newSpeed
        }
        
        UpdateSlotsList()
        SaveSlots()
        SB_SetText("Скорость изменена для " . selectedRows.Length() . " слотов", 1)
    }
return

; === ОКНО НАСТРОЕК СЛОТОВ ===
OpenSlotsSettings:
    global slotsRepeatCount, slotsErrorLevel, slotsCapitalizeFirst, slotsPrintTranslit, slotsStartPosition
    
    ; Создаем окно настроек
    Gui, SlotsSettings:New, +Owner1 +AlwaysOnTop, Настройки слотов
    Gui, SlotsSettings:Font, s9, Segoe UI
    Gui, SlotsSettings:Add, Text, x10 y10, Цикл повторов:
    Gui, SlotsSettings:Add, Edit, vSlotsSettingsRepeatCount x150 y8 w100 Number, %slotsRepeatCount%
    Gui, SlotsSettings:Add, Text, x260 y10 cGray, (сколько раз будет повторяться печать)
    
    Gui, SlotsSettings:Add, Text, x10 y45, Уровень ошибок:
    Gui, SlotsSettings:Add, DropDownList, vSlotsSettingsErrorLevel x150 y42 w200, Нет|Лёгкий|Средний|Высокий|Экстремальный
    GuiControl, SlotsSettings:ChooseString, SlotsSettingsErrorLevel, %slotsErrorLevel%
    
    Gui, SlotsSettings:Add, Text, x10 y80, Первая буква всегда заглавная:
    Gui, SlotsSettings:Add, Checkbox, vSlotsSettingsCapitalizeFirst x150 y78, Включено
    if (slotsCapitalizeFirst)
        GuiControl, SlotsSettings:, SlotsSettingsCapitalizeFirst, 1
    
    Gui, SlotsSettings:Add, Text, x10 y115, Печать транслитом:
    Gui, SlotsSettings:Add, DropDownList, vSlotsSettingsPrintTranslit x150 y112 w200, Выключено|Включено
    GuiControl, SlotsSettings:ChooseString, SlotsSettingsPrintTranslit, %slotsPrintTranslit%
    
    Gui, SlotsSettings:Add, Text, x10 y150, Откуда начать печатать:
    Gui, SlotsSettings:Add, DropDownList, vSlotsSettingsStartPosition x150 y147 w200, С начала|С середины|С конца|Случайно
    GuiControl, SlotsSettings:ChooseString, SlotsSettingsStartPosition, %slotsStartPosition%
    
    Gui, SlotsSettings:Add, Button, x10 y185 w185 gSlotsSettingsOK, ✓ Сохранить
    Gui, SlotsSettings:Add, Button, x205 y185 w185 gSlotsSettingsCancel, ✗ Отмена
    Gui, SlotsSettings:Show, w400 h225, Настройки слотов
return

SlotsSettingsOK:
    Gui, SlotsSettings:Submit
    global slotsRepeatCount, slotsErrorLevel, slotsCapitalizeFirst, slotsPrintTranslit, slotsStartPosition
    
    if (SlotsSettingsRepeatCount < 1) {
        MsgBox, 48, Ошибка, Количество повторов должно быть больше 0!
        return
    }
    
    slotsRepeatCount := SlotsSettingsRepeatCount
    slotsErrorLevel := SlotsSettingsErrorLevel
    slotsCapitalizeFirst := SlotsSettingsCapitalizeFirst ? 1 : 0
    slotsPrintTranslit := SlotsSettingsPrintTranslit
    slotsStartPosition := SlotsSettingsStartPosition
    
    ; Сохраняем настройки в INI
    IniWrite, %slotsRepeatCount%, %appDataDir%\AutoTyper.ini, Slots, RepeatCount
    IniWrite, %slotsErrorLevel%, %appDataDir%\AutoTyper.ini, Slots, ErrorLevel
    IniWrite, %slotsCapitalizeFirst%, %appDataDir%\AutoTyper.ini, Slots, CapitalizeFirst
    IniWrite, %slotsPrintTranslit%, %appDataDir%\AutoTyper.ini, Slots, PrintTranslit
    IniWrite, %slotsStartPosition%, %appDataDir%\AutoTyper.ini, Slots, StartPosition
    
    Gui, SlotsSettings:Destroy
    Gui, 1:Default
    SB_SetText("Настройки слотов сохранены", 1)
return

SlotsSettingsCancel:
    Gui, SlotsSettings:Destroy
    Gui, 1:Default
return

SlotsSettingsGuiClose:
    Gui, SlotsSettings:Destroy
    Gui, 1:Default
return

; === ФУНКЦИИ КОНСТРУКТОРА БИНДОВ ===

; Добавить бинд
AddBind:
    Gui, BindDialog:New, , Добавить бинд
    Gui, BindDialog:Font, s9, Segoe UI
    
    Gui, BindDialog:Add, Text, x10 y10, Действие:
    Gui, BindDialog:Add, DropDownList, vBindAction x10 y30 w350 gUpdateBindParameters, Старт печати|Стоп печати|Пауза печати|Переключить режим на: Обычный текст|Переключить режим на: Генератор текста|Переключить режим на: По слотам|Установить Auto-Enter макс. слов|Установить Auto-Enter время|Отключить Auto-Enter|Изменить скорость|Сменить ускорение|Установить регистр текста|Установить уровень ошибок|Генератор: по строкам|Генератор: по словам|Тестовая генерация|Открыть конструктор|Сохранить настройки|Очистить текст
    
    Gui, BindDialog:Add, Text, x10 y70 vBindParamLabel, Параметр:
    Gui, BindDialog:Add, Edit, vBindParameter x10 y90 w350 h20
    Gui, BindDialog:Add, Text, x10 y115 vBindParamHint cGray, Введите параметр (например: 5 для макс. слов)
    
    Gui, BindDialog:Add, Text, x10 y145, Горячая клавиша:
    Gui, BindDialog:Add, Edit, vBindHotkey x10 y165 w350 h20
    Gui, BindDialog:Add, Text, x10 y190 cGray, Пример: F11, ^!s (Ctrl+Alt+S), +F12 (Shift+F12)
    
    Gui, BindDialog:Add, Button, x10 y220 w170 h30 gBindDialogOK, ✓ Добавить
    Gui, BindDialog:Add, Button, x190 y220 w170 h30 gBindDialogCancel, ✗ Отмена
    
    Gui, BindDialog:Show, w370 h260
return

UpdateBindParameters:
    Gui, BindDialog:Submit, NoHide
    
    ; Показываем/скрываем поле параметров в зависимости от действия
    needsParameter := InStr(BindAction, "Установить Auto-Enter") || InStr(BindAction, "Изменить скорость") || InStr(BindAction, "Сменить ускорение") || InStr(BindAction, "регистр") || InStr(BindAction, "уровень ошибок") || InStr(BindAction, "Генератор:")
    
    if (needsParameter) {
        GuiControl, BindDialog:Show, BindParamLabel
        GuiControl, BindDialog:Show, BindParameter
        GuiControl, BindDialog:Show, BindParamHint
        
        ; Обновляем подсказку
        if (InStr(BindAction, "макс. слов"))
            GuiControl, BindDialog:, BindParamHint, Введите максимальное количество слов (например: 5)
        else if (InStr(BindAction, "время"))
            GuiControl, BindDialog:, BindParamHint, Введите время в мс (например: 1000)
        else if (InStr(BindAction, "скорость"))
            GuiControl, BindDialog:, BindParamHint, Введите скорость (например: 20 для 20 букв/сек)
        else if (InStr(BindAction, "ускорение"))
            GuiControl, BindDialog:, BindParamHint, Введите множитель (например: 10 для 10x)
        else if (InStr(BindAction, "регистр"))
            GuiControl, BindDialog:, BindParamHint, Введите: Обычный, ВЕРХНИЙ, нижний или Случайный
        else if (InStr(BindAction, "уровень ошибок"))
            GuiControl, BindDialog:, BindParamHint, Введите: Нет, Лёгкий, Средний, Высокий или Экстремальный
        else if (InStr(BindAction, "по строкам"))
            GuiControl, BindDialog:, BindParamHint, Введите количество строк (например: 3)
        else if (InStr(BindAction, "по словам"))
            GuiControl, BindDialog:, BindParamHint, Введите количество слов (например: 10)
    } else {
        GuiControl, BindDialog:Hide, BindParamLabel
        GuiControl, BindDialog:Hide, BindParameter
        GuiControl, BindDialog:Hide, BindParamHint
    }
return

BindDialogOK:
    Gui, BindDialog:Submit
    global actionBinds
    
    if (BindHotkey = "") {
        MsgBox, 48, Ошибка, Введите горячую клавишу!
        return
    }
    
    if (BindAction = "") {
        MsgBox, 48, Ошибка, Выберите действие!
        return
    }
    
    ; Проверяем, не использует ли пользователь зарезервированные клавиши
    if (BindHotkey = "!c" || BindHotkey = "Alt+C") {
        MsgBox, 48, Ошибка, Клавиша Alt+C зарезервирована для контекстного меню!`nИспользуйте другую комбинацию.
        return
    }
    if (BindHotkey = "!x" || BindHotkey = "Alt+X") {
        MsgBox, 48, Ошибка, Клавиша Alt+X зарезервирована для быстрого управления вставками!`nИспользуйте другую комбинацию.
        return
    }
    if (BindHotkey = "!z" || BindHotkey = "Alt+Z") {
        MsgBox, 48, Ошибка, Клавиша Alt+Z зарезервирована для окна нейросети!`nИспользуйте другую комбинацию.
        return
    }
    if (BindHotkey = "!v" || BindHotkey = "Alt+V") {
        MsgBox, 48, Ошибка, Клавиша Alt+V зарезервирована для нейросети (ответ на выделенный текст)!`nИспользуйте другую комбинацию.
        return
    }
    
    ; Проверяем, не занята ли уже эта клавиша
    for i, bind in actionBinds {
        bindHotkey := bind.hotkey
        if (bindHotkey = BindHotkey) {
            MsgBox, 48, Ошибка, Клавиша "%BindHotkey%" уже используется!
            return
        }
    }
    
    ; Добавляем бинд
    actionBinds.Push({hotkey: BindHotkey, action: BindAction, parameter: BindParameter, enabled: true})
    
    ; Регистрируем горячую клавишу
    RegisterActionHotkey(BindHotkey, actionBinds.Length())
    
    Gui, BindDialog:Destroy
    UpdateBindsList()
    SaveBinds()
    SB_SetText("Бинд добавлен", 1)
return

BindDialogCancel:
    Gui, BindDialog:Destroy
return

BindDialogGuiClose:
    Gui, BindDialog:Destroy
return

; Редактировать бинд
EditBind:
    Gui, 1:Submit, NoHide
    Gui, ListView, BindsList
    
    selectedRow := LV_GetNext(0)
    if (selectedRow = 0) {
        MsgBox, 48, Ошибка, Выберите бинд для редактирования!
        return
    }
    
    global actionBinds
    bind := actionBinds[selectedRow]
    bindHotkey := bind.hotkey
    
    ; Удаляем старую горячую клавишу
    try {
        Hotkey, %bindHotkey%, Off
    }
    
    Gui, EditBindDialog:New, , Редактировать бинд
    Gui, EditBindDialog:Font, s9, Segoe UI
    
    bindAction := bind.action
    bindParameter := bind.parameter
    
    Gui, EditBindDialog:Add, Text, x10 y10, Действие:
    Gui, EditBindDialog:Add, DropDownList, vEditBindAction x10 y30 w350, Старт печати|Стоп печати|Пауза печати|Переключить режим на: Обычный текст|Переключить режим на: Генератор текста|Переключить режим на: По слотам|Установить Auto-Enter макс. слов|Установить Auto-Enter время|Отключить Auto-Enter|Изменить скорость|Сменить ускорение|Установить регистр текста|Установить уровень ошибок|Генератор: по строкам|Генератор: по словам|Тестовая генерация|Открыть конструктор|Сохранить настройки|Очистить текст
    GuiControl, EditBindDialog:ChooseString, EditBindAction, %bindAction%
    
    Gui, EditBindDialog:Add, Text, x10 y70, Параметр:
    Gui, EditBindDialog:Add, Edit, vEditBindParameter x10 y90 w350 h20, %bindParameter%
    
    Gui, EditBindDialog:Add, Text, x10 y120, Горячая клавиша:
    Gui, EditBindDialog:Add, Edit, vEditBindHotkey x10 y140 w350 h20, %bindHotkey%
    
    Gui, EditBindDialog:Add, Button, x10 y180 w170 h30 gEditBindDialogOK, ✓ Сохранить
    Gui, EditBindDialog:Add, Button, x190 y180 w170 h30 gEditBindDialogCancel, ✗ Отмена
    
    Gui, EditBindDialog:Show, w370 h220
    global editingBindIndex := selectedRow
return

EditBindDialogOK:
    Gui, EditBindDialog:Submit
    global actionBinds, editingBindIndex
    
    if (EditBindHotkey = "") {
        MsgBox, 48, Ошибка, Введите горячую клавишу!
        return
    }
    
    ; Обновляем бинд
    actionBinds[editingBindIndex].hotkey := EditBindHotkey
    actionBinds[editingBindIndex].action := EditBindAction
    actionBinds[editingBindIndex].parameter := EditBindParameter
    
    ; Регистрируем новую горячую клавишу
    RegisterActionHotkey(EditBindHotkey, editingBindIndex)
    
    Gui, EditBindDialog:Destroy
    UpdateBindsList()
    SaveBinds()
    SB_SetText("Бинд обновлен", 1)
return

EditBindDialogCancel:
    Gui, EditBindDialog:Destroy
return

EditBindDialogGuiClose:
    Gui, EditBindDialog:Destroy
return

; Удалить бинд
DeleteBind:
    Gui, 1:Submit, NoHide
    Gui, ListView, BindsList
    
    selectedRow := LV_GetNext(0)
    if (selectedRow = 0) {
        MsgBox, 48, Ошибка, Выберите бинд для удаления!
        return
    }
    
    global actionBinds
    bind := actionBinds[selectedRow]
    bindHotkey := bind.hotkey
    
    MsgBox, 4, Подтверждение, Удалить бинд "%bindHotkey%"?
    IfMsgBox No
        return
    
    ; Удаляем горячую клавишу
    try {
        Hotkey, %bindHotkey%, Off
    }
    
    actionBinds.RemoveAt(selectedRow)
    UpdateBindsList()
    SaveBinds()
    SB_SetText("Бинд удален", 1)
return

; Включить/выключить бинд
ToggleBind:
    Gui, 1:Submit, NoHide
    Gui, ListView, BindsList
    
    selectedRow := LV_GetNext(0)
    if (selectedRow = 0) {
        MsgBox, 48, Ошибка, Выберите бинд для переключения!
        return
    }
    
    global actionBinds
    bind := actionBinds[selectedRow]
    bind.enabled := !bind.enabled
    bindHotkey := bind.hotkey
    
    ; Включаем/выключаем горячую клавишу
    if (bind.enabled) {
        try {
            Hotkey, %bindHotkey%, ExecuteBindActionByIndex, On
        } catch e {
            ; Игнорируем ошибку
        }
    } else {
        try {
            Hotkey, %bindHotkey%, Off
        } catch e {
            ; Игнорируем ошибку
        }
    }
    
    UpdateBindsList()
    SaveBinds()
    
    status := bind.enabled ? "включен" : "выключен"
    SB_SetText("Бинд " . status, 1)
return

; Очистить все бинды
ClearBinds:
    global actionBinds
    
    if (actionBinds.Length() = 0) {
        MsgBox, 48, Ошибка, Список биндов пуст!
        return
    }
    
    MsgBox, 4, Подтверждение, Удалить все бинды?
    IfMsgBox No
        return
    
    ; Удаляем все горячие клавиши
    for i, bind in actionBinds {
        bindHotkey := bind.hotkey
        try {
            Hotkey, %bindHotkey%, Off
        }
    }
    
    actionBinds := []
    UpdateBindsList()
    SaveBinds()
    SB_SetText("Все бинды удалены", 1)
return

; Тест бинда
TestBind:
    Gui, 1:Submit, NoHide
    Gui, ListView, BindsList
    
    selectedRow := LV_GetNext(0)
    if (selectedRow = 0) {
        MsgBox, 48, Ошибка, Выберите бинд для теста!
        return
    }
    
    global actionBinds
    bind := actionBinds[selectedRow]
    bindEnabled := bind.enabled
    bindAction := bind.action
    bindParameter := bind.parameter
    
    if (!bindEnabled) {
        MsgBox, 48, Ошибка, Бинд выключен! Включите его перед тестированием.
        return
    }
    
    MsgBox, 64, Тест бинда, Будет выполнено действие:`n`n"%bindAction%"`nПараметр: "%bindParameter%"`n`nНажмите OK для выполнения.
    
    ; Выполняем действие
    ExecuteBindAction(bindAction, bindParameter)
return

; Обработчик выбора бинда
BindSelected:
return

; Обновить список биндов
UpdateBindsList() {
    global actionBinds
    Gui, 1:Default
    Gui, ListView, BindsList
    GuiControl, -Redraw, BindsList
    LV_Delete()
    
    for i, bind in actionBinds {
        bindHotkey := bind.hotkey
        bindAction := bind.action
        bindParameter := bind.parameter
        bindEnabled := bind.enabled
        
        status := bindEnabled ? "Вкл" : "Выкл"
        param := bindParameter != "" ? bindParameter : "-"
        LV_Add("", bindHotkey, bindAction, param, status)
    }
    
    GuiControl, +Redraw, BindsList
}

; Сохранить бинды
SaveBinds() {
    global actionBinds
    
    IniDelete, %appDataDir%\AutoTyper.ini, Binds
    IniWrite, % actionBinds.Length(), %appDataDir%\AutoTyper.ini, Binds, Count
    
    for i, bind in actionBinds {
        section := "Bind" . i
        bindHotkey := bind.hotkey
        bindAction := bind.action
        bindParameter := bind.parameter
        bindEnabled := bind.enabled
        
        IniWrite, %bindHotkey%, %appDataDir%\AutoTyper.ini, %section%, Hotkey
        IniWrite, %bindAction%, %appDataDir%\AutoTyper.ini, %section%, Action
        IniWrite, %bindParameter%, %appDataDir%\AutoTyper.ini, %section%, Parameter
        IniWrite, %bindEnabled%, %appDataDir%\AutoTyper.ini, %section%, Enabled
    }
}

; Загрузить бинды
LoadBinds() {
    global actionBinds
    
    IniRead, bindCount, %appDataDir%\AutoTyper.ini, Binds, Count, 0
    
    actionBinds := []
    
    Loop, %bindCount% {
        section := "Bind" . A_Index
        IniRead, hotkey, %appDataDir%\AutoTyper.ini, %section%, Hotkey
        IniRead, action, %appDataDir%\AutoTyper.ini, %section%, Action
        IniRead, parameter, %appDataDir%\AutoTyper.ini, %section%, Parameter
        IniRead, enabled, %appDataDir%\AutoTyper.ini, %section%, Enabled, 1
        
        if (hotkey != "ERROR" && action != "ERROR") {
            actionBinds.Push({hotkey: hotkey, action: action, parameter: parameter, enabled: enabled})
            
            ; Регистрируем горячую клавишу
            if (enabled)
                RegisterActionHotkey(hotkey, A_Index)
        }
    }
    
    UpdateBindsList()
}

; Регистрировать горячую клавишу для действия
RegisterActionHotkey(hotkey, index) {
    ; Проверяем, не защищенная ли это клавиша
    if (hotkey = "!c" || hotkey = "Alt+C" || hotkey = "!x" || hotkey = "Alt+X" || hotkey = "!z" || hotkey = "Alt+Z" || hotkey = "!v" || hotkey = "Alt+V") {
        return ; Игнорируем защищенные клавиши
    }
    
    try {
        Hotkey, %hotkey%, ExecuteBindActionByIndex
    } catch e {
        ; Игнорируем ошибки регистрации (клавиша может быть уже занята)
    }
}

; Выполнить действие по индексу (вызывается горячей клавишей)
ExecuteBindActionByIndex:
    global actionBinds
    
    ; Находим бинд по горячей клавише
    hotkeyPressed := A_ThisHotkey
    
    for i, bind in actionBinds {
        bindHotkey := bind.hotkey
        bindEnabled := bind.enabled
        bindAction := bind.action
        bindParameter := bind.parameter
        
        if (bindHotkey = hotkeyPressed && bindEnabled) {
            ExecuteBindAction(bindAction, bindParameter)
            return
        }
    }
return

; Выполнить действие бинда
ExecuteBindAction(action, parameter) {
    if (action = "Старт печати") {
        Gosub, StartTyping
    }
    else if (action = "Стоп печати") {
        Gosub, StopTyping
    }
    else if (action = "Пауза печати") {
        Gosub, PauseTyping
    }
    else if (action = "Переключить режим на: Обычный текст") {
        GuiControl,, TypingMode, Обычный текст
        ; Моментально применяем изменение к глобальной переменной
        global TypingMode
        TypingMode := "Обычный текст"
    }
    else if (action = "Переключить режим на: Генератор текста") {
        GuiControl,, TypingMode, Генератор текста
        ; Моментально применяем изменение к глобальной переменной
        global TypingMode
        TypingMode := "Генератор текста"
    }
    else if (action = "Переключить режим на: По слотам") {
        GuiControl,, TypingMode, По слотам
        ; Моментально применяем изменение к глобальной переменной
        global TypingMode
        TypingMode := "По слотам"
    }
    else if (action = "Установить Auto-Enter макс. слов") {
        if (parameter != "") {
            GuiControl,, AutoEnterMode, 2
            GuiControl,, MaxWordsInput, %parameter%
            ; Моментально применяем изменения к глобальным переменным
            global AutoEnterMode, MaxWordsInput
            AutoEnterMode := 2
            MaxWordsInput := parameter
        }
    }
    else if (action = "Установить Auto-Enter время") {
        if (parameter != "") {
            GuiControl,, AutoEnterMode, 3
            GuiControl,, TimeInput, %parameter%
            ; Моментально применяем изменения к глобальным переменным
            global AutoEnterMode, TimeInput
            AutoEnterMode := 3
            TimeInput := parameter
        }
    }
    else if (action = "Отключить Auto-Enter") {
        GuiControl,, AutoEnterMode, 1
        ; Моментально применяем изменение к глобальной переменной
        global AutoEnterMode
        AutoEnterMode := 1
    }
    else if (action = "Изменить скорость") {
        if (parameter != "") {
            GuiControl,, SpeedInput, %parameter%
            ; Моментально применяем изменение к глобальной переменной
            global SpeedInput
            SpeedInput := parameter
        }
    }
    else if (action = "Сменить ускорение") {
        if (parameter != "") {
            GuiControl, ChooseString, SpeedMultiplier, %parameter%x
            ; Моментально применяем изменение к глобальной переменной
            global SpeedMultiplier
            SpeedMultiplier := parameter . "x"
        }
    }
    else if (action = "Установить регистр текста") {
        if (parameter != "") {
            GuiControl, ChooseString, TextCase, %parameter%
            ; Моментально применяем изменение к глобальной переменной
            global TextCase
            TextCase := parameter
        }
    }
    else if (action = "Установить уровень ошибок") {
        if (parameter != "") {
            GuiControl, ChooseString, ErrorLevelSetting, %parameter%
            ; Моментально применяем изменение к глобальной переменной
            global ErrorLevelSetting
            ErrorLevelSetting := parameter
        }
    }
    else if (action = "Генератор: по строкам") {
        GuiControl,, GenByLines, 1
        GuiControl,, GenByWords, 0
        ; Моментально применяем изменения к глобальным переменным
        global GenByLines, GenByWords, LinesCount
        GenByLines := 1
        GenByWords := 0
        Gosub, UpdateGenType
        if (parameter != "") {
            GuiControl,, LinesCount, %parameter%
            LinesCount := parameter
        }
    }
    else if (action = "Генератор: по словам") {
        GuiControl,, GenByLines, 0
        GuiControl,, GenByWords, 1
        ; Моментально применяем изменения к глобальным переменным
        global GenByLines, GenByWords, WordsCount
        GenByLines := 0
        GenByWords := 1
        Gosub, UpdateGenType
        if (parameter != "") {
            GuiControl,, WordsCount, %parameter%
            WordsCount := parameter
        }
    }
    else if (action = "Тестовая генерация") {
        Gosub, TestGeneration
    }
    else if (action = "Открыть конструктор") {
        GuiControl, Choose, SysTabControl321, 13
    }
    else if (action = "Сохранить настройки") {
        Gosub, GuiClose
    }
    else if (action = "Очистить текст") {
        GuiControl,, TypeText,
    }
}

; Управление (старт/стоп/пауза) перенесено в настраиваемые Hotkey() бинды.
; По умолчанию используются F8/F9/F10, но их можно изменить во вкладке "Бинды".
; F8::Gosub, StartTyping
; F9::Gosub, StopTyping
; F10::Gosub, PauseTyping

; Контекстное меню по Alt+C (убрано из статических горячих клавиш во избежание конфликтов)
ShowContextMenu:
    UpdateInsertsSubmenu()
    UpdateCustomContextMenu()
    Menu, ContextMenu, Show
return

; Обновить пользовательские действия в контекстном меню
UpdateCustomContextMenu() {
    global contextMenuActions
    
    ; Удаляем все пользовательские действия (они находятся перед "Закрыть")
    ; Сначала удалим старые пункты меню
    try {
        Loop {
            Menu, ContextMenu, Delete, CustomAction_%A_Index%
            if (ErrorLevel)
                break
        }
    }
    
    ; Находим позицию перед "Закрыть" и добавляем пользовательские действия
    if (contextMenuActions.Length() > 0) {
        ; Добавляем разделитель если его нет
        ; Добавляем пользовательские действия
        for index, actionObj in contextMenuActions {
            if (actionObj.enabled) {
                menuLabel := "CustomAction_" . index
                menuText := actionObj.name
                Menu, ContextMenu, Insert, ❌ Закрыть, %menuText%, ExecuteCustomContextAction
            }
        }
        ; Добавляем разделитель перед "Закрыть"
        Menu, ContextMenu, Insert, ❌ Закрыть
    }
}

; Выполнить пользовательское действие из контекстного меню
ExecuteCustomContextAction:
    global contextMenuActions
    menuText := A_ThisMenuItem
    
    ; Находим действие по названию
    for index, actionObj in contextMenuActions {
        if (actionObj.name = menuText && actionObj.enabled) {
            ExecuteContextMenuAction(actionObj.action, actionObj.parameter)
            return
        }
    }
return

; Выполнить действие контекстного меню
ExecuteContextMenuAction(action, parameter) {
    if (action = "Установить слова для генератора") {
        GuiControl, 1:, GenByLines, 0
        GuiControl, 1:, GenByWords, 1
        Gosub, UpdateGenType
        if (parameter != "")
            GuiControl, 1:, GenWordCount, %parameter%
        MsgBox, 64, Успех, Установлено: %parameter% слов
    }
    else if (action = "Установить строки для генератора") {
        GuiControl, 1:, GenByLines, 1
        GuiControl, 1:, GenByWords, 0
        Gosub, UpdateGenType
        if (parameter != "")
            GuiControl, 1:, GenLineCount, %parameter%
        MsgBox, 64, Успех, Установлено: %parameter% строк
    }
    else if (action = "Установить регистр") {
        if (parameter != "")
            GuiControl, 1:ChooseString, TextCase, %parameter%
        MsgBox, 64, Успех, Регистр: %parameter%
    }
    else if (action = "Установить уровень ошибок") {
        if (parameter != "")
            GuiControl, 1:ChooseString, ErrorLevelSetting, %parameter%
        MsgBox, 64, Успех, Уровень ошибок: %parameter%
    }
    else if (action = "Установить скорость") {
        if (parameter != "")
            GuiControl, 1:, SpeedInput, %parameter%
        MsgBox, 64, Успех, Скорость: %parameter% букв/сек
    }
    else if (action = "Переключить режим") {
        if (parameter != "")
            GuiControl, 1:ChooseString, TypingMode, %parameter%
        MsgBox, 64, Успех, Режим: %parameter%
    }
}

return

; Обновить подменю вставок
UpdateInsertsSubmenu() {
    global customInserts
    
    ; Очищаем меню (если оно существует)
    try {
        Menu, InsertsSubmenu, DeleteAll
    }
    
    if (customInserts.Length() = 0) {
        Menu, InsertsSubmenu, Add, (Нет вставок), DoNothing
        Menu, InsertsSubmenu, Disable, (Нет вставок)
        return
    }
    
    ; Добавляем каждую вставку
    for index, insertObj in customInserts {
        insertText := insertObj.text
        ; Обрезаем текст если слишком длинный
        if (StrLen(insertText) > 40)
            insertText := SubStr(insertText, 1, 40) . "..."
        
        ; Добавляем маркер состояния
        status := insertObj.enabled ? "✓" : "✗"
        menuText := status . " " . insertText
        
        ; Добавляем пункт меню
        Menu, InsertsSubmenu, Add, %menuText%, ToggleInsertFromMenu
    }
}

; Заглушка для пустого меню
DoNothing:
return

; Переключить вставку из меню
ToggleInsertFromMenu:
    global customInserts
    
    ; Получаем текст пункта меню
    menuItem := A_ThisMenuItem
    
    ; Ищем вставку по тексту (убираем маркер статуса)
    searchText := SubStr(menuItem, 3) ; Убираем "✓ " или "✗ "
    
    for index, insertObj in customInserts {
        insertText := insertObj.text
        if (StrLen(insertText) > 40)
            insertText := SubStr(insertText, 1, 40) . "..."
        
        if (insertText = searchText) {
            ; Открываем диалог управления вставкой
            global selectedInsertIndex := index
            Gosub, ShowInsertPositionDialog
            return
        }
    }
return

; Диалог выбора позиции вставки
ShowInsertPositionDialog:
    global customInserts, selectedInsertIndex
    
    insertObj := customInserts[selectedInsertIndex]
    currentPosition := insertObj.position
    currentEnabled := insertObj.enabled
    insertText := insertObj.text
    
    if (StrLen(insertText) > 30)
        insertText := SubStr(insertText, 1, 30) . "..."
    
    Gui, InsertPosDialog:New, -Resize, Управление вставкой
    Gui, InsertPosDialog:Font, s9, Segoe UI
    
    Gui, InsertPosDialog:Add, Text, x10 y10, Вставка:
    Gui, InsertPosDialog:Add, Edit, x10 y30 w360 h20 ReadOnly, %insertText%
    
    Gui, InsertPosDialog:Add, Text, x10 y60, Позиция:
    Gui, InsertPosDialog:Add, DropDownList, vInsertNewPosition x10 y80 w360, Случайно|Поочерёдно|В начале|В середине|В конце
    GuiControl, InsertPosDialog:ChooseString, InsertNewPosition, %currentPosition%
    
    Gui, InsertPosDialog:Add, Checkbox, vInsertNewEnabled x10 y120, Включить вставку
    GuiControl, InsertPosDialog:, InsertNewEnabled, %currentEnabled%
    
    Gui, InsertPosDialog:Add, Button, x10 y160 w175 h30 gInsertPosDialogOK, ✓ Сохранить
    Gui, InsertPosDialog:Add, Button, x195 y160 w175 h30 gInsertPosDialogCancel, ✗ Отмена
    
    Gui, InsertPosDialog:Show, w380 h200
return

InsertPosDialogOK:
    Gui, InsertPosDialog:Submit
    global customInserts, selectedInsertIndex
    
    customInserts[selectedInsertIndex].position := InsertNewPosition
    customInserts[selectedInsertIndex].enabled := InsertNewEnabled
    
    SaveInserts()
    UpdateInsertsList()
    
    Gui, InsertPosDialog:Destroy
    Gui, 1:Default
    
    MsgBox, 64, Успех, Настройки вставки сохранены!`nПозиция: %InsertNewPosition%
return

InsertPosDialogCancel:
InsertPosDialogGuiClose:
    Gui, InsertPosDialog:Destroy
    Gui, 1:Default
return

; Быстрое добавление/удаление слова в вставки (Alt+X)
!x::
    selectedText := GetSelectedText()
    
    if (selectedText = "") {
        MsgBox, 48, Ошибка, Не удалось получить выделенный текст!`n`nВыделите слово и нажмите Alt+X
        return
    }
    
    global customInserts, insertCount
    
    ; Проверяем, есть ли уже такая вставка
    found := false
    foundIndex := 0
    
    for index, insertObj in customInserts {
        if (insertObj.text = selectedText) {
            found := true
            foundIndex := index
            break
        }
    }
    
    if (found) {
        ; Удаляем вставку
        customInserts.RemoveAt(foundIndex)
        insertCount--
        SaveInserts()
        UpdateInsertsList()
        MsgBox, 64, Успех, Слово удалено из вставок!`n`n"%selectedText%"
    } else {
        ; Добавляем новую вставку
        insertObj := {}
        insertObj.text := selectedText
        insertObj.position := "Поочерёдно"
        insertObj.ignoreWords := ""
        insertObj.hotkey := ""
        insertObj.enabled := 1
        insertObj.applyErrors := 0
        insertObj.variations := []
        insertObj.variationStartPosition := "С начала"
        
        customInserts.Push(insertObj)
        insertCount++
        SaveInserts()
        UpdateInsertsList()
        MsgBox, 64, Успех, Слово добавлено в вставки!`n`n"%selectedText%"
    }
return

; Меню нейросети (Alt+Z): показывает контекстное меню с быстрыми действиями.
!z::
    Menu, NeuroMenu, Show
return

; Ответ нейросети на выделенный текст (Alt+V): берет выделение как промпт и печатает ответ в текущем окне.
!v::
    selectedText := GetSelectedText()
    if (selectedText = "") {
        MsgBox, 48, Ошибка, Не удалось получить выделенный текст!`n`nВыделите текст и нажмите Alt+V
        return
    }
    ; Делаем запрос и вставляем ответ максимально быстро (через буфер).
    NeuroRunQueryAndType(selectedText)
return

NeuroMenuOpenTab:
    global NeuroTabIndex
    Gui, 1:Show
    GuiControl, Choose, MainTabs, %NeuroTabIndex%
    UpdateMenuHighlight("MenuNeuro")
return

NeuroMenuOpenSettings:
    global NeuroTabIndex
    Gui, 1:Show
    GuiControl, Choose, MainTabs, %NeuroTabIndex%
    UpdateMenuHighlight("MenuNeuro")
    GuiControl, Focus, NeuroSystemPrompt
return

NeuroMenuAsk:
    InputBox, q, Нейросеть, Введите запрос для нейросети:, , 520, 160
    if (ErrorLevel || q = "")
        return
    NeuroRunQuery(q)
return

NeuroMenuAskClipboard:
    q := Clipboard
    q := Trim(q, "`r`n`t ")
    if (q = "") {
        MsgBox, 48, Ошибка, Буфер обмена пуст.
        return
    }
    NeuroRunQuery(q)
return

; === УПРАВЛЕНИЕ ПОЛЬЗОВАТЕЛЬСКИМИ ДЕЙСТВИЯМИ КОНТЕКСТНОГО МЕНЮ ===

; Добавить действие в контекстное меню
AddContextAction:
    Gui, ContextActionDialog:New, -Resize, Добавить действие
    Gui, ContextActionDialog:Font, s9, Segoe UI
    
    Gui, ContextActionDialog:Add, Text, x10 y10, Название (отображается в меню):
    Gui, ContextActionDialog:Add, Edit, vContextActionName x10 y30 w360
    
    Gui, ContextActionDialog:Add, Text, x10 y60, Действие:
    Gui, ContextActionDialog:Add, DropDownList, vContextActionType x10 y80 w360 gUpdateContextActionParams, Установить слова для генератора|Установить строки для генератора|Установить регистр|Установить уровень ошибок|Установить скорость|Переключить режим
    
    Gui, ContextActionDialog:Add, Text, vContextActionParamLabel x10 y110 hidden, Параметр:
    Gui, ContextActionDialog:Add, Edit, vContextActionParam x10 y130 w360 hidden
    Gui, ContextActionDialog:Add, Text, vContextActionParamHint x10 y160 w360 hidden cGray, Подсказка
    
    Gui, ContextActionDialog:Add, Button, x10 y190 w175 h30 gContextActionDialogOK, ✓ Добавить
    Gui, ContextActionDialog:Add, Button, x195 y190 w175 h30 gContextActionDialogCancel, ✗ Отмена
    
    Gui, ContextActionDialog:Show, w380 h230
return

UpdateContextActionParams:
    Gui, ContextActionDialog:Submit, NoHide
    
    ; Показываем поле параметра и подсказку
    GuiControl, ContextActionDialog:Show, ContextActionParamLabel
    GuiControl, ContextActionDialog:Show, ContextActionParam
    GuiControl, ContextActionDialog:Show, ContextActionParamHint
    
    if (ContextActionType = "Установить слова для генератора")
        GuiControl, ContextActionDialog:, ContextActionParamHint, Введите количество слов (например: 5)
    else if (ContextActionType = "Установить строки для генератора")
        GuiControl, ContextActionDialog:, ContextActionParamHint, Введите количество строк (например: 3)
    else if (ContextActionType = "Установить регистр")
        GuiControl, ContextActionDialog:, ContextActionParamHint, Введите: Обычный, ВЕРХНИЙ, нижний или Случайный
    else if (ContextActionType = "Установить уровень ошибок")
        GuiControl, ContextActionDialog:, ContextActionParamHint, Введите: Нет, Лёгкий, Средний, Высокий или Экстремальный
    else if (ContextActionType = "Установить скорость")
        GuiControl, ContextActionDialog:, ContextActionParamHint, Введите скорость (например: 20 для 20 букв/сек)
    else if (ContextActionType = "Переключить режим")
        GuiControl, ContextActionDialog:, ContextActionParamHint, Введите: Обычный текст, Генератор текста или По слотам
return

ContextActionDialogOK:
    Gui, ContextActionDialog:Submit
    global contextMenuActions
    
    if (ContextActionName = "") {
        MsgBox, 48, Ошибка, Введите название действия!
        return
    }
    
    if (ContextActionType = "") {
        MsgBox, 48, Ошибка, Выберите действие!
        return
    }
    
    ; Создаем объект действия
    actionObj := {}
    actionObj.name := ContextActionName
    actionObj.action := ContextActionType
    actionObj.parameter := ContextActionParam
    actionObj.enabled := 1
    
    contextMenuActions.Push(actionObj)
    UpdateContextMenuList()
    SaveContextActions()
    
    Gui, ContextActionDialog:Destroy
    Gui, 1:Default
    MsgBox, 64, Успех, Действие добавлено в контекстное меню!
return

ContextActionDialogCancel:
ContextActionDialogGuiClose:
    Gui, ContextActionDialog:Destroy
    Gui, 1:Default
return

; Выбор действия в списке
ContextMenuSelected:
return

; Редактировать действие
EditContextAction:
    MsgBox, 48, В разработке, Функция редактирования скоро будет добавлена!
return

; Удалить действие
DeleteContextAction:
    Gui, 1:Submit, NoHide
    Gui, ListView, ContextMenuList
    
    selectedRow := LV_GetNext(0)
    if (selectedRow = 0) {
        MsgBox, 48, Ошибка, Выберите действие для удаления!
        return
    }
    
    global contextMenuActions
    actionObj := contextMenuActions[selectedRow]
    actionName := actionObj.name
    
    MsgBox, 4, Подтверждение, Удалить действие "%actionName%"?
    IfMsgBox No
        return
    
    contextMenuActions.RemoveAt(selectedRow)
    UpdateContextMenuList()
    SaveContextActions()
    SB_SetText("Действие удалено", 1)
return

; Переключить действие
ToggleContextAction:
    Gui, 1:Submit, NoHide
    Gui, ListView, ContextMenuList
    
    selectedRow := LV_GetNext(0)
    if (selectedRow = 0) {
        MsgBox, 48, Ошибка, Выберите действие для переключения!
        return
    }
    
    global contextMenuActions
    contextMenuActions[selectedRow].enabled := !contextMenuActions[selectedRow].enabled
    
    UpdateContextMenuList()
    SaveContextActions()
    
    status := contextMenuActions[selectedRow].enabled ? "включено" : "выключено"
    SB_SetText("Действие " . status, 1)
return

; Очистить все действия
ClearContextActions:
    global contextMenuActions
    
    if (contextMenuActions.Length() = 0) {
        MsgBox, 48, Ошибка, Список действий пуст!
        return
    }
    
    MsgBox, 4, Подтверждение, Удалить все действия?
    IfMsgBox No
        return
    
    contextMenuActions := []
    UpdateContextMenuList()
    SaveContextActions()
    SB_SetText("Все действия удалены", 1)
return

; Обновить список действий
UpdateContextMenuList() {
    global contextMenuActions
    Gui, 1:Default
    Gui, ListView, ContextMenuList
    GuiControl, -Redraw, ContextMenuList
    LV_Delete()
    
    for i, actionObj in contextMenuActions {
        status := actionObj.enabled ? "Вкл" : "Выкл"
        param := actionObj.parameter != "" ? actionObj.parameter : "-"
        LV_Add("", actionObj.name, actionObj.action, param, status)
    }
    
    GuiControl, +Redraw, ContextMenuList
}

; Сохранить действия
SaveContextActions() {
    global contextMenuActions
    
    IniDelete, %appDataDir%\AutoTyper.ini, ContextActions
    IniWrite, % contextMenuActions.Length(), %appDataDir%\AutoTyper.ini, ContextActions, Count
    
    for i, actionObj in contextMenuActions {
        section := "ContextAction" . i
        actionName := actionObj.name
        actionType := actionObj.action
        actionParameter := actionObj.parameter
        actionEnabled := actionObj.enabled
        
        IniWrite, %actionName%, %appDataDir%\AutoTyper.ini, %section%, Name
        IniWrite, %actionType%, %appDataDir%\AutoTyper.ini, %section%, Action
        IniWrite, %actionParameter%, %appDataDir%\AutoTyper.ini, %section%, Parameter
        IniWrite, %actionEnabled%, %appDataDir%\AutoTyper.ini, %section%, Enabled
    }
}

; Загрузить действия
LoadContextActions() {
    global contextMenuActions
    
    IniRead, actionCount, %appDataDir%\AutoTyper.ini, ContextActions, Count, 0
    
    contextMenuActions := []
    
    Loop, %actionCount% {
        section := "ContextAction" . A_Index
        IniRead, name, %appDataDir%\AutoTyper.ini, %section%, Name
        IniRead, action, %appDataDir%\AutoTyper.ini, %section%, Action
        IniRead, parameter, %appDataDir%\AutoTyper.ini, %section%, Parameter
        IniRead, enabled, %appDataDir%\AutoTyper.ini, %section%, Enabled, 1
        
        if (name != "ERROR" && action != "ERROR") {
            contextMenuActions.Push({name: name, action: action, parameter: parameter, enabled: enabled})
        }
    }
    
    UpdateContextMenuList()
}

; ============================================
; === ИЗМЕНИТЕЛЬ БУКВ ===
; ============================================

; Открытие диалога изменителя букв
OpenLetterChanger:
    Gui, LetterChanger:Destroy
    Gui, LetterChanger:New, +Owner1, Изменитель букв
    Gui, LetterChanger:Font, s9, Segoe UI
    
    ; ListView для отображения замен
    Gui, LetterChanger:Add, GroupBox, x10 y10 w560 h300, Текущие замены
    Gui, LetterChanger:Add, ListView, vLetterReplacementsList x20 y30 w540 h240 Grid, Исходная буква|Замена на
    LV_ModifyCol(1, 270)
    LV_ModifyCol(2, 270)
    
    ; Кнопки управления заменами
    Gui, LetterChanger:Add, Button, x20 y275 w130 gAddLetterReplacement, ➕ Добавить
    Gui, LetterChanger:Add, Button, x160 y275 w130 gEditLetterReplacement, ✏️ Редактировать
    Gui, LetterChanger:Add, Button, x300 y275 w130 gDeleteLetterReplacement, ❌ Удалить
    Gui, LetterChanger:Add, Button, x440 y275 w120 gClearLetterReplacements, 🗑 Очистить все
    
    ; Управление пресетами
    Gui, LetterChanger:Add, GroupBox, x10 y320 w560 h100, Пресеты
    Gui, LetterChanger:Add, Text, x20 y340, Название пресета:
    Gui, LetterChanger:Add, DropDownList, vLetterPresetsList x140 y337 w300 gLoadLetterPresetAuto
    Gui, LetterChanger:Add, Button, x450 y337 w110 gRefreshLetterPresets, 🔄 Обновить
    
    Gui, LetterChanger:Add, Button, x20 y370 w170 gSaveLetterPreset, 💾 Сохранить пресет
    Gui, LetterChanger:Add, Button, x200 y370 w170 gLoadLetterPresetBtn, 📂 Загрузить пресет
    Gui, LetterChanger:Add, Button, x380 y370 w180 gDeleteLetterPreset, ❌ Удалить пресет
    
    ; Включение/выключение функции
    Gui, LetterChanger:Add, Checkbox, vLetterReplacementsEnabledCheck x20 y430, ✅ Включить замену букв
    GuiControl, LetterChanger:, LetterReplacementsEnabledCheck, %letterReplacementsEnabled%
    
    ; Кнопки закрытия
    Gui, LetterChanger:Add, Button, x200 y460 w170 gLetterChangerOK, OK
    Gui, LetterChanger:Add, Button, x380 y460 w190 gLetterChangerCancel, Отмена
    
    ; Загружаем текущие замены в ListView
    Gosub, RefreshLetterReplacementsList
    Gosub, RefreshLetterPresets
    
    Gui, LetterChanger:Show, w580 h500
return

; Обновление списка замен в ListView
RefreshLetterReplacementsList:
    Gui, LetterChanger:Default
    Gui, ListView, LetterReplacementsList
    LV_Delete()
    
    for original, replacement in letterReplacements {
        LV_Add("", original, replacement)
    }
return

; Добавление новой замены
AddLetterReplacement:
    InputBox, originalLetter, Добавить замену, Введите исходную букву или символ:, , 300, 130
    if (ErrorLevel || originalLetter = "")
        return
    
    InputBox, replacementLetter, Добавить замену, Введите замену для "%originalLetter%":, , 300, 130
    if (ErrorLevel)
        return
    
    letterReplacements[originalLetter] := replacementLetter
    Gosub, RefreshLetterReplacementsList
return

; Редактирование замены
EditLetterReplacement:
    Gui, LetterChanger:Default
    Gui, ListView, LetterReplacementsList
    selectedRow := LV_GetNext(0)
    if (!selectedRow) {
        MsgBox, 48, Ошибка, Выберите замену для редактирования!
        return
    }
    
    LV_GetText(originalLetter, selectedRow, 1)
    LV_GetText(currentReplacement, selectedRow, 2)
    
    InputBox, newReplacement, Редактировать замену, Новая замена для "%originalLetter%":, , 300, 130, , , , , %currentReplacement%
    if (ErrorLevel)
        return
    
    letterReplacements[originalLetter] := newReplacement
    Gosub, RefreshLetterReplacementsList
return

; Удаление замены
DeleteLetterReplacement:
    Gui, LetterChanger:Default
    Gui, ListView, LetterReplacementsList
    selectedRow := LV_GetNext(0)
    if (!selectedRow) {
        MsgBox, 48, Ошибка, Выберите замену для удаления!
        return
    }
    
    LV_GetText(originalLetter, selectedRow, 1)
    letterReplacements.Delete(originalLetter)
    Gosub, RefreshLetterReplacementsList
return

; Очистка всех замен
ClearLetterReplacements:
    MsgBox, 4, Подтверждение, Вы уверены, что хотите удалить все замены?
    IfMsgBox, Yes
    {
        letterReplacements := {}
        Gosub, RefreshLetterReplacementsList
    }
return

; Обновление списка пресетов
RefreshLetterPresets:
    Gui, LetterChanger:Default
    GuiControl,, LetterPresetsList, |
    
    Loop, Files, %letterReplacementsPresetsDir%\*.ini
    {
        SplitPath, A_LoopFileName, , , , nameNoExt
        GuiControl,, LetterPresetsList, %nameNoExt%
    }
return

; Сохранение пресета
SaveLetterPreset:
    InputBox, presetName, Сохранить пресет, Введите название пресета:, , 300, 130
    if (ErrorLevel || presetName = "")
        return
    
    ; Удаляем недопустимые символы из имени
    presetName := RegExReplace(presetName, "[\\/:*?""<>|]", "")
    
    if (presetName = "") {
        MsgBox, 48, Ошибка, Недопустимое имя пресета!
        return
    }
    
    presetFile := letterReplacementsPresetsDir . "\" . presetName . ".ini"
    
    ; Удаляем старый файл если существует
    FileDelete, %presetFile%
    
    ; Сохраняем замены
    for original, replacement in letterReplacements {
        IniWrite, %replacement%, %presetFile%, Replacements, %original%
    }
    
    MsgBox, 64, Успех, Пресет "%presetName%" сохранён!
    Gosub, RefreshLetterPresets
return

; Автоматическая загрузка пресета при выборе из списка
LoadLetterPresetAuto:
return

; Загрузка пресета по кнопке
LoadLetterPresetBtn:
    Gui, LetterChanger:Submit, NoHide
    
    if (LetterPresetsList = "") {
        MsgBox, 48, Ошибка, Выберите пресет для загрузки!
        return
    }
    
    presetFile := letterReplacementsPresetsDir . "\" . LetterPresetsList . ".ini"
    
    if (!FileExist(presetFile)) {
        MsgBox, 16, Ошибка, Файл пресета не найден!
        return
    }
    
    ; Очищаем текущие замены
    letterReplacements := {}
    
    ; Загружаем замены из файла
    IniRead, sectionContent, %presetFile%, Replacements
    
    if (sectionContent = "" || sectionContent = "ERROR") {
        MsgBox, 48, Предупреждение, Пресет пуст или повреждён!
        return
    }
    
    Loop, Parse, sectionContent, `n
    {
        if (A_LoopField = "")
            continue
        
        parts := StrSplit(A_LoopField, "=")
        if (parts.Length() >= 2) {
            original := parts[1]
            replacement := parts[2]
            letterReplacements[original] := replacement
        }
    }
    
    Gosub, RefreshLetterReplacementsList
    MsgBox, 64, Успех, Пресет "%LetterPresetsList%" загружен!
return

; Удаление пресета
DeleteLetterPreset:
    Gui, LetterChanger:Submit, NoHide
    
    if (LetterPresetsList = "") {
        MsgBox, 48, Ошибка, Выберите пресет для удаления!
        return
    }
    
    MsgBox, 4, Подтверждение, Вы уверены, что хотите удалить пресет "%LetterPresetsList%"?
    IfMsgBox, Yes
    {
        presetFile := letterReplacementsPresetsDir . "\" . LetterPresetsList . ".ini"
        FileDelete, %presetFile%
        Gosub, RefreshLetterPresets
        MsgBox, 64, Успех, Пресет удалён!
    }
return

; Закрытие диалога с сохранением
LetterChangerOK:
    Gui, LetterChanger:Submit
    letterReplacementsEnabled := LetterReplacementsEnabledCheck
    Gui, LetterChanger:Destroy
    
    ; Сохраняем настройки в основной INI
    SaveLetterReplacements()
return

; Закрытие диалога без сохранения
LetterChangerCancel:
    Gui, LetterChanger:Destroy
    ; Перезагружаем настройки из INI
    LoadLetterReplacements()
return

; ============================================
; === ОГРАНИЧЕНИЕ БУКВ ===
; ============================================

; Открытие диалога ограничения букв
OpenLetterRestriction:
    Gui, LetterRestriction:Destroy
    Gui, LetterRestriction:New, +Owner1, 🚫 Ограничение букв
    Gui, LetterRestriction:Font, s9 Bold, Segoe UI
    
    ; Инструкция
    Gui, LetterRestriction:Add, GroupBox, x10 y10 w780 h60, 💡 Инструкция
    Gui, LetterRestriction:Font, s9 Normal, Segoe UI
    Gui, LetterRestriction:Add, Text, x20 y30 w760, Нажмите на клавишу, чтобы запретить её печать (станет красной).
    Gui, LetterRestriction:Add, Text, x20 y50 w760, Нажмите снова, чтобы разрешить печать (станет зелёной).
    
    ; Экранная клавиатура - Цифры
    Gui, LetterRestriction:Font, s9 Bold, Segoe UI
    Gui, LetterRestriction:Add, GroupBox, x10 y80 w780 h60, Цифры и символы
    yPos := 100
    xPos := 20
    digitKeys := ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "="]
    for index, key in digitKeys {
        btnName := "KeyBtn_digit_" . index
        color := restrictedLetters[key] ? "Red" : "Green"
        Gui, LetterRestriction:Add, Progress, v%btnName%_bg x%xPos% y%yPos% w50 h30 Background%color% Disabled
        Gui, LetterRestriction:Add, Text, v%btnName% x%xPos% y%yPos% w50 h30 Center 0x200 BackgroundTrans gToggleKeyRestriction, %key%
        xPos += 55
    }
    
    ; Экранная клавиатура - Первый ряд (QWERTY)
    Gui, LetterRestriction:Add, GroupBox, x10 y150 w780 h60, Первый ряд (English)
    yPos := 170
    xPos := 20
    qwertyKeys := ["q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]"]
    for index, key in qwertyKeys {
        btnName := "KeyBtn_qwerty_" . index
        color := restrictedLetters[key] ? "Red" : "Green"
        Gui, LetterRestriction:Add, Progress, v%btnName%_bg x%xPos% y%yPos% w50 h30 Background%color% Disabled
        Gui, LetterRestriction:Add, Text, v%btnName% x%xPos% y%yPos% w50 h30 Center 0x200 BackgroundTrans gToggleKeyRestriction, %key%
        xPos += 55
    }
    
    ; Экранная клавиатура - Второй ряд (ASDF)
    Gui, LetterRestriction:Add, GroupBox, x10 y220 w780 h60, Второй ряд (English)
    yPos := 240
    xPos := 40
    asdfKeys := ["a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'"]
    for index, key in asdfKeys {
        btnName := "KeyBtn_asdf_" . index
        color := restrictedLetters[key] ? "Red" : "Green"
        Gui, LetterRestriction:Add, Progress, v%btnName%_bg x%xPos% y%yPos% w50 h30 Background%color% Disabled
        Gui, LetterRestriction:Add, Text, v%btnName% x%xPos% y%yPos% w50 h30 Center 0x200 BackgroundTrans gToggleKeyRestriction, %key%
        xPos += 55
    }
    
    ; Экранная клавиатура - Третий ряд (ZXCV)
    Gui, LetterRestriction:Add, GroupBox, x10 y290 w780 h60, Третий ряд (English)
    yPos := 310
    xPos := 70
    zxcvKeys := ["z", "x", "c", "v", "b", "n", "m", ",", ".", "/"]
    for index, key in zxcvKeys {
        btnName := "KeyBtn_zxcv_" . index
        color := restrictedLetters[key] ? "Red" : "Green"
        Gui, LetterRestriction:Add, Progress, v%btnName%_bg x%xPos% y%yPos% w50 h30 Background%color% Disabled
        Gui, LetterRestriction:Add, Text, v%btnName% x%xPos% y%yPos% w50 h30 Center 0x200 BackgroundTrans gToggleKeyRestriction, %key%
        xPos += 55
    }
    
    ; Русская клавиатура - Первый ряд (ЙЦУКЕН)
    Gui, LetterRestriction:Add, GroupBox, x10 y360 w780 h60, Русский - Первый ряд
    yPos := 380
    xPos := 20
    ruKeys1 := ["й", "ц", "у", "к", "е", "н", "г", "ш", "щ", "з", "х", "ъ"]
    for index, key in ruKeys1 {
        btnName := "KeyBtn_ru1_" . index
        color := restrictedLetters[key] ? "Red" : "Green"
        Gui, LetterRestriction:Add, Progress, v%btnName%_bg x%xPos% y%yPos% w50 h30 Background%color% Disabled
        Gui, LetterRestriction:Add, Text, v%btnName% x%xPos% y%yPos% w50 h30 Center 0x200 BackgroundTrans gToggleKeyRestriction, %key%
        xPos += 55
    }
    
    ; Русская клавиатура - Второй ряд (ФЫВАП)
    Gui, LetterRestriction:Add, GroupBox, x10 y430 w780 h60, Русский - Второй ряд
    yPos := 450
    xPos := 40
    ruKeys2 := ["ф", "ы", "в", "а", "п", "р", "о", "л", "д", "ж", "э"]
    for index, key in ruKeys2 {
        btnName := "KeyBtn_ru2_" . index
        color := restrictedLetters[key] ? "Red" : "Green"
        Gui, LetterRestriction:Add, Progress, v%btnName%_bg x%xPos% y%yPos% w50 h30 Background%color% Disabled
        Gui, LetterRestriction:Add, Text, v%btnName% x%xPos% y%yPos% w50 h30 Center 0x200 BackgroundTrans gToggleKeyRestriction, %key%
        xPos += 55
    }
    
    ; Русская клавиатура - Третий ряд (ЯЧСМ)
    Gui, LetterRestriction:Add, GroupBox, x10 y500 w780 h60, Русский - Третий ряд
    yPos := 520
    xPos := 70
    ruKeys3 := ["я", "ч", "с", "м", "и", "т", "ь", "б", "ю", "."]
    for index, key in ruKeys3 {
        btnName := "KeyBtn_ru3_" . index
        color := restrictedLetters[key] ? "Red" : "Green"
        Gui, LetterRestriction:Add, Progress, v%btnName%_bg x%xPos% y%yPos% w50 h30 Background%color% Disabled
        Gui, LetterRestriction:Add, Text, v%btnName% x%xPos% y%yPos% w50 h30 Center 0x200 BackgroundTrans gToggleKeyRestriction, %key%
        xPos += 55
    }
    
    ; Дополнительные символы и пробел
    Gui, LetterRestriction:Add, GroupBox, x10 y570 w780 h60, Дополнительно
    color := restrictedLetters[" "] ? "Red" : "Green"
    Gui, LetterRestriction:Add, Progress, vKeyBtn_space_bg x20 y590 w200 h30 Background%color% Disabled
    Gui, LetterRestriction:Add, Text, vKeyBtn_space x20 y590 w200 h30 Center 0x200 BackgroundTrans gToggleKeyRestriction, ПРОБЕЛ
    
    color := restrictedLetters["\"] ? "Red" : "Green"
    Gui, LetterRestriction:Add, Progress, vKeyBtn_backslash_bg x230 y590 w50 h30 Background%color% Disabled
    Gui, LetterRestriction:Add, Text, vKeyBtn_backslash x230 y590 w50 h30 Center 0x200 BackgroundTrans gToggleKeyRestriction, \
    
    color := restrictedLetters["``"] ? "Red" : "Green"
    Gui, LetterRestriction:Add, Progress, vKeyBtn_backtick_bg x290 y590 w50 h30 Background%color% Disabled
    Gui, LetterRestriction:Add, Text, vKeyBtn_backtick x290 y590 w50 h30 Center 0x200 BackgroundTrans gToggleKeyRestriction, ``
    
    ; Кнопки управления
    Gui, LetterRestriction:Font, s9 Normal, Segoe UI
    Gui, LetterRestriction:Add, Button, x350 y590 w150 h30 gRestrictionClearAll, 🗑 Очистить всё
    Gui, LetterRestriction:Add, Button, x510 y590 w130 h30 gRestrictionInvertAll, 🔄 Инвертировать
    Gui, LetterRestriction:Add, Button, x650 y590 w140 h30 gLetterRestrictionOK, ✅ Применить
    
    Gui, LetterRestriction:Show, w800 h640
return

; Переключение ограничения клавиши
ToggleKeyRestriction:
    ; Получаем текст кнопки
    GuiControlGet, btnText, LetterRestriction:, %A_GuiControl%
    
    ; Определяем клавишу
    key := btnText
    if (btnText = "ПРОБЕЛ")
        key := " "
    
    ; Переключаем статус
    if (restrictedLetters[key])
        restrictedLetters.Delete(key)
    else
        restrictedLetters[key] := 1
    
    ; Обновляем цвет фона (Progress элемента)
    bgControlName := A_GuiControl . "_bg"
    newColor := restrictedLetters[key] ? "Red" : "Green"
    GuiControl, LetterRestriction:+Background%newColor%, %bgControlName%
return

; Очистить все ограничения
RestrictionClearAll:
    restrictedLetters := {}
    Gui, LetterRestriction:Destroy
    Gosub, OpenLetterRestriction
return

; Инвертировать все ограничения
RestrictionInvertAll:
    allKeys := "1234567890-=qwertyuiop[]asdfghjkl;'zxcvbnm,./йцукенгшщзхъфывапролджэячсмитьбю. \``"
    Loop, Parse, allKeys
    {
        key := A_LoopField
        if (restrictedLetters[key])
            restrictedLetters.Delete(key)
        else
            restrictedLetters[key] := 1
    }
    Gui, LetterRestriction:Destroy
    Gosub, OpenLetterRestriction
return

; Применение ограничений
LetterRestrictionOK:
    SaveLetterRestrictions()
    Gui, LetterRestriction:Destroy
    MsgBox, 64, Успех, Ограничения букв применены!
return

; Применение замен букв к тексту
ApplyLetterReplacements(text) {
    global letterReplacements
    global letterReplacementsEnabled
    
    if (!letterReplacementsEnabled || letterReplacements.Count() = 0)
        return text
    
    result := text
    
    for original, replacement in letterReplacements {
        result := StrReplace(result, original, replacement)
    }
    
    return result
}

; Сохранение замен в INI
SaveLetterReplacements() {
    global letterReplacements
    global letterReplacementsEnabled
    global appDataDir
    
    iniFile := appDataDir . "\AutoTyper.ini"
    
    ; Удаляем старую секцию
    IniDelete, %iniFile%, LetterReplacements
    
    ; Сохраняем каждую замену
    for original, replacement in letterReplacements {
        IniWrite, %replacement%, %iniFile%, LetterReplacements, %original%
    }
    
    ; Сохраняем статус включения
    IniWrite, %letterReplacementsEnabled%, %iniFile%, LetterReplacements, Enabled
}

; Загрузка замен из INI
LoadLetterReplacements() {
    global letterReplacements
    global letterReplacementsEnabled
    global appDataDir
    
    iniFile := appDataDir . "\AutoTyper.ini"
    
    ; Загружаем статус включения
    IniRead, savedEnabled, %iniFile%, LetterReplacements, Enabled, 1
    letterReplacementsEnabled := savedEnabled
    
    ; Загружаем замены
    IniRead, sectionContent, %iniFile%, LetterReplacements
    
    if (sectionContent = "" || sectionContent = "ERROR")
        return
    
    letterReplacements := {}
    
    Loop, Parse, sectionContent, `n
    {
        if (A_LoopField = "" || InStr(A_LoopField, "Enabled="))
            continue
        
        parts := StrSplit(A_LoopField, "=")
        if (parts.Length() >= 2) {
            original := parts[1]
            replacement := parts[2]
            letterReplacements[original] := replacement
        }
    }
}

; ═══════════════════════════════════════════════════════════════════════════════
; === ОГРАНИЧЕНИЕ БУКВ - СОХРАНЕНИЕ И ЗАГРУЗКА ===
; ═══════════════════════════════════════════════════════════════════════════════

; Сохранение ограничений букв в INI
SaveLetterRestrictions() {
    global restrictedLetters
    global appDataDir
    
    iniFile := appDataDir . "\AutoTyper.ini"
    
    ; Удаляем старую секцию
    IniDelete, %iniFile%, LetterRestrictions
    
    ; Сохраняем каждую ограниченную букву
    restrictedList := ""
    for key, value in restrictedLetters {
        if (key = " ")
            restrictedList .= "[SPACE],"
        else if (key = "``")
            restrictedList .= "[BACKTICK],"
        else if (key = "\")
            restrictedList .= "[BACKSLASH],"
        else
            restrictedList .= key . ","
    }
    
    ; Убираем последнюю запятую
    restrictedList := RTrim(restrictedList, ",")
    
    IniWrite, %restrictedList%, %iniFile%, LetterRestrictions, RestrictedKeys
}

; Загрузка ограничений букв из INI
LoadLetterRestrictions() {
    global restrictedLetters
    global appDataDir
    
    iniFile := appDataDir . "\AutoTyper.ini"
    
    ; Загружаем список ограниченных букв
    IniRead, restrictedList, %iniFile%, LetterRestrictions, RestrictedKeys, 
    
    if (restrictedList = "" || restrictedList = "ERROR")
        return
    
    restrictedLetters := {}
    
    Loop, Parse, restrictedList, `,
    {
        key := A_LoopField
        if (key = "[SPACE]")
            restrictedLetters[" "] := 1
        else if (key = "[BACKTICK]")
            restrictedLetters["``"] := 1
        else if (key = "[BACKSLASH]")
            restrictedLetters["\"] := 1
        else if (key != "")
            restrictedLetters[key] := 1
    }
}

; Применение ограничений букв к тексту (удаление запрещённых символов)
ApplyLetterRestrictions(text) {
    global restrictedLetters
    
    if (restrictedLetters.Count() = 0)
        return text
    
    result := ""
    
    Loop, Parse, text
    {
        char := A_LoopField
        ; Если буква не ограничена, добавляем её
        if (!restrictedLetters[char])
            result .= char
    }
    
    return result
}

; ═══════════════════════════════════════════════════════════════════════════════
; ███████╗ НОВЫЙ ГЕНЕРАТОР ТЕКСТА - ФУНКЦИИ
; ═══════════════════════════════════════════════════════════════════════════════

; === ИНИЦИАЛИЗАЦИЯ ГЕНЕРАТОРА ===
InitializeGenerator() {
    global genTemplatesDir, genCategoriesFile
    
    ; Создаём папки если не существуют
    if (!FileExist(genTemplatesDir))
        FileCreateDir, %genTemplatesDir%
    
    ; Загружаем список категорий
    LoadGenCategories()
}

; === ЗАГРУЗКА КАТЕГОРИЙ ГЕНЕРАТОРА ===
LoadGenCategories() {
    global genTemplatesDir, genCategoriesFile, genNavigationLevel, genCurrentCategory, genCurrentSubcategory
    
    Gui, 1:Default
    Gui, ListView, GenTemplateList
    LV_Delete()
    
    if (genNavigationLevel = "categories") {
        ; Показываем категории
        GuiControl,, GenNavPath, 📁 Категории
        
        IniRead, categories, %genCategoriesFile%, Categories, List, 
        if (categories != "" && categories != "ERROR") {
            Loop, Parse, categories, |
            {
                if (A_LoopField != "")
                    LV_Add("", "📂 " . A_LoopField)
            }
        }
    }
    else if (genNavigationLevel = "subcategories") {
        ; Показываем подкатегории
        GuiControl,, GenNavPath, 📁 %genCurrentCategory%
        
        IniRead, subcategories, %genCategoriesFile%, Category_%genCurrentCategory%, Subcategories, 
        if (subcategories != "" && subcategories != "ERROR") {
            Loop, Parse, subcategories, |
            {
                if (A_LoopField != "")
                    LV_Add("", "📁 " . A_LoopField)
            }
        }
    }
    else if (genNavigationLevel = "templates") {
        ; Показываем шаблоны
        GuiControl,, GenNavPath, 📁 %genCurrentCategory% → %genCurrentSubcategory%
        
        templatePath := genTemplatesDir . "\" . genCurrentCategory . "\" . genCurrentSubcategory
        if (FileExist(templatePath)) {
            Loop, Files, %templatePath%\*.txt
            {
                name := RegExReplace(A_LoopFileName, "\.txt$")
                LV_Add("", "📄 " . name)
            }
        }
    }
    
    LV_ModifyCol(1, 400)
}

; === НАВИГАЦИЯ ПО КАТЕГОРИЯМ ===
GenNavOpen:
    Gui, 1:Default
    Gui, ListView, GenTemplateList
    
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0)
        return
    
    LV_GetText(selectedItem, focusedRow)
    ; Убираем иконку из названия
    selectedItem := RegExReplace(selectedItem, "^[📂📁📄]\s*", "")
    
    global genNavigationLevel, genCurrentCategory, genCurrentSubcategory, genCurrentTemplate, genTemplatesDir
    
    if (genNavigationLevel = "categories") {
        genCurrentCategory := selectedItem
        genNavigationLevel := "subcategories"
        LoadGenCategories()
    }
    else if (genNavigationLevel = "subcategories") {
        genCurrentSubcategory := selectedItem
        genNavigationLevel := "templates"
        LoadGenCategories()
    }
    else if (genNavigationLevel = "templates") {
        ; Загружаем шаблон
        genCurrentTemplate := selectedItem
        templatePath := genTemplatesDir . "\" . genCurrentCategory . "\" . genCurrentSubcategory . "\" . selectedItem . ".txt"
        
        if (FileExist(templatePath)) {
            FileRead, content, %templatePath%
            GuiControl,, GenTemplateContent, %content%
            SB_SetText("Шаблон загружен: " . selectedItem, 1)
        }
    }
return

GenNavBack:
    global genNavigationLevel, genCurrentCategory, genCurrentSubcategory
    
    if (genNavigationLevel = "templates") {
        genNavigationLevel := "subcategories"
        genCurrentSubcategory := ""
    }
    else if (genNavigationLevel = "subcategories") {
        genNavigationLevel := "categories"
        genCurrentCategory := ""
    }
    
    LoadGenCategories()
return

; === СОЗДАНИЕ КАТЕГОРИИ ГЕНЕРАТОРА ===
GenCreateCategory:
    global genCategoriesFile, genTemplatesDir
    
    InputBox, newCategory, Создать категорию, Введите имя категории:
    if (ErrorLevel || newCategory = "")
        return
    
    ; Добавляем в список
    IniRead, categories, %genCategoriesFile%, Categories, List, 
    if (categories = "" || categories = "ERROR")
        categories := newCategory
    else
        categories .= "|" . newCategory
    IniWrite, %categories%, %genCategoriesFile%, Categories, List
    
    ; Создаём папку
    categoryPath := genTemplatesDir . "\" . newCategory
    if (!FileExist(categoryPath))
        FileCreateDir, %categoryPath%
    
    LoadGenCategories()
    SB_SetText("Категория создана: " . newCategory, 1)
return

; === СОЗДАНИЕ ПОДКАТЕГОРИИ ГЕНЕРАТОРА ===
GenCreateSubcat:
    global genCategoriesFile, genNavigationLevel, genCurrentCategory, genTemplatesDir
    
    if (genNavigationLevel = "categories") {
        MsgBox, 48, Ошибка, Сначала откройте категорию!
        return
    }
    
    InputBox, newSubcat, Создать подкатегорию, Введите имя подкатегории:
    if (ErrorLevel || newSubcat = "")
        return
    
    ; Добавляем в список
    IniRead, subcategories, %genCategoriesFile%, Category_%genCurrentCategory%, Subcategories, 
    if (subcategories = "" || subcategories = "ERROR")
        subcategories := newSubcat
    else
        subcategories .= "|" . newSubcat
    IniWrite, %subcategories%, %genCategoriesFile%, Category_%genCurrentCategory%, Subcategories
    
    ; Создаём папку
    subcatPath := genTemplatesDir . "\" . genCurrentCategory . "\" . newSubcat
    if (!FileExist(subcatPath))
        FileCreateDir, %subcatPath%
    
    LoadGenCategories()
    SB_SetText("Подкатегория создана: " . newSubcat, 1)
return

; === СОЗДАНИЕ ШАБЛОНА ГЕНЕРАТОРА ===
GenCreateTemplate:
    global genNavigationLevel, genCurrentCategory, genCurrentSubcategory, genTemplatesDir
    
    if (genNavigationLevel != "templates") {
        MsgBox, 48, Ошибка, Сначала откройте подкатегорию!
        return
    }
    
    InputBox, newTemplate, Создать шаблон, Введите имя шаблона:
    if (ErrorLevel || newTemplate = "")
        return
    
    templatePath := genTemplatesDir . "\" . genCurrentCategory . "\" . genCurrentSubcategory . "\" . newTemplate . ".txt"
    
    if (FileExist(templatePath)) {
        MsgBox, 48, Ошибка, Шаблон с таким именем уже существует!
        return
    }
    
    ; Создаём пустой файл
    FileAppend, , %templatePath%, UTF-8
    
    LoadGenCategories()
    SB_SetText("Шаблон создан: " . newTemplate, 1)
return

; === УДАЛЕНИЕ ЭЛЕМЕНТА ===
GenDeleteItem:
    global genNavigationLevel, genCurrentCategory, genCurrentSubcategory, genTemplatesDir, genCategoriesFile
    
    Gui, 1:Default
    Gui, ListView, GenTemplateList
    
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0) {
        MsgBox, 48, Ошибка, Выберите элемент для удаления!
        return
    }
    
    LV_GetText(selectedItem, focusedRow)
    selectedItem := RegExReplace(selectedItem, "^[📂📁📄]\s*", "")
    
    MsgBox, 4, Подтверждение, Удалить "%selectedItem%"?
    IfMsgBox, No
        return
    
    if (genNavigationLevel = "categories") {
        ; Удаляем категорию
        IniRead, categories, %genCategoriesFile%, Categories, List, 
        categories := RegExReplace(categories, "\Q" . selectedItem . "\E\|?", "")
        categories := RegExReplace(categories, "\|$", "")
        IniWrite, %categories%, %genCategoriesFile%, Categories, List
        IniDelete, %genCategoriesFile%, Category_%selectedItem%
        
        categoryPath := genTemplatesDir . "\" . selectedItem
        FileRemoveDir, %categoryPath%, 1
    }
    else if (genNavigationLevel = "subcategories") {
        ; Удаляем подкатегорию
        IniRead, subcategories, %genCategoriesFile%, Category_%genCurrentCategory%, Subcategories, 
        subcategories := RegExReplace(subcategories, "\Q" . selectedItem . "\E\|?", "")
        subcategories := RegExReplace(subcategories, "\|$", "")
        IniWrite, %subcategories%, %genCategoriesFile%, Category_%genCurrentCategory%, Subcategories
        
        subcatPath := genTemplatesDir . "\" . genCurrentCategory . "\" . selectedItem
        FileRemoveDir, %subcatPath%, 1
    }
    else if (genNavigationLevel = "templates") {
        ; Удаляем шаблон
        templatePath := genTemplatesDir . "\" . genCurrentCategory . "\" . genCurrentSubcategory . "\" . selectedItem . ".txt"
        FileDelete, %templatePath%
    }
    
    LoadGenCategories()
    SB_SetText("Удалено: " . selectedItem, 1)
return

; === ОБНОВЛЕНИЕ СПИСКА ===
GenRefreshList:
    LoadGenCategories()
    SB_SetText("Список обновлён", 1)
return

; === ПЕРЕМЕЩЕНИЕ ШАБЛОНА ===
GenMoveTemplate:
    global genNavigationLevel, genCurrentCategory, genCurrentSubcategory, genTemplatesDir, genCategoriesFile
    
    if (genNavigationLevel != "templates") {
        MsgBox, 48, Ошибка, Выберите шаблон для перемещения!
        return
    }
    
    Gui, 1:Default
    Gui, ListView, GenTemplateList
    
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0) {
        MsgBox, 48, Ошибка, Выберите шаблон!
        return
    }
    
    LV_GetText(templateName, focusedRow)
    templateName := RegExReplace(templateName, "^[📄]\s*", "")
    
    ; Создаём диалог выбора целевой подкатегории
    Gui, GenMoveDialog:New
    Gui, GenMoveDialog:Font, s9, Segoe UI
    Gui, GenMoveDialog:Add, Text, x10 y10, Переместить "%templateName%" в:
    Gui, GenMoveDialog:Add, ComboBox, vGenMoveTarget x10 y35 w300
    Gui, GenMoveDialog:Add, Button, x10 y70 w145 gGenMoveConfirm, ✓ Переместить
    Gui, GenMoveDialog:Add, Button, x165 y70 w145 gGenMoveCancel, ✗ Отмена
    
    ; Заполняем список подкатегорий
    IniRead, allCategories, %genCategoriesFile%, Categories, List, 
    Loop, Parse, allCategories, |
    {
        if (A_LoopField = "")
            continue
        category := A_LoopField
        IniRead, subcategories, %genCategoriesFile%, Category_%category%, Subcategories, 
        Loop, Parse, subcategories, |
        {
            if (A_LoopField != "") {
                targetPath := category . " → " . A_LoopField
                GuiControl, GenMoveDialog:, GenMoveTarget, %targetPath%
            }
        }
    }
    
    Gui, GenMoveDialog:Show, w320 h105, Переместить шаблон
return

GenMoveConfirm:
    Gui, GenMoveDialog:Submit, NoHide
    global genTemplatesDir, genCurrentCategory, genCurrentSubcategory
    
    if (GenMoveTarget = "") {
        MsgBox, 48, Ошибка, Выберите целевую подкатегорию!
        return
    }
    
    ; Парсим целевой путь
    parts := StrSplit(GenMoveTarget, " → ")
    targetCategory := parts[1]
    targetSubcategory := parts[2]
    
    ; Получаем имя шаблона
    Gui, 1:Default
    Gui, ListView, GenTemplateList
    focusedRow := LV_GetNext(0, "Focused")
    LV_GetText(templateName, focusedRow)
    templateName := RegExReplace(templateName, "^[📄]\s*", "")
    
    ; Перемещаем файл
    sourcePath := genTemplatesDir . "\" . genCurrentCategory . "\" . genCurrentSubcategory . "\" . templateName . ".txt"
    targetPath := genTemplatesDir . "\" . targetCategory . "\" . targetSubcategory . "\" . templateName . ".txt"
    
    FileMove, %sourcePath%, %targetPath%
    
    Gui, GenMoveDialog:Destroy
    Gui, 1:Default
    LoadGenCategories()
    SB_SetText("Шаблон перемещён", 1)
return

GenMoveCancel:
    Gui, GenMoveDialog:Destroy
    Gui, 1:Default
return

; === ПОКАЗАТЬ/СКРЫТЬ СОДЕРЖИМОЕ ШАБЛОНА ===
GenToggleContent:
    global genContentVisible
    
    genContentVisible := !genContentVisible
    
    if (genContentVisible) {
        GuiControl, Show, GenTemplateContent
        GuiControl,, GenShowContentBtn, 👁 Скрыть
    } else {
        GuiControl, Hide, GenTemplateContent
        GuiControl,, GenShowContentBtn, 👁 Показать
    }
return

; === ВЫБОР ШАБЛОНА В СПИСКЕ ===
GenTemplateSelected:
    global genNavigationLevel, genCurrentCategory, genCurrentSubcategory, genCurrentTemplate, genTemplatesDir
    
    if (A_GuiEvent != "Normal" && A_GuiEvent != "DoubleClick")
        return
    
    if (A_GuiEvent = "DoubleClick") {
        Gosub, GenNavOpen
        return
    }
    
    ; При одиночном клике тоже выбираем шаблон
    Gui, 1:Default
    Gui, ListView, GenTemplateList
    
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0)
        return
    
    LV_GetText(selectedItem, focusedRow)
    ; Убираем иконку из названия
    selectedItem := RegExReplace(selectedItem, "^[📂📁📄]\s*", "")
    
    ; Если мы на уровне шаблонов, загружаем выбранный шаблон
    if (genNavigationLevel = "templates") {
        genCurrentTemplate := selectedItem
        templatePath := genTemplatesDir . "\" . genCurrentCategory . "\" . genCurrentSubcategory . "\" . selectedItem . ".txt"
        
        if (FileExist(templatePath)) {
            FileRead, content, %templatePath%
            GuiControl,, GenTemplateContent, %content%
            SB_SetText("Шаблон выбран: " . selectedItem . " [" . genCurrentCategory . "/" . genCurrentSubcategory . "]", 1)
        } else {
            SB_SetText("Ошибка: файл шаблона не найден", 1)
        }
    }
return

; === РЕЖИМЫ ГЕНЕРАЦИИ ===
GenSetModeInfinite:
    global genGenerationMode
    genGenerationMode := "infinite"
    GuiControl,, GenModeLabel, Текущий режим: ∞ Бесконечность
    GuiControl, Choose, GenGenerationMode, По словам
    SB_SetText("Режим: Бесконечность", 1)
return

GenSetModeLines:
    global genGenerationMode
    genGenerationMode := "lines"
    GuiControl,, GenModeLabel, Текущий режим: 📄 По строкам
    GuiControl, Choose, GenGenerationMode, По строкам
    SB_SetText("Режим: По строкам", 1)
return

GenSetModeRandom:
    global genGenerationMode
    genGenerationMode := "random"
    GuiControl,, GenModeLabel, Текущий режим: 🎲 Случайный порядок
    SB_SetText("Режим: Случайный порядок", 1)
return

GenSetModeSingle:
    global genGenerationMode
    genGenerationMode := "single"
    GuiControl,, GenModeLabel, Текущий режим: 🎯 Случайная строка
    SB_SetText("Режим: Случайная строка", 1)
return

; === ЭФФЕКТЫ ГЕНЕРАЦИИ ===
GenUpdateEffect:
    Gui, 1:Submit, NoHide
    global genEffect
    
    if (GenEffectNormal) {
        genEffect := "normal"
        GuiControl,, GenEffectPreview, Превью: Обычный текст
    }
    else if (GenEffectExplosive) {
        genEffect := "explosive"
        GuiControl,, GenEffectPreview, Превью: П!Р!И!В!Е!Т!
    }
    else if (GenEffectWavy) {
        genEffect := "wavy"
        GuiControl,, GenEffectPreview, Превью: ПрИвЕт КаК дЕлА
    }
return

; === УРОВЕНЬ ОШИБОК ===
GenUpdateErrorLevel:
    Gui, 1:Submit, NoHide
    global genErrorLevel
    genErrorLevel := GenErrorLevel
    
    ; Обновляем превью
    if (genErrorLevel = "Нет") {
        GuiControl,, GenErrorPreview, Превью: Нормальный текст
    }
    else if (genErrorLevel = "Особенный") {
        GuiControl,, GenErrorPreview, Превью: атец, ти такой плахой
    }
    else if (genErrorLevel = "Лёгкий") {
        GuiControl,, GenErrorPreview, Превью: привте как длеа
    }
    else if (genErrorLevel = "Средний") {
        GuiControl,, GenErrorPreview, Превью: прветт кка деал
    }
    else if (genErrorLevel = "Высокий") {
        GuiControl,, GenErrorPreview, Превью: првиет ккаа дела
    }
    else if (genErrorLevel = "Экстремальный") {
        GuiControl,, GenErrorPreview, Превью: пррвиетт ккаак деелаа
    }
return

; === РЕЖИМ ГЕНЕРАЦИИ (ПО СЛОВАМ/ПО СТРОКАМ) ===
GenModeChanged:
    Gui, 1:Submit, NoHide
    global GenByWords, GenByLines, GenWordCount, GenLineCount
    
    ; Проверяем радио-боксы режима генерации
    if (GenModeLines) {
        ; Если выбран радио-бокс "По строкам", синхронизируем с выпадающим списком
        GuiControl, ChooseString, GenGenerationMode, По строкам
        GuiControl, Enable, GenGenerationMode
        GenByWords := 0
        GenByLines := 1
        GenLineCount := GenCountValue
    } else if (GenModeSingle || GenModeInfinite || GenModeRandom) {
        ; Если выбран другой режим (не "По строкам"), используем выпадающий список
        ; Проверяем выпадающий список (GenGenerationMode)
        if (GenGenerationMode = "По словам") {
            GenByWords := 1
            GenByLines := 0
            GenWordCount := GenCountValue
        } else if (GenGenerationMode = "По строкам") {
            GenByWords := 0
            GenByLines := 1
            GenLineCount := GenCountValue
        }
    }
return

; === ИГНОРИРУЕМЫЕ СЛОВА ===
GenAddIgnored:
    Gui, 1:Submit, NoHide
    global ignoredWords
    
    if (GenIgnoredInput = "") {
        MsgBox, 48, Ошибка, Введите слово!
        return
    }
    
    ; Проверяем, нет ли уже такого слова
    for i, word in ignoredWords {
        if (word = GenIgnoredInput) {
            MsgBox, 48, Ошибка, Это слово уже в списке!
            return
        }
    }
    
    ignoredWords.Push(GenIgnoredInput)
    
    Gui, 1:Default
    Gui, ListView, GenIgnoredList
    LV_Add("", GenIgnoredInput)
    
    GuiControl,, GenIgnoredInput,
    SB_SetText("Слово добавлено в игнор: " . GenIgnoredInput, 1)
return

GenRemoveIgnored:
    Gui, 1:Default
    Gui, ListView, GenIgnoredList
    
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0) {
        MsgBox, 48, Ошибка, Выберите слово для удаления!
        return
    }
    
    LV_GetText(wordToRemove, focusedRow)
    
    global ignoredWords
    newList := []
    for i, word in ignoredWords {
        if (word != wordToRemove)
            newList.Push(word)
    }
    ignoredWords := newList
    
    LV_Delete(focusedRow)
    SB_SetText("Слово удалено из игнора", 1)
return

GenClearIgnored:
    MsgBox, 4, Подтверждение, Очистить весь список игнорируемых слов?
    IfMsgBox, No
        return
    
    global ignoredWords
    ignoredWords := []
    
    Gui, 1:Default
    Gui, ListView, GenIgnoredList
    LV_Delete()
    
    SB_SetText("Список игнорируемых слов очищен", 1)
return

; ═══════════════════════════════════════════════════════════════════════════════
; НОВАЯ ФУНКЦИЯ ГЕНЕРАЦИИ ТЕКСТА
; ═══════════════════════════════════════════════════════════════════════════════
GenerateTextNew() {
    global genCurrentTemplate, genTemplatesDir, genCurrentCategory, genCurrentSubcategory
    global genGenerationMode, genEffect, genErrorLevel, genUsedWords
    global ignoredWords, customWords
    global GenNoRepeat, GenCapitalize, GenPunctuation, GenAddPunctMarks, GenAutoCorrect, GenTranslit
    
    Gui, 1:Submit, NoHide
    
    ; Получаем режим и количество из GUI
    GuiControlGet, guiGenMode,, GenGenerationMode
    GuiControlGet, countValue,, GenCountValue
    
    if (countValue = "" || countValue < 1)
        countValue := 5
    
    ; Загружаем содержимое шаблона
    if (genCurrentTemplate = "") {
        return ""
    }
    
    templatePath := genTemplatesDir . "\" . genCurrentCategory . "\" . genCurrentSubcategory . "\" . genCurrentTemplate . ".txt"
    
    if (!FileExist(templatePath)) {
        return ""
    }
    
    FileRead, content, %templatePath%
    if (ErrorLevel || content = "") {
        return ""
    }
    
    ; Собираем все строки
    allLines := []
    Loop, Parse, content, `n, `r
    {
        line := Trim(A_LoopField)
        if (line != "")
            allLines.Push(line)
    }
    
    if (allLines.Length() = 0)
        return ""
    
    result := ""
    
    ; Определяем режим: из DropDownList или из кнопок
    useMode := ""
    if (guiGenMode = "По словам")
        useMode := "infinite"
    else if (guiGenMode = "По строкам")
        useMode := "lines"
    else
        useMode := genGenerationMode  ; Используем режим из кнопок
    
    ; Генерируем в зависимости от режима
    if (useMode = "single") {
        ; Случайная строка
        Random, idx, 1, % allLines.Length()
        result := allLines[idx]
    }
    else if (useMode = "lines") {
        ; По строкам - генерируем указанное количество случайных строк
        lineCount := countValue
        Loop, %lineCount% {
            Random, idx, 1, % allLines.Length()
            result .= (result != "" ? "`n" : "") . allLines[idx]
        }
    }
    else if (useMode = "random") {
        ; Случайный порядок - перемешиваем все строки
        tempArr := []
        for i, line in allLines
            tempArr.Push(line)
        
        ; Простое перемешивание Fisher-Yates
        Loop, % tempArr.Length() {
            Random, j, A_Index, % tempArr.Length()
            temp := tempArr[A_Index]
            tempArr[A_Index] := tempArr[j]
            tempArr[j] := temp
        }
        
        for i, line in tempArr {
            result .= (result != "" ? " " : "") . line
        }
    }
    else if (useMode = "infinite") {
        ; Бесконечность / По словам - генерируем указанное количество слов
        targetWords := countValue
        currentWords := 0
        
        while (currentWords < targetWords) {
            Random, idx, 1, % allLines.Length()
            line := allLines[idx]
            
            ; Разбиваем строку на слова
            lineWords := StrSplit(line, " ")
            for i, word in lineWords {
                if (currentWords >= targetWords)
                    break
                if (word != "") {
                    result .= (result != "" ? " " : "") . word
                    currentWords++
                }
            }
        }
    }
    else {
        ; Режим по умолчанию - случайная строка
        Random, idx, 1, % allLines.Length()
        result := allLines[idx]
    }
    
    ; Если результат пустой, возвращаем первую строку
    if (result = "" && allLines.Length() > 0)
        result := allLines[1]
    
    ; Фильтруем игнорируемые слова
    if (ignoredWords.Length() > 0)
        result := FilterIgnoredWordsFromText(result, ignoredWords)
    
    ; Применяем настройки
    if (GenNoRepeat)
        result := RemoveDuplicateWords(result)
    
    if (GenCapitalize)
        result := CapitalizeAllWords(result)
    
    if (GenPunctuation) {
        if (!RegExMatch(result, "[.!?]$"))
            result .= "."
    }
    
    if (GenAddPunctMarks)
        result := AddRandomPunctuation(result)
    
    if (GenAutoCorrect)
        result := AutoCorrectText(result)
    
    if (GenTranslit)
        result := Transliterate(result)
    
    ; Применяем эффекты
    if (genEffect != "normal")
        result := ApplyGenEffect(result, genEffect)
    
    ; Применяем ошибки
    if (genErrorLevel != "Нет")
        result := ApplyGenErrors(result, genErrorLevel)
    
    ; Добавляем custom-слова
    if (customWords.Length() > 0)
        result := InsertCustomWords(result, customWords)
    
    return result
}

; === ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ГЕНЕРАТОРА ===

; Фильтрация игнорируемых слов из текста
FilterIgnoredWordsFromText(text, ignoredList) {
    if (ignoredList.Length() = 0)
        return text
    
    words := StrSplit(text, " ")
    result := ""
    
    for i, word in words {
        isIgnored := false
        cleanWord := RegExReplace(word, "[^\w\sа-яА-ЯёЁ]", "")
        
        for j, ignored in ignoredList {
            if (cleanWord = ignored) {
                isIgnored := true
                break
            }
        }
        
        if (!isIgnored)
            result .= (result ? " " : "") . word
    }
    
    return result
}

; Удаление дубликатов слов
RemoveDuplicateWords(text) {
    words := StrSplit(text, " ")
    seen := {}
    result := ""
    
    for i, word in words {
        lowerWord := Format("{:L}", word)
        if (!seen.HasKey(lowerWord)) {
            seen[lowerWord] := true
            result .= (result ? " " : "") . word
        }
    }
    
    return result
}

; Заглавные буквы для всех слов
CapitalizeAllWords(text) {
    words := StrSplit(text, " ")
    result := ""
    
    for i, word in words {
        if (word != "") {
            StringUpper, upperWord, word
            result .= (result ? " " : "") . upperWord
        }
    }
    
    return result
}

; Добавление случайной пунктуации
AddRandomPunctuation(text) {
    words := StrSplit(text, " ")
    result := ""
    punctMarks := [",", "!", "?", ",", ","]
    
    for i, word in words {
        result .= (result ? " " : "") . word
        
        ; Случайно добавляем пунктуацию после некоторых слов
        Random, chance, 1, 10
        if (chance <= 2 && i < words.Length()) {
            Random, pIdx, 1, % punctMarks.Length()
            result .= punctMarks[pIdx]
        }
    }
    
    return result
}

; Автокоррекция текста
AutoCorrectText(text) {
    ; Убираем двойные пробелы
    text := RegExReplace(text, " +", " ")
    ; Убираем пробелы перед знаками препинания
    text := RegExReplace(text, " ([,\.!?])", "$1")
    ; Добавляем пробел после знаков препинания
    text := RegExReplace(text, "([,\.!?])(\w)", "$1 $2")
    ; Заглавная буква после точки
    text := RegExReplace(text, "(\. )(\w)", "$1" . Format("{:U}", "$2"))
    
    return Trim(text)
}

; Применение эффектов генерации
ApplyGenEffect(text, effect) {
    if (effect = "normal")
        return text
    
    if (effect = "explosive") {
        ; Взрывной эффект - добавляем ! между буквами
        result := ""
        Loop, Parse, text
        {
            if (A_LoopField = " ")
                result .= " "
            else
                result .= A_LoopField . "!"
        }
        ; Убираем последний !
        result := RegExReplace(result, "!$", "")
        return result
    }
    
    if (effect = "wavy") {
        ; Волнистый эффект - чередуем регистр
        result := ""
        upper := true
        Loop, Parse, text
        {
            if (A_LoopField = " ") {
                result .= " "
            } else {
                if (upper) {
                    StringUpper, char, A_LoopField
                } else {
                    StringLower, char, A_LoopField
                }
                result .= char
                upper := !upper
            }
        }
        return result
    }
    
    return text
}

; Применение ошибок генерации
ApplyGenErrors(text, errLevel) {
    if (errLevel = "Нет")
        return text
    
    ; Определяем интенсивность ошибок
    errorChance := 0
    if (errLevel = "Лёгкий")
        errorChance := 5
    else if (errLevel = "Средний")
        errorChance := 10
    else if (errLevel = "Высокий")
        errorChance := 20
    else if (errLevel = "Экстремальный")
        errorChance := 35
    
    result := ""
    Loop, Parse, text
    {
        char := A_LoopField
        
        Random, chance, 1, 100
        if (chance <= errorChance && char != " ") {
            ; Применяем случайную ошибку
            Random, errorType, 1, 4
            
            if (errorType = 1) {
                ; Дублирование буквы
                result .= char . char
            }
            else if (errorType = 2) {
                ; Пропуск буквы
                ; Ничего не добавляем
            }
            else if (errorType = 3) {
                ; Перестановка с соседней (добавляем после следующей)
                result .= char
            }
            else {
                ; Замена на соседнюю клавишу
                result .= GetNearbyKey(char)
            }
        } else {
            result .= char
        }
    }
    
    return result
}

; Получение соседней клавиши
GetNearbyKey(char) {
    ; Русская раскладка
    nearbyRu := {"й": "ц", "ц": "й", "у": "к", "к": "у", "е": "н", "н": "е"
        , "г": "ш", "ш": "г", "щ": "з", "з": "щ", "х": "ъ", "ъ": "х"
        , "ф": "ы", "ы": "ф", "в": "а", "а": "в", "п": "р", "р": "п"
        , "о": "л", "л": "о", "д": "ж", "ж": "д", "э": "ж"
        , "я": "ч", "ч": "я", "с": "м", "м": "с", "и": "т", "т": "и"
        , "ь": "б", "б": "ь", "ю": "б"}
    
    lowerChar := Format("{:L}", char)
    
    if (nearbyRu.HasKey(lowerChar)) {
        newChar := nearbyRu[lowerChar]
        ; Сохраняем регистр
        if (char != lowerChar) {
            StringUpper, newChar, newChar
        }
        return newChar
    }
    
    return char
}

; Вставка custom-слов с учётом позиции
InsertCustomWords(text, customWordsList) {
    if (customWordsList.Length() = 0)
        return text
    
    words := StrSplit(text, " ")
    
    for i, customItem in customWordsList {
        if (!customItem.enabled)
            continue
        
        customWord := customItem.word
        position := customItem.HasKey("position") ? customItem.position : "Любая"
        nearWord := customItem.HasKey("nearWord") ? customItem.nearWord : ""
        wordCase := customItem.HasKey("case") ? customItem.case : "Обычный"
        variations := customItem.HasKey("variations") ? customItem.variations : []
        
        ; Выбираем слово или его вариацию
        if (variations.Length() > 0) {
            Random, useVariation, 0, 1
            if (useVariation) {
                Random, varIdx, 1, % variations.Length()
                customWord := variations[varIdx]
            }
        }
        
        ; Применяем регистр
        if (wordCase = "ВЕРХНИЙ") {
            StringUpper, customWord, customWord
        }
        else if (wordCase = "нижний") {
            StringLower, customWord, customWord
        }
        else if (wordCase = "Случайный") {
            Random, caseType, 1, 3
            if (caseType = 1) {
                StringUpper, customWord, customWord
            } else if (caseType = 2) {
                StringLower, customWord, customWord
            }
        }
        
        ; Определяем позицию вставки
        insertPos := 0
        
        if (nearWord != "") {
            ; Ищем слово рядом с которым нужно вставить
            for j, word in words {
                cleanWord := RegExReplace(word, "[^\w\sа-яА-ЯёЁ]", "")
                if (cleanWord = nearWord) {
                    if (position = "До") {
                        insertPos := j
                    } else if (position = "После") {
                        insertPos := j + 1
                    } else {
                        Random, beforeAfter, 0, 1
                        insertPos := beforeAfter ? j : j + 1
                    }
                    break
                }
            }
        }
        
        ; Если не нашли целевое слово или позиция "Любая"
        if (insertPos = 0) {
            Random, insertPos, 1, % words.Length() + 1
        }
        
        ; Вставляем слово
        words.InsertAt(insertPos, customWord)
    }
    
    ; Собираем обратно
    result := ""
    for i, word in words {
        result .= (result ? " " : "") . word
    }
    
    return result
}

; Перемешивание массива
ShuffleArray(arr) {
    shuffled := []
    for i, item in arr {
        shuffled.Push(item)
    }
    
    Loop, % shuffled.Length() {
        Random, j, 1, % shuffled.Length()
        temp := shuffled[A_Index]
        shuffled[A_Index] := shuffled[j]
        shuffled[j] := temp
    }
    
    return shuffled
}

; ═══════════════════════════════════════════════════════════════════════════════
; ФУНКЦИИ ДЛЯ ДОП. НАСТРОЕК ГЕНЕРАТОРА (CUSTOM-СЛОВА)
; ═══════════════════════════════════════════════════════════════════════════════

; Добавление Custom-слова (расширенное)
AddCustomWord:
    Gui, 1:Submit, NoHide
    global customWords
    
    if (CustomWordInput = "") {
        MsgBox, 48, Ошибка, Введите слово!
        return
    }
    
    ; Создаём объект custom-слова
    newWord := {}
    newWord.word := CustomWordInput
    newWord.enabled := true
    newWord.position := CustomWordPosition != "" ? CustomWordPosition : "Любая"
    newWord.nearWord := CustomWordNear
    newWord.case := CustomWordCase != "" ? CustomWordCase : "Обычный"
    
    ; Парсим вариации
    newWord.variations := []
    if (CustomWordVariations != "") {
        Loop, Parse, CustomWordVariations, `,
        {
            variation := Trim(A_LoopField)
            if (variation != "")
                newWord.variations.Push(variation)
        }
    }
    
    newWord.errorVariations := []
    
    customWords.Push(newWord)
    
    ; Обновляем ListView
    UpdateCustomWordsListView()
    
    ; Очищаем поля
    GuiControl,, CustomWordInput,
    GuiControl,, CustomWordNear,
    GuiControl,, CustomWordVariations,
    
    UpdateCustomWordsStats()
    SB_SetText("Custom-слово добавлено: " . CustomWordInput, 1)
return

; Обновление ListView custom-слов
UpdateCustomWordsListView() {
    global customWords
    
    Gui, 1:Default
    Gui, ListView, CustomWordsList
    LV_Delete()
    
    for i, item in customWords {
        position := item.HasKey("position") ? item.position : "Любая"
        nearWord := item.HasKey("nearWord") ? item.nearWord : "-"
        variations := item.HasKey("variations") ? item.variations.Length() : 0
        wordCase := item.HasKey("case") ? item.case : "Обычный"
        status := item.enabled ? "✓ Вкл" : "✗ Выкл"
        
        LV_Add("", item.word, position, nearWord, variations, wordCase, status)
    }
}

; Обновление статистики
UpdateCustomWordsStats() {
    global customWords
    
    total := customWords.Length()
    active := 0
    withVariations := 0
    posBefore := 0
    posAfter := 0
    posAny := 0
    
    for i, item in customWords {
        if (item.enabled)
            active++
        if (item.HasKey("variations") && item.variations.Length() > 0)
            withVariations++
        
        pos := item.HasKey("position") ? item.position : "Любая"
        if (pos = "До")
            posBefore++
        else if (pos = "После")
            posAfter++
        else
            posAny++
    }
    
    statsText := "Всего слов: " . total . " | Активных: " . active . " | С вариациями: " . withVariations
    statsText .= "`nПозиции: До - " . posBefore . " | После - " . posAfter . " | Любая - " . posAny
    
    GuiControl,, CustomWordsStats, %statsText%
}

; Редактирование Custom-слова
EditCustomWord:
    Gui, 1:Default
    Gui, ListView, CustomWordsList
    
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0) {
        MsgBox, 48, Ошибка, Выберите слово для редактирования!
        return
    }
    
    global customWords
    item := customWords[focusedRow]
    
    ; Заполняем поля текущими значениями
    GuiControl,, CustomWordInput, % item.word
    GuiControl, ChooseString, CustomWordPosition, % item.HasKey("position") ? item.position : "Любая"
    GuiControl,, CustomWordNear, % item.HasKey("nearWord") ? item.nearWord : ""
    GuiControl, ChooseString, CustomWordCase, % item.HasKey("case") ? item.case : "Обычный"
    
    ; Вариации
    variations := ""
    if (item.HasKey("variations")) {
        for i, v in item.variations {
            variations .= (variations ? ", " : "") . v
        }
    }
    GuiControl,, CustomWordVariations, %variations%
    
    ; Удаляем старое слово
    customWords.RemoveAt(focusedRow)
    UpdateCustomWordsListView()
    
    SB_SetText("Редактирование: " . item.word . " - измените и нажмите Добавить", 1)
return

; Удаление Custom-слова
DeleteCustomWord:
    Gui, 1:Default
    Gui, ListView, CustomWordsList
    
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0) {
        MsgBox, 48, Ошибка, Выберите слово для удаления!
        return
    }
    
    global customWords
    LV_GetText(wordName, focusedRow, 1)
    
    customWords.RemoveAt(focusedRow)
    UpdateCustomWordsListView()
    UpdateCustomWordsStats()
    
    SB_SetText("Custom-слово удалено: " . wordName, 1)
return

; Включение/выключение Custom-слова
ToggleCustomWord:
    Gui, 1:Default
    Gui, ListView, CustomWordsList
    
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0) {
        MsgBox, 48, Ошибка, Выберите слово!
        return
    }
    
    global customWords
    customWords[focusedRow].enabled := !customWords[focusedRow].enabled
    
    UpdateCustomWordsListView()
    UpdateCustomWordsStats()
return

; Очистка всех Custom-слов
ClearCustomWords:
    MsgBox, 4, Подтверждение, Удалить все custom-слова?
    IfMsgBox, No
        return
    
    global customWords
    customWords := []
    
    UpdateCustomWordsListView()
    UpdateCustomWordsStats()
    
    SB_SetText("Все custom-слова удалены", 1)
return

SaveCustomWord:
    Gosub, AddCustomWord
return

ClearCustomWordForm:
    GuiControl,, CustomWordInput,
    GuiControl,, CustomWordNear,
    GuiControl,, CustomWordVariations,
    GuiControl, ChooseString, CustomWordPosition, Любая
    GuiControl, ChooseString, CustomWordCase, Обычный
    SB_SetText("Форма очищена", 1)
return

RefreshCustomWords:
    UpdateCustomWordsListView()
    UpdateCustomWordsStats()
    SB_SetText("Список обновлён", 1)
return

; Двойной клик по Custom-слову
CustomWordDoubleClick:
    if (A_GuiEvent = "DoubleClick") {
        Gosub, ToggleCustomWord
    }
return

; Сохранение вариаций ошибок для Custom-слова
SetCustomWordErrors:
    Gui, 1:Submit, NoHide
    Gui, 1:Default
    Gui, ListView, CustomWordsList
    
    focusedRow := LV_GetNext(0, "Focused")
    if (focusedRow = 0) {
        MsgBox, 48, Ошибка, Сначала выберите слово в списке!
        return
    }
    
    global customWords
    
    ; Парсим вариации ошибок
    errorVars := []
    if (CustomWordErrorVars != "") {
        Loop, Parse, CustomWordErrorVars, `,
        {
            variation := Trim(A_LoopField)
            if (variation != "")
                errorVars.Push(variation)
        }
    }
    
    customWords[focusedRow].errorVariations := errorVars
    
    SB_SetText("Вариации ошибок сохранены для: " . customWords[focusedRow].word, 1)
return

; Тест Custom-слов
TestCustomWords:
    Gui, 1:Submit, NoHide
    global customWords
    
    if (CustomWordTestInput = "") {
        MsgBox, 48, Ошибка, Введите тестовый текст!
        return
    }
    
    result := InsertCustomWords(CustomWordTestInput, customWords)
    GuiControl,, CustomWordTestOutput, %result%
return

; Экспорт Custom-слов в файл
ExportCustomWords:
    global customWords, appDataDir
    
    if (customWords.Length() = 0) {
        MsgBox, 48, Ошибка, Нет custom-слов для экспорта!
        return
    }
    
    FileSelectFile, exportPath, S, %appDataDir%\custom_words.txt, Сохранить custom-слова, Текстовые файлы (*.txt)
    if (exportPath = "")
        return
    
    ; Формируем содержимое
    content := ""
    for i, item in customWords {
        line := item.word . "|"
        line .= (item.HasKey("position") ? item.position : "Любая") . "|"
        line .= (item.HasKey("nearWord") ? item.nearWord : "") . "|"
        line .= (item.HasKey("case") ? item.case : "Обычный") . "|"
        line .= (item.enabled ? "1" : "0") . "|"
        
        ; Вариации
        if (item.HasKey("variations") && item.variations.Length() > 0) {
            for j, v in item.variations {
                line .= (j > 1 ? "," : "") . v
            }
        }
        
        content .= line . "`n"
    }
    
    FileDelete, %exportPath%
    FileAppend, %content%, %exportPath%, UTF-8
    
    MsgBox, 64, Успех, Custom-слова экспортированы в:`n%exportPath%
return

; Импорт Custom-слов из файла
ImportCustomWords:
    global customWords, appDataDir
    
    FileSelectFile, importPath, , %appDataDir%, Загрузить custom-слова, Текстовые файлы (*.txt)
    if (importPath = "")
        return
    
    FileRead, content, %importPath%
    if (ErrorLevel) {
        MsgBox, 16, Ошибка, Не удалось прочитать файл!
        return
    }
    
    importedCount := 0
    
    Loop, Parse, content, `n, `r
    {
        if (A_LoopField = "")
            continue
        
        parts := StrSplit(A_LoopField, "|")
        if (parts.Length() < 5)
            continue
        
        newWord := {}
        newWord.word := parts[1]
        newWord.position := parts[2]
        newWord.nearWord := parts[3]
        newWord.case := parts[4]
        newWord.enabled := parts[5] = "1"
        
        ; Вариации
        newWord.variations := []
        if (parts.Length() >= 6 && parts[6] != "") {
            Loop, Parse, % parts[6], `,
            {
                if (A_LoopField != "")
                    newWord.variations.Push(A_LoopField)
            }
        }
        
        newWord.errorVariations := []
        
        customWords.Push(newWord)
        importedCount++
    }
    
    UpdateCustomWordsListView()
    UpdateCustomWordsStats()
    
    MsgBox, 64, Успех, Импортировано custom-слов: %importedCount%
return

; Загрузка пресета Custom-слов
LoadCustomWordsPreset:
    global appDataDir
    
    presetsDir := appDataDir . "\custom_words_presets"
    if (!FileExist(presetsDir))
        FileCreateDir, %presetsDir%
    
    FileSelectFile, presetPath, , %presetsDir%, Загрузить пресет, Текстовые файлы (*.txt)
    if (presetPath = "")
        return
    
    ; Очищаем текущие слова
    global customWords
    customWords := []
    
    ; Импортируем из файла
    FileRead, content, %presetPath%
    if (ErrorLevel) {
        MsgBox, 16, Ошибка, Не удалось прочитать файл!
        return
    }
    
    Loop, Parse, content, `n, `r
    {
        if (A_LoopField = "")
            continue
        
        parts := StrSplit(A_LoopField, "|")
        if (parts.Length() < 5)
            continue
        
        newWord := {}
        newWord.word := parts[1]
        newWord.position := parts[2]
        newWord.nearWord := parts[3]
        newWord.case := parts[4]
        newWord.enabled := parts[5] = "1"
        newWord.variations := []
        newWord.errorVariations := []
        
        if (parts.Length() >= 6 && parts[6] != "") {
            Loop, Parse, % parts[6], `,
            {
                if (A_LoopField != "")
                    newWord.variations.Push(A_LoopField)
            }
        }
        
        customWords.Push(newWord)
    }
    
    UpdateCustomWordsListView()
    UpdateCustomWordsStats()
    
    SB_SetText("Пресет загружен", 1)
return

; Инициализация генератора при запуске
InitializeGenerator()

; ═══════════════════════════════════════════════════════════════════════════════
; ███████╗ LEGIT-РЕЖИМ - ЧЕЛОВЕЧЕСКАЯ ПЕЧАТЬ
; ═══════════════════════════════════════════════════════════════════════════════

; === ОБРАБОТЧИКИ GUI LEGIT-РЕЖИМА ===

LegitModeToggle:
    Gui, 1:Submit, NoHide
    global legitModeEnabled
    legitModeEnabled := LegitModeEnabled
    
    if (legitModeEnabled) {
        SB_SetText("Legit-режим ВКЛЮЧЕН", 1)
    } else {
        SB_SetText("Legit-режим выключен", 1)
    }
return

LegitWPMChanged:
    Gui, 1:Submit, NoHide
    global legitWPM
    legitWPM := LegitWPM
    GuiControl,, LegitWPMInput, %legitWPM%
    UpdateLegitWPMDescription(legitWPM)
return

LegitWPMInputChanged:
    Gui, 1:Submit, NoHide
    global legitWPM
    legitWPM := LegitWPMInput
    if (legitWPM < 10)
        legitWPM := 10
    if (legitWPM > 5000)
        legitWPM := 5000
    GuiControl,, LegitWPM, %legitWPM%
    UpdateLegitWPMDescription(legitWPM)
return

; === ОБРАБОТЧИКИ МНОЖИТЕЛЯ WPM ===
LegitWPMMultiplierChanged:
    Gui, 1:Submit, NoHide
    global legitWPMMultiplier
    ; Слайдер имеет диапазон 10-30, делим на 10 чтобы получить 1.0-3.0
    legitWPMMultiplier := LegitWPMMultiplier / 10
    GuiControl,, LegitWPMMultiplierInput, %legitWPMMultiplier%
return

LegitWPMMultiplierInputChanged:
    Gui, 1:Submit, NoHide
    global legitWPMMultiplier
    legitWPMMultiplier := LegitWPMMultiplierInput
    if (legitWPMMultiplier < 1.0)
        legitWPMMultiplier := 1.0
    if (legitWPMMultiplier > 3.0)
        legitWPMMultiplier := 3.0
    ; Обновляем слайдер (умножаем на 10)
    sliderVal := Round(legitWPMMultiplier * 10)
    GuiControl,, LegitWPMMultiplier, %sliderVal%
return

LegitMultiplier10:
    GuiControl,, LegitWPMMultiplier, 10
    GuiControl,, LegitWPMMultiplierInput, 1.0
    global legitWPMMultiplier := 1.0
return

LegitMultiplier12:
    GuiControl,, LegitWPMMultiplier, 12
    GuiControl,, LegitWPMMultiplierInput, 1.2
    global legitWPMMultiplier := 1.2
return

LegitMultiplier15:
    GuiControl,, LegitWPMMultiplier, 15
    GuiControl,, LegitWPMMultiplierInput, 1.5
    global legitWPMMultiplier := 1.5
return

LegitMultiplier20:
    GuiControl,, LegitWPMMultiplier, 20
    GuiControl,, LegitWPMMultiplierInput, 2.0
    global legitWPMMultiplier := 2.0
return

LegitMultiplier30:
    GuiControl,, LegitWPMMultiplier, 30
    GuiControl,, LegitWPMMultiplierInput, 3.0
    global legitWPMMultiplier := 3.0
return

UpdateLegitWPMDescription(wpm) {
    if (wpm < 40)
        desc := "Очень медленно (начинающий)"
    else if (wpm < 60)
        desc := "Медленно (новичок)"
    else if (wpm < 80)
        desc := "Средний уровень"
    else if (wpm < 120)
        desc := "Быстро (опытный)"
    else if (wpm < 200)
        desc := "Очень быстро (профессионал)"
    else if (wpm < 500)
        desc := "Экстремально быстро"
    else if (wpm < 1000)
        desc := "Сверхчеловеческая скорость"
    else
        desc := "INSANE MODE"
    
    GuiControl,, LegitWPMDesc, %wpm% WPM = %desc%
}

; === ПРЕСЕТЫ СКОРОСТИ ===
LegitPresetSlow:
    GuiControl,, LegitWPM, 40
    GuiControl,, LegitWPMInput, 40
    GuiControl,, LegitSpeedVariation, 25
    GuiControl,, LegitWordPause, 100
    UpdateLegitWPMDescription(40)
return

LegitPresetNormal:
    GuiControl,, LegitWPM, 80
    GuiControl,, LegitWPMInput, 80
    GuiControl,, LegitSpeedVariation, 15
    GuiControl,, LegitWordPause, 50
    UpdateLegitWPMDescription(80)
return

LegitPresetFast:
    GuiControl,, LegitWPM, 150
    GuiControl,, LegitWPMInput, 150
    GuiControl,, LegitSpeedVariation, 10
    GuiControl,, LegitWordPause, 30
    UpdateLegitWPMDescription(150)
return

LegitPresetPro:
    GuiControl,, LegitWPM, 300
    GuiControl,, LegitWPMInput, 300
    GuiControl,, LegitSpeedVariation, 5
    GuiControl,, LegitWordPause, 15
    UpdateLegitWPMDescription(300)
return

LegitPresetInsane:
    GuiControl,, LegitWPM, 2000
    GuiControl,, LegitWPMInput, 2000
    GuiControl,, LegitSpeedVariation, 3
    GuiControl,, LegitWordPause, 5
    UpdateLegitWPMDescription(2000)
return

; === ПРЕСЕТЫ РЕАЛИЗМА (Доп.Legit вкладка) ===
LegitPresetRobot:
    ; Робот - никаких человеческих особенностей
    GuiControl,, LegitHumanMistakes, 0
    GuiControl,, LegitDoublePress, 0
    GuiControl,, LegitMissedKey, 0
    GuiControl,, LegitKeyDistance, 0
    GuiControl,, LegitHandSwitch, 0
    GuiControl,, LegitFingerStrength, 0
    GuiControl,, LegitSentencePause, 0
    GuiControl,, LegitCommaPause, 0
    GuiControl,, LegitNewWordPause, 0
    GuiControl,, LegitNaturalVariation, 0
    GuiControl,, LegitRandomSpikes, 0
    GuiControl,, LegitProgressiveFatigue, 0
    GuiControl,, LegitConcentrationLoss, 0
    GuiControl,, LegitWarmup, 0
    GuiControl,, LegitEndRush, 0
    GuiControl,, LegitLongWordSlow, 0
    GuiControl,, LegitNeighborKeyError, 0
    GuiControl,, LegitSwapLetters, 0
return

LegitPresetBeginner:
    ; Новичок - много ошибок, медленно, много пауз
    GuiControl,, LegitHumanMistakes, 1
    GuiControl,, LegitFastErrorChance, 15
    GuiControl,, LegitDoublePress, 1
    GuiControl,, LegitDoublePressChance, 3
    GuiControl,, LegitMissedKey, 1
    GuiControl,, LegitMissedKeyChance, 2
    GuiControl,, LegitKeyDistance, 1
    GuiControl,, LegitHandSwitch, 1
    GuiControl,, LegitHandSwitchDelay, 40
    GuiControl,, LegitFingerStrength, 1
    GuiControl,, LegitSentencePause, 1
    GuiControl,, LegitSentencePauseMin, 300
    GuiControl,, LegitSentencePauseMax, 1000
    GuiControl,, LegitCommaPause, 1
    GuiControl,, LegitCommaPauseMs, 150
    GuiControl,, LegitNewWordPause, 1
    GuiControl,, LegitNewWordPauseMs, 50
    GuiControl,, LegitNaturalVariation, 1
    GuiControl,, LegitWaveAmplitude, 35
    GuiControl,, LegitRandomSpikes, 1
    GuiControl,, LegitProgressiveFatigue, 1
    GuiControl,, LegitFatiguePercent, 40
    GuiControl,, LegitConcentrationLoss, 1
    GuiControl,, LegitDistractionChance, 5
    GuiControl,, LegitWarmup, 1
    GuiControl,, LegitWarmupWords, 10
    GuiControl,, LegitLongWordSlow, 1
    GuiControl,, LegitLongWordThreshold, 6
    GuiControl,, LegitNeighborKeyError, 1
    GuiControl,, LegitNeighborKeyChance, 5
    GuiControl,, LegitSwapLetters, 1
    GuiControl,, LegitSwapLettersChance, 3
return

LegitPresetAverage:
    ; Средний пользователь
    GuiControl,, LegitHumanMistakes, 1
    GuiControl,, LegitFastErrorChance, 5
    GuiControl,, LegitDoublePress, 1
    GuiControl,, LegitDoublePressChance, 1
    GuiControl,, LegitMissedKey, 1
    GuiControl,, LegitMissedKeyChance, 1
    GuiControl,, LegitKeyDistance, 1
    GuiControl,, LegitHandSwitch, 1
    GuiControl,, LegitHandSwitchDelay, 20
    GuiControl,, LegitFingerStrength, 1
    GuiControl,, LegitSentencePause, 1
    GuiControl,, LegitSentencePauseMin, 100
    GuiControl,, LegitSentencePauseMax, 400
    GuiControl,, LegitCommaPause, 1
    GuiControl,, LegitCommaPauseMs, 50
    GuiControl,, LegitNewWordPause, 1
    GuiControl,, LegitNewWordPauseMs, 15
    GuiControl,, LegitNaturalVariation, 1
    GuiControl,, LegitWaveAmplitude, 20
    GuiControl,, LegitRandomSpikes, 1
    GuiControl,, LegitProgressiveFatigue, 1
    GuiControl,, LegitFatiguePercent, 15
    GuiControl,, LegitConcentrationLoss, 1
    GuiControl,, LegitDistractionChance, 2
    GuiControl,, LegitWarmup, 1
    GuiControl,, LegitWarmupWords, 5
    GuiControl,, LegitLongWordSlow, 1
    GuiControl,, LegitLongWordThreshold, 8
    GuiControl,, LegitNeighborKeyError, 1
    GuiControl,, LegitNeighborKeyChance, 2
    GuiControl,, LegitSwapLetters, 1
    GuiControl,, LegitSwapLettersChance, 1
return

LegitPresetProRealism:
    ; Профессионал - мало ошибок, быстро
    GuiControl,, LegitHumanMistakes, 1
    GuiControl,, LegitFastErrorChance, 2
    GuiControl,, LegitDoublePress, 0
    GuiControl,, LegitMissedKey, 0
    GuiControl,, LegitKeyDistance, 1
    GuiControl,, LegitHandSwitch, 1
    GuiControl,, LegitHandSwitchDelay, 10
    GuiControl,, LegitFingerStrength, 0
    GuiControl,, LegitSentencePause, 1
    GuiControl,, LegitSentencePauseMin, 50
    GuiControl,, LegitSentencePauseMax, 200
    GuiControl,, LegitCommaPause, 1
    GuiControl,, LegitCommaPauseMs, 25
    GuiControl,, LegitNewWordPause, 1
    GuiControl,, LegitNewWordPauseMs, 8
    GuiControl,, LegitNaturalVariation, 1
    GuiControl,, LegitWaveAmplitude, 10
    GuiControl,, LegitRandomSpikes, 0
    GuiControl,, LegitProgressiveFatigue, 0
    GuiControl,, LegitConcentrationLoss, 0
    GuiControl,, LegitWarmup, 1
    GuiControl,, LegitWarmupWords, 3
    GuiControl,, LegitEndRush, 1
    GuiControl,, LegitEndRushPercent, 15
    GuiControl,, LegitLongWordSlow, 0
    GuiControl,, LegitNeighborKeyError, 1
    GuiControl,, LegitNeighborKeyChance, 1
    GuiControl,, LegitSwapLetters, 0
return

LegitPresetUltra:
    ; Ультра реализм - все эффекты включены умеренно
    GuiControl,, LegitHumanMistakes, 1
    GuiControl,, LegitFastErrorChance, 8
    GuiControl,, LegitDoublePress, 1
    GuiControl,, LegitDoublePressChance, 2
    GuiControl,, LegitMissedKey, 1
    GuiControl,, LegitMissedKeyChance, 1
    GuiControl,, LegitKeyDistance, 1
    GuiControl,, LegitHandSwitch, 1
    GuiControl,, LegitHandSwitchDelay, 25
    GuiControl,, LegitFingerStrength, 1
    GuiControl,, LegitSentencePause, 1
    GuiControl,, LegitSentencePauseMin, 150
    GuiControl,, LegitSentencePauseMax, 600
    GuiControl,, LegitCommaPause, 1
    GuiControl,, LegitCommaPauseMs, 80
    GuiControl,, LegitNewWordPause, 1
    GuiControl,, LegitNewWordPauseMs, 25
    GuiControl,, LegitNaturalVariation, 1
    GuiControl,, LegitWaveAmplitude, 25
    GuiControl,, LegitWavePeriod, 25
    GuiControl,, LegitRandomSpikes, 1
    GuiControl,, LegitProgressiveFatigue, 1
    GuiControl,, LegitFatiguePercent, 25
    GuiControl,, LegitConcentrationLoss, 1
    GuiControl,, LegitDistractionChance, 3
    GuiControl,, LegitCapsLockDelay, 1
    GuiControl,, LegitCapsLockMs, 35
    GuiControl,, LegitNumberRowDelay, 1
    GuiControl,, LegitNumberRowMs, 30
    GuiControl,, LegitSpecialCharDelay, 1
    GuiControl,, LegitSpecialCharMs, 45
    GuiControl,, LegitWarmup, 1
    GuiControl,, LegitWarmupWords, 7
    GuiControl,, LegitEndRush, 1
    GuiControl,, LegitEndRushPercent, 10
    GuiControl,, LegitLongWordSlow, 1
    GuiControl,, LegitLongWordThreshold, 7
    GuiControl,, LegitNeighborKeyError, 1
    GuiControl,, LegitNeighborKeyChance, 3
    GuiControl,, LegitSwapLetters, 1
    GuiControl,, LegitSwapLettersChance, 2
return

; === ТЕСТ LEGIT-РЕЖИМА ===
LegitTestType:
    Gui, 1:Submit, NoHide
    global legitWPM, legitSpeedVariation, legitWordPause
    global legitThinkingEnabled, legitThinkingFreq, legitThinkingMin, legitThinkingMax
    global legitTyposEnabled, legitTypoFreq, legitAutoCorrect
    global legitRhythm, legitCharDifficulty, legitBurstMode, legitFatigue
    global legitCapsDelay, legitPunctDelay
    
    testText := LegitTestInput
    if (testText = "") {
        MsgBox, 48, Ошибка, Введите тестовый текст!
        return
    }
    
    ; Обновляем настройки из GUI
    legitWPM := LegitWPMInput > 0 ? LegitWPMInput : 80
    legitSpeedVariation := LegitSpeedVariation
    legitWordPause := LegitWordPauseInput > 0 ? LegitWordPauseInput : 50
    legitThinkingEnabled := LegitThinkingEnabled
    legitThinkingFreq := LegitThinkingFreq > 0 ? LegitThinkingFreq : 15
    legitThinkingMin := LegitThinkingMin > 0 ? LegitThinkingMin : 200
    legitThinkingMax := LegitThinkingMax > 0 ? LegitThinkingMax : 800
    legitTyposEnabled := LegitTyposEnabled
    legitTypoFreq := LegitTypoFreq
    legitAutoCorrect := LegitAutoCorrect
    legitRhythm := LegitRhythm
    legitCharDifficulty := LegitCharDifficulty
    legitBurstMode := LegitBurstMode
    legitFatigue := LegitFatigue
    legitCapsDelay := LegitCapsDelay
    legitPunctDelay := LegitPunctDelay
    
    ; Рассчитываем статистику
    charCount := StrLen(testText)
    wordCount := 0
    Loop, Parse, testText, %A_Space%
    {
        if (A_LoopField != "")
            wordCount++
    }
    
    ; Рассчитываем примерное время
    avgCharsPerWord := 5
    charsPerMinute := legitWPM * avgCharsPerWord
    charsPerSecond := charsPerMinute / 60
    baseDelayMs := 1000 / charsPerSecond
    
    estimatedTime := (charCount * baseDelayMs) / 1000
    estimatedTime += (wordCount * legitWordPause) / 1000
    
    statsText := "Символов: " . charCount . " | Слов: " . wordCount . " | Примерное время: " . Round(estimatedTime, 1) . " сек | Задержка/символ: " . Round(baseDelayMs, 1) . " мс"
    GuiControl,, LegitTestStats, %statsText%
    
    ; Запускаем тестовую печать
    Sleep, 500
    LegitTypeTextFull(testText)
return

; === ФУНКЦИЯ LEGIT-ПЕЧАТИ С ТОЧНЫМ WPM ===
LegitTypeTextFull(text) {
    global isTyping, burstWords
    global stealthBlockReason
    
    Gui, 1:Submit, NoHide

    text := ApplyStealthMode(text, "Legit")
    if (text = "") {
        SB_SetText("Stealth: отправка отменена (" . stealthBlockReason . ")", 3)
        return false
    }
    pauseList := []
    text := EncodeSpecialPausesForLegit(text, pauseList)
    text := ApplyFinalTextStyle(text)
    pauseIdx := 1
    
    ; === ПОЛУЧАЕМ НАСТРОЙКИ ИЗ GUI ===
    GuiControlGet, wpmValue,, LegitWPMInput
    GuiControlGet, wpmMultiplier,, LegitWPMMultiplierInput
    GuiControlGet, speedVar,, LegitSpeedVarInput
    GuiControlGet, minDelayVal,, LegitMinDelay
    GuiControlGet, maxDelayVal,, LegitMaxDelay
    GuiControlGet, accelEnabled,, LegitAccelEnabled
    GuiControlGet, accelStartWPM,, LegitAccelStartWPM
    GuiControlGet, accelEndWPM,, LegitAccelEndWPM
    GuiControlGet, accelTime,, LegitAccelTime
    GuiControlGet, randomDelayEnabled,, LegitRandomDelay
    GuiControlGet, randomDelayMin,, LegitRandomDelayMin
    GuiControlGet, randomDelayMax,, LegitRandomDelayMax
    GuiControlGet, adaptiveDelay,, LegitAdaptiveDelay
    GuiControlGet, wordPauseEnabled,, LegitWordPauseEnabled
    GuiControlGet, wordPauseVal,, LegitWordPauseInput
    GuiControlGet, wordPauseUnit,, LegitWordPauseUnit
    GuiControlGet, wordPauseMin,, LegitWordPauseMin
    GuiControlGet, wordPauseMax,, LegitWordPauseMax
    GuiControlGet, wordPauseRandom,, LegitWordPauseRandom
    GuiControlGet, thinkEnabled,, LegitThinkingEnabled
    GuiControlGet, thinkFreq,, LegitThinkingFreq
    GuiControlGet, thinkMin,, LegitThinkingMin
    GuiControlGet, thinkMax,, LegitThinkingMax
    GuiControlGet, thinkUnit,, LegitThinkingUnit
    GuiControlGet, thinkChance,, LegitThinkingChance
    GuiControlGet, pauseEnabled,, LegitPauseEnabled
    GuiControlGet, pauseDuration,, LegitPauseDuration
    GuiControlGet, pauseUnit,, LegitPauseUnit
    GuiControlGet, pauseCount,, LegitPauseCount
    GuiControlGet, pauseInterval,, LegitPauseInterval
    GuiControlGet, rhythmVal,, LegitRhythm
    GuiControlGet, rhythmIntensity,, LegitRhythmIntInput
    GuiControlGet, typosEnabled,, LegitTyposEnabled
    GuiControlGet, typoFreqVal,, LegitTypoFreqInput
    GuiControlGet, autoCorrectVal,, LegitAutoCorrect
    GuiControlGet, burstVal,, LegitBurstMode
    GuiControlGet, fatigueVal,, LegitFatigue
    GuiControlGet, charDiffVal,, LegitCharDifficulty
    GuiControlGet, capsDelayVal,, LegitCapsDelay
    GuiControlGet, punctDelayVal,, LegitPunctDelay
    
    ; === ЗНАЧЕНИЯ ПО УМОЛЧАНИЮ ===
    if (wpmValue = "" || wpmValue < 1)
        wpmValue := 80
    if (wpmMultiplier = "" || wpmMultiplier < 1)
        wpmMultiplier := 1.0
    if (speedVar = "")
        speedVar := 0
    if (minDelayVal = "")
        minDelayVal := 0
    if (maxDelayVal = "")
        maxDelayVal := 0
    if (accelStartWPM = "" || accelStartWPM < 1)
        accelStartWPM := 40
    if (accelEndWPM = "" || accelEndWPM < 1)
        accelEndWPM := 120
    if (accelTime = "" || accelTime < 1)
        accelTime := 5
    if (randomDelayMin = "")
        randomDelayMin := 20
    if (randomDelayMax = "")
        randomDelayMax := 150
    if (wordPauseVal = "")
        wordPauseVal := 0
    if (wordPauseMin = "")
        wordPauseMin := 30
    if (wordPauseMax = "")
        wordPauseMax := 100
    if (thinkFreq = "" || thinkFreq < 1)
        thinkFreq := 15
    if (thinkMin = "")
        thinkMin := 200
    if (thinkMax = "")
        thinkMax := 800
    if (thinkChance = "")
        thinkChance := 100
    if (pauseDuration = "")
        pauseDuration := 500
    if (pauseCount = "")
        pauseCount := 3
    if (pauseInterval = "")
        pauseInterval := 50
    if (rhythmIntensity = "")
        rhythmIntensity := 30
    if (typoFreqVal = "")
        typoFreqVal := 3
    
    ; ═══════════════════════════════════════════════════════════════════════════
    ; ТОЧНЫЙ РАСЧЁТ WPM (Words Per Minute)
    ; ═══════════════════════════════════════════════════════════════════════════
    ; WPM = количество слов в минуту
    ; Стандарт: 1 слово = 5 символов (включая пробел)
    ; 
    ; Формула: задержка_мс = 60000 / (WPM * 5)
    ;
    ; Примеры:
    ;   1 WPM   = 5 символов/мин   = 12000 мс на символ (очень медленно)
    ;   10 WPM  = 50 символов/мин  = 1200 мс на символ
    ;   60 WPM  = 300 символов/мин = 200 мс на символ
    ;   100 WPM = 500 символов/мин = 120 мс на символ
    ;   200 WPM = 1000 символов/мин = 60 мс на символ
    ;   300 WPM = 1500 символов/мин = 40 мс на символ
    ;   500 WPM = 2500 символов/мин = 24 мс на символ
    ; ═══════════════════════════════════════════════════════════════════════════
    
    ; Применяем множитель WPM
    effectiveWPM := wpmValue * wpmMultiplier
    
    ; Базовая задержка по WPM
    charsPerMinute := effectiveWPM * 5
    baseDelayMs := 60000 / charsPerMinute
    
    ; Минимальная задержка 1 мс
    if (baseDelayMs < 1)
        baseDelayMs := 1
    
    ; Применяем ограничения мин/макс задержки
    if (minDelayVal > 0 && baseDelayMs < minDelayVal)
        baseDelayMs := minDelayVal
    if (maxDelayVal > 0 && baseDelayMs > maxDelayVal)
        baseDelayMs := maxDelayVal
    
    ; Конвертируем единицы времени в мс
    wordPauseMs := wordPauseVal
    if (wordPauseUnit = "сек")
        wordPauseMs := wordPauseVal * 1000
    if (wordPauseUnit = "мин")
        wordPauseMs := wordPauseVal * 60000
    
    thinkMinMs := thinkMin
    thinkMaxMs := thinkMax
    if (thinkUnit = "сек") {
        thinkMinMs := thinkMin * 1000
        thinkMaxMs := thinkMax * 1000
    }
    
    pauseDurationMs := pauseDuration
    if (pauseUnit = "сек")
        pauseDurationMs := pauseDuration * 1000
    if (pauseUnit = "мин")
        pauseDurationMs := pauseDuration * 60000
    
    ; === ИНИЦИАЛИЗАЦИЯ ===
    totalChars := StrLen(text)
    charIndex := 0
    wordIndex := 0
    currentWord := ""
    currentWordLen := 0
    pausesDone := 0
    nextPauseAt := pauseInterval
    startTime := A_TickCount
    accelStartTime := A_TickCount
    accelTimeMs := accelTime * 1000
    
    ; === ГЛАВНЫЙ ЦИКЛ ПЕЧАТИ ===
    Loop, Parse, text
    {
        if (!isTyping)
            break
        
        char := A_LoopField
        charIndex++

        ; Special tag pause marker (inserted by EncodeSpecialPausesForLegit)
        if (char = Chr(30)) {
            ; Marker isn't a real typed character.
            charIndex--
            if (pauseIdx <= pauseList.Length()) {
                ms := pauseList[pauseIdx] + 0
                pauseIdx++
                if (ms > 0)
                    Sleep, %ms%
            }
            continue
        }
        
        ; === ОСТАНОВКИ ПЕЧАТИ ===
        if (pauseEnabled && pauseCount > 0 && pausesDone < pauseCount) {
            if (charIndex >= nextPauseAt) {
                SB_SetText("Пауза печати...", 3)
                Sleep, %pauseDurationMs%
                pausesDone++
                nextPauseAt := charIndex + pauseInterval
            }
        }
        
        ; === РАСЧЁТ ТЕКУЩЕГО WPM (с учётом ускорения) ===
        currentWPM := wpmValue
        if (accelEnabled) {
            elapsedAccel := A_TickCount - accelStartTime
            if (elapsedAccel < accelTimeMs) {
                ; Линейная интерполяция от начального к конечному WPM
                progress := elapsedAccel / accelTimeMs
                currentWPM := accelStartWPM + (accelEndWPM - accelStartWPM) * progress
            } else {
                currentWPM := accelEndWPM
            }
            ; Пересчитываем базовую задержку
            baseDelayMs := 60000 / (currentWPM * 5)
            if (baseDelayMs < 1)
                baseDelayMs := 1
        }
        
        ; === БАЗОВАЯ ЗАДЕРЖКА ===
        delay := baseDelayMs
        
        ; === СЛУЧАЙНАЯ ЗАДЕРЖКА (если включена) ===
        if (randomDelayEnabled) {
            Random, rndDelay, %randomDelayMin%, %randomDelayMax%
            delay := rndDelay
        }
        
        ; === ВАРИАЦИЯ СКОРОСТИ (разброс) ===
        if (speedVar > 0 && !randomDelayEnabled) {
            ; Генерируем случайное отклонение в процентах
            Random, variation, % -speedVar, % speedVar
            delay := delay * (1 + variation / 100)
        }
        
        ; === АДАПТИВНАЯ ЗАДЕРЖКА (по длине слова) ===
        if (adaptiveDelay && currentWordLen > 0) {
            ; Длинные слова - медленнее в начале, быстрее к концу
            if (currentWordLen > 6) {
                wordProgress := (StrLen(currentWord)) / currentWordLen
                if (wordProgress < 0.3)
                    delay := delay * 1.2  ; Начало слова медленнее
                if (wordProgress > 0.7)
                    delay := delay * 0.85  ; Конец слова быстрее
            }
        }
        
        ; === РИТМ ПЕЧАТИ ===
        if (rhythmVal != "" && rhythmVal != "Равномерный") {
            intensity := rhythmIntensity / 100
            
            if (rhythmVal = "Волнообразный") {
                wave := Sin(charIndex / 8) * intensity
                delay := delay * (1 + wave)
            }
            if (rhythmVal = "Рваный") {
                Random, rnd, 1, 100
                if (rnd <= 15)
                    delay := delay * (1 + intensity)
                if (rnd >= 85)
                    delay := delay * (1 - intensity * 0.5)
            }
            if (rhythmVal = "Ускоряющийся") {
                progress := charIndex / totalChars
                delay := delay * (1 - progress * intensity)
                if (delay < baseDelayMs * 0.3)
                    delay := baseDelayMs * 0.3
            }
            if (rhythmVal = "Замедляющийся") {
                progress := charIndex / totalChars
                delay := delay * (1 + progress * intensity)
            }
        }
        
        ; === BURST-РЕЖИМ ===
        if (burstVal && burstWords && burstWords.Length() > 0) {
            wordLower := Format("{:L}", currentWord)
            for i, item in burstWords {
                if (Format("{:L}", item.word) = wordLower) {
                    if (item.style = "Резкий")
                        delay := delay * 0.3
                    if (item.style = "Очень быстрый")
                        delay := 1
                    if (item.style = "Плавный")
                        delay := delay * 0.6
                    if (item.style = "Свой" && item.customWPM > 0)
                        delay := 60000 / (item.customWPM * 5)
                    break
                }
            }
        }
        
        ; === СЛОЖНОСТЬ СИМВОЛОВ ===
        if (charDiffVal) {
            if (RegExMatch(char, "[ъьёЪЬЁ]"))
                delay := delay * 1.35
            if (RegExMatch(char, "[0-9]"))
                delay := delay * 1.2
            if (RegExMatch(char, "[!@#$%^&*()_+=\[\]{}|;:'"",.<>?/\\]"))
                delay := delay * 1.25
        }
        
        ; === УСТАЛОСТЬ ===
        if (fatigueVal) {
            fatigue := 1 + (charIndex / 400) * 0.2
            if (fatigue > 1.6)
                fatigue := 1.6
            delay := delay * fatigue
        }
        
        ; === SHIFT-ЗАДЕРЖКА ===
        if (capsDelayVal && RegExMatch(char, "[A-ZА-ЯЁ]"))
            delay := delay + 15
        
        ; === ПУНКТУАЦИЯ ===
        if (punctDelayVal && RegExMatch(char, "[.,!?;:]"))
            delay := delay + 25
        
        ; === ПРИМЕНЯЕМ МИН/МАКС ОГРАНИЧЕНИЯ ===
        if (minDelayVal > 0 && delay < minDelayVal)
            delay := minDelayVal
        if (maxDelayVal > 0 && delay > maxDelayVal)
            delay := maxDelayVal
        
        ; === ОПЕЧАТКИ ===
        if (typosEnabled && typoFreqVal > 0) {
            Random, typoRoll, 1, 100
            if (typoRoll <= typoFreqVal) {
                typoChar := GetTypoChar(char)
                Send, {Text}%typoChar%
                if (autoCorrectVal) {
                    Random, cd, 60, 150
                    Sleep, %cd%
                    Send, {Backspace}
                    Random, ad, 30, 80
                    Sleep, %ad%
                }
            }
        }
        
        ; === ПЕЧАТАЕМ СИМВОЛ ===
        Send, {Text}%char%
        
        ; === КОНЕЦ СЛОВА ===
        if (char = " " || char = "`n") {
            wordIndex++
            currentWord := ""
            currentWordLen := 0
            
            ; Пауза между словами
            if (wordPauseEnabled) {
                if (wordPauseRandom) {
                    Random, wp, %wordPauseMin%, %wordPauseMax%
                    Sleep, %wp%
                }
                if (!wordPauseRandom && wordPauseMs > 0) {
                    Sleep, %wordPauseMs%
                }
            }
            
            ; Пауза раздумья
            if (thinkEnabled && thinkFreq > 0 && Mod(wordIndex, thinkFreq) = 0) {
                Random, thinkRoll, 1, 100
                if (thinkRoll <= thinkChance) {
                    Random, tp, %thinkMinMs%, %thinkMaxMs%
                    Sleep, %tp%
                }
            }
        }
        if (char != " " && char != "`n") {
            currentWord .= char
            ; Определяем длину текущего слова для адаптивной задержки
            if (currentWordLen = 0) {
                ; Ищем конец слова
                restText := SubStr(text, charIndex)
                spacePos := InStr(restText, " ")
                nlPos := InStr(restText, "`n")
                if (spacePos > 0 && (nlPos = 0 || spacePos < nlPos))
                    currentWordLen := spacePos
                else if (nlPos > 0)
                    currentWordLen := nlPos
                else
                    currentWordLen := StrLen(restText)
            }
        }
        
        ; === ЗАДЕРЖКА МЕЖДУ СИМВОЛАМИ ===
        sleepTime := Round(delay)
        if (sleepTime >= 1)
            Sleep, %sleepTime%
        
        ; === СТАТУС ===
        if (Mod(charIndex, 20) = 0) {
            elapsed := (A_TickCount - startTime) / 1000
            if (elapsed > 0.5) {
                actualCPM := charIndex / (elapsed / 60)
                actualWPM := Round(actualCPM / 5)
                targetWPM := accelEnabled ? Round(currentWPM) : wpmValue
                SB_SetText("Legit: " . charIndex . "/" . totalChars . " | WPM: " . actualWPM . " (цель: " . targetWPM . ")", 3)
            }
        }
    }
    
    ; === ФИНАЛЬНАЯ СТАТИСТИКА ===
    elapsed := (A_TickCount - startTime) / 1000
    if (elapsed > 0) {
        actualCPM := totalChars / (elapsed / 60)
        actualWPM := Round(actualCPM / 5)
        SB_SetText("Готово: " . totalChars . " симв. | " . Round(elapsed, 1) . " сек | WPM: " . actualWPM, 3)
    }
}

; === ОТКРЫТИЕ НАСТРОЕК BURST-РЕЖИМА ===
OpenBurstSettings:
    Gui, BurstSettings:New, +Owner1
    Gui, BurstSettings:Font, s9, Segoe UI
    Gui, BurstSettings:Add, Text, x10 y10, Слова для Burst-режима:
    Gui, BurstSettings:Add, ListView, vBurstWordsList x10 y30 w350 h180 Grid, Слово|Стиль|WPM
    LV_ModifyCol(1, 140)
    LV_ModifyCol(2, 110)
    LV_ModifyCol(3, 80)
    
    global burstWords
    if (burstWords && burstWords.Length() > 0) {
        Gui, BurstSettings:Default
        for i, item in burstWords
            LV_Add("", item.word, item.style, item.customWPM)
    }
    
    Gui, BurstSettings:Add, Text, x10 y220, Слово:
    Gui, BurstSettings:Add, Edit, vBurstNewWord x60 y217 w100
    Gui, BurstSettings:Add, Text, x170 y220, Стиль:
    Gui, BurstSettings:Add, DropDownList, vBurstNewStyle x210 y217 w150 gBurstStyleChanged, Резкий|Очень быстрый|Плавный|Свой
    Gui, BurstSettings:Add, Text, vBurstWPMLabel x10 y250 Hidden, WPM:
    Gui, BurstSettings:Add, Edit, vBurstCustomWPM x50 y247 w60 Number Hidden
    Gui, BurstSettings:Add, Button, x10 y280 w110 gBurstAddWord, Добавить
    Gui, BurstSettings:Add, Button, x130 y280 w110 gBurstRemoveWord, Удалить
    Gui, BurstSettings:Add, Button, x250 y280 w110 gBurstClearWords, Очистить
    Gui, BurstSettings:Add, Button, x10 y310 w350 gBurstSaveClose, Сохранить и закрыть
    Gui, BurstSettings:Show, w370 h345, Настройки Burst-режима
return

BurstStyleChanged:
    Gui, BurstSettings:Submit, NoHide
    if (BurstNewStyle = "Свой") {
        GuiControl, BurstSettings:Show, BurstWPMLabel
        GuiControl, BurstSettings:Show, BurstCustomWPM
    } else {
        GuiControl, BurstSettings:Hide, BurstWPMLabel
        GuiControl, BurstSettings:Hide, BurstCustomWPM
    }
return

BurstAddWord:
    Gui, BurstSettings:Submit, NoHide
    if (BurstNewWord = "") return
    global burstWords
    if (!burstWords) burstWords := []
    customWPM := (BurstNewStyle = "Свой") ? BurstCustomWPM : 0
    burstWords.Push({word: BurstNewWord, style: BurstNewStyle, customWPM: customWPM})
    Gui, BurstSettings:Default
    LV_Add("", BurstNewWord, BurstNewStyle, customWPM)
    GuiControl, BurstSettings:, BurstNewWord,
return

BurstRemoveWord:
    Gui, BurstSettings:Default
    row := LV_GetNext()
    if (row = 0) return
    global burstWords
    burstWords.RemoveAt(row)
    LV_Delete(row)
return

BurstClearWords:
    global burstWords
    burstWords := []
    Gui, BurstSettings:Default
    LV_Delete()
return

BurstSaveClose:
BurstSettingsGuiClose:
    Gui, BurstSettings:Destroy
return

; === ГЕНЕРАЦИЯ ОПЕЧАТКИ ===
GetTypoChar(originalChar) {
    ; Карта соседних клавиш (русская раскладка)
    nearbyRu := {}
    nearbyRu["й"] := "цф"
    nearbyRu["ц"] := "йук"
    nearbyRu["у"] := "цке"
    nearbyRu["к"] := "уен"
    nearbyRu["е"] := "кнг"
    nearbyRu["н"] := "егш"
    nearbyRu["г"] := "ншщ"
    nearbyRu["ш"] := "гщз"
    nearbyRu["щ"] := "шзх"
    nearbyRu["з"] := "щхъ"
    nearbyRu["х"] := "зъ"
    nearbyRu["ъ"] := "хэ"
    nearbyRu["ф"] := "йыв"
    nearbyRu["ы"] := "фва"
    nearbyRu["в"] := "ыап"
    nearbyRu["а"] := "впр"
    nearbyRu["п"] := "аро"
    nearbyRu["р"] := "пол"
    nearbyRu["о"] := "рлд"
    nearbyRu["л"] := "одж"
    nearbyRu["д"] := "лжэ"
    nearbyRu["ж"] := "дэ"
    nearbyRu["э"] := "жъ"
    nearbyRu["я"] := "фыч"
    nearbyRu["ч"] := "яыс"
    nearbyRu["с"] := "чвм"
    nearbyRu["м"] := "сап"
    nearbyRu["и"] := "мпт"
    nearbyRu["т"] := "ирь"
    nearbyRu["ь"] := "тоб"
    nearbyRu["б"] := "ьлю"
    nearbyRu["ю"] := "бд"
    
    lowerChar := Format("{:L}", originalChar)
    
    if (nearbyRu.HasKey(lowerChar)) {
        neighbors := nearbyRu[lowerChar]
        Random, idx, 1, % StrLen(neighbors)
        typoChar := SubStr(neighbors, idx, 1)
        
        ; Сохраняем регистр
        if (originalChar != lowerChar) {
            StringUpper, typoChar, typoChar
        }
        return typoChar
    }
    
    ; Если нет соседей, возвращаем случайную букву
    Random, randChar, 1, 33
    alphabet := "абвгдеёжзийклмнопрстуфхцчшщъыьэюя"
    return SubStr(alphabet, randChar, 1)
}



; ============================================
; === RAGE-РЕЖИМ ОБРАБОТЧИКИ ===
; ============================================

RageModeToggle:
    Gui, Submit, NoHide
    global rageModeEnabled
    rageModeEnabled := RageModeEnabled
    if (rageModeEnabled) {
        SB_SetText("Rage-режим активирован!", 1)
    } else {
        SB_SetText("Rage-режим выключен", 1)
    }
return

RagePresetFast:
    GuiControl,, RageSpeed, 5000
    GuiControl,, RageSpeedInput, 5000
    GuiControl,, RageNoDelay, 1
    GuiControl,, RageInstantPaste, 0
    SB_SetText("Пресет: Быстро (5000 симв/сек)", 1)
return

RagePresetInsane:
    GuiControl,, RageSpeed, 25000
    GuiControl,, RageSpeedInput, 25000
    GuiControl,, RageNoDelay, 1
    GuiControl,, RageInstantPaste, 1
    GuiControl,, RageExploitKeyDelay, 1
    SB_SetText("Пресет: Безумно (25000 симв/сек)", 1)
return

RagePresetMax:
    GuiControl,, RageSpeed, 99999
    GuiControl,, RageSpeedInput, 99999
    GuiControl,, RageNoDelay, 1
    GuiControl,, RageInstantPaste, 1
    GuiControl,, RageExploitClipboard, 1
    GuiControl,, RageExploitSendRaw, 1
    GuiControl,, RageExploitKeyDelay, 1
    GuiControl,, RageExploitBatchSend, 1
    SB_SetText("Пресет: МАКСИМУМ (99999 симв/сек)", 1)
return

RageTestType:
    Gui, Submit, NoHide
    testText := RageTestInput
    if (testText = "") {
        MsgBox, 48, Ошибка, Введите текст для теста!
        return
    }
    
    ; Получаем настройки
    rageSpd := RageSpeedInput
    noDelay := RageNoDelay
    instantPaste := RageInstantPaste
    exploitClipboard := RageExploitClipboard
    exploitSendRaw := RageExploitSendRaw
    exploitKeyDelay := RageExploitKeyDelay
    exploitBatchSend := RageExploitBatchSend
    
    ; Задержка перед началом
    Sleep, 2000
    
    startTime := A_TickCount
    
    ; Выбираем метод печати
    if (instantPaste || exploitClipboard) {
        ; Мгновенная вставка через буфер
        Clipboard := testText
        Sleep, 10
        Send, ^v
    } else if (exploitSendRaw) {
        ; SendRaw bypass
        if (exploitKeyDelay)
            SetKeyDelay, -1, -1
        SendRaw, %testText%
    } else if (exploitBatchSend) {
        ; Batch send - отправляем по частям
        if (exploitKeyDelay)
            SetKeyDelay, -1, -1
        chunkSize := 50
        Loop, % Ceil(StrLen(testText) / chunkSize) {
            chunk := SubStr(testText, (A_Index - 1) * chunkSize + 1, chunkSize)
            Send, {Text}%chunk%
        }
    } else {
        ; Обычная быстрая печать
        if (exploitKeyDelay)
            SetKeyDelay, -1, -1
        
        if (noDelay) {
            Send, {Text}%testText%
        } else {
            delay := 1000 / rageSpd
            Loop, Parse, testText
            {
                Send, {Text}%A_LoopField%
                if (delay >= 1)
                    Sleep, %delay%
            }
        }
    }
    
    endTime := A_TickCount
    elapsed := (endTime - startTime) / 1000
    charCount := StrLen(testText)
    
    if (elapsed > 0) {
        cps := Round(charCount / elapsed)
        GuiControl,, RageTestStats, Статистика: %charCount% символов за %elapsed% сек | %cps% симв/сек
    } else {
        GuiControl,, RageTestStats, Статистика: %charCount% символов (мгновенно)
    }
return

; === НОВЫЕ ПРЕСЕТЫ RAGE ===
RagePresetUltra:
    GuiControl,, RageSpeed, 99999
    GuiControl,, RageSpeedInput, 99999
    GuiControl,, RageNoDelay, 1
    GuiControl,, RageInstantPaste, 1
    GuiControl,, RageBurstMode, 1
    GuiControl,, RageBurstSize, 1000
    GuiControl,, RageExploitClipboard, 1
    GuiControl,, RageExploitSendRaw, 1
    GuiControl,, RageExploitKeyDelay, 1
    GuiControl,, RageExploitBatchSend, 1
    GuiControl,, RageExploitMemoryWrite, 1
    SB_SetText("Пресет: ULTRA RAGE (1000 строк/мс)", 1)
return

RagePresetGodMode:
    GuiControl,, RageSpeed, 99999
    GuiControl,, RageSpeedInput, 99999
    GuiControl,, RageLinesPerMs, 10000
    GuiControl,, RageNoDelay, 1
    GuiControl,, RageInstantPaste, 1
    GuiControl,, RageBurstMode, 1
    GuiControl,, RageBurstSize, 10000
    GuiControl,, RageOverrideMode, 1
    GuiControl,, RageExploitClipboard, 1
    GuiControl,, RageExploitSendRaw, 1
    GuiControl,, RageExploitKeyDelay, 1
    GuiControl,, RageExploitBatchSend, 1
    GuiControl,, RageExploitMemoryWrite, 1
    GuiControl,, RageExploitThreadInjection, 1
    SB_SetText("Пресет: GOD MODE (10000 строк/мс)", 1)
return

; === ТЕСТ BURST-РЕЖИМА ===
RageTestBurst:
    Gui, Submit, NoHide
    testText := RageTestInput
    testMode := RageTestMode
    
    if (testText = "") {
        MsgBox, 48, Ошибка, Введите текст для теста!
        return
    }
    
    ; Определяем количество строк
    if (testMode = "Burst (100 строк)")
        lineCount := 100
    else if (testMode = "Burst (1000 строк)")
        lineCount := 1000
    else if (testMode = "Ultra (10000 строк)")
        lineCount := 10000
    else
        lineCount := 1
    
    MsgBox, 36, Подтверждение, Отправить %lineCount% строк?`n`nУ вас есть 3 секунды для переключения на целевое окно!
    IfMsgBox, No
        return
    
    Sleep, 3000
    
    startTime := A_TickCount
    
    ; Burst-отправка
    Loop, %lineCount% {
        Send, {Text}%testText%
        Send, {Enter}
    }
    
    endTime := A_TickCount
    elapsed := (endTime - startTime) / 1000
    totalChars := StrLen(testText) * lineCount
    
    if (elapsed > 0) {
        cps := Round(totalChars / elapsed)
        lps := Round(lineCount / elapsed)
        GuiControl,, RageTestStats, Burst: %lineCount% строк за %elapsed% сек | %cps% симв/сек | %lps% строк/сек
    } else {
        GuiControl,, RageTestStats, Burst: %lineCount% строк (мгновенно)
    }
return

; === НОВЫЕ ОБРАБОТЧИКИ RAGE ===
RageWorkModeChanged:
    Gui, Submit, NoHide
    if (RageWorkModeNormal)
        SB_SetText("Rage: Обычный режим (текст)", 1)
    else if (RageWorkModeGenerator)
        SB_SetText("Rage: Генератор текста", 1)
    else if (RageWorkModeHybrid)
        SB_SetText("Rage: Гибридный режим", 1)
return

RagePresetGod:
    GuiControl,, RageSpeed, 99999
    GuiControl,, RageSpeedInput, 99999
    GuiControl,, RageNoDelay, 1
    GuiControl,, RageTurboMode, 0
    GuiControl,, RageHyperMode, 0
    GuiControl,, RageGodMode, 1
    GuiControl,, RageSpeedMultiplier, 10.0
    SB_SetText("Пресет: GOD MODE (99999 x10)", 1)
return

; === ОБРАБОТЧИКИ BURST ЧЕКБОКСОВ ===
RageBurstChanged:
    Gui, Submit, NoHide
    
    ; Определяем какой чекбокс активен и устанавливаем размер
    if (RageMicroBurst) {
        GuiControl,, RageBurstSize, 10
        SB_SetText("Burst: Micro (10 строк)", 1)
    } else if (RageMiniBurst) {
        GuiControl,, RageBurstSize, 50
        SB_SetText("Burst: Mini (50 строк)", 1)
    } else if (RageNormalBurst) {
        GuiControl,, RageBurstSize, 100
        SB_SetText("Burst: Normal (100 строк)", 1)
    } else if (RageMegaBurst) {
        GuiControl,, RageBurstSize, 500
        SB_SetText("Burst: Mega (500 строк)", 1)
    } else if (RageGigaBurst) {
        GuiControl,, RageBurstSize, 1000
        SB_SetText("Burst: Giga (1000 строк)", 1)
    } else if (RageUltraBurst) {
        GuiControl,, RageBurstSize, 5000
        SB_SetText("Burst: Ultra (5000 строк)", 1)
    } else if (RageInfiniteBurst) {
        GuiControl,, RageBurstSize, 99999
        SB_SetText("Burst: Infinite (без лимита)", 1)
    }
    
    ; Включаем Burst если выбран любой режим
    if (RageMicroBurst || RageMiniBurst || RageNormalBurst || RageMegaBurst || RageGigaBurst || RageUltraBurst || RageInfiniteBurst) {
        GuiControl,, RageBurstMode, 1
    }
return

; === СТАРЫЕ ОБРАБОТЧИКИ (удалены, заменены на RageBurstChanged) ===
RageBurstMicro:
RageBurstMini:
RageBurstNormal:
RageBurstMega:
RageBurstGiga:
RageBurstUltra:
RageBurstInfinite:
    ; Эти обработчики больше не нужны, используется RageBurstChanged
return

; === СИНХРОНИЗАЦИЯ СЛАЙДЕРА И ПОЛЯ ВВОДА ===
RageSpeedChanged:
    GuiControlGet, val,, RageSpeed
    GuiControl,, RageSpeedInput, %val%
return

RageSpeedInputChanged:
    GuiControlGet, val,, RageSpeedInput
    GuiControl,, RageSpeed, %val%
return

; ═══════════════════════════════════════════════════════════════════════════════
; 🔧 РАСШИРЕННЫЕ НАСТРОЙКИ RAGE (150+ ПАРАМЕТРОВ)
; ═══════════════════════════════════════════════════════════════════════════════

OpenRageAdvanced:
    Gui, RageAdvanced:New, +Owner1 +Resize
    Gui, RageAdvanced:Font, s10 Bold, Segoe UI
    Gui, RageAdvanced:Color, White
    
    ; Заголовок
    Gui, RageAdvanced:Add, Text, x15 y10 w970 h30 c0066CC Center, 🔥 РАСШИРЕННЫЕ НАСТРОЙКИ RAGE-РЕЖИМА (500+ ПАРАМЕТРОВ)
    Gui, RageAdvanced:Font, s9 Normal, Segoe UI
    
    ; Создаём вкладки для группировки настроек
    Gui, RageAdvanced:Add, Tab3, x10 y45 w980 h650 vRageAdvancedTabs, Скорость|Эксплойты|Burst|Override
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ВКЛАДКА 1: СКОРОСТЬ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, RageAdvanced:Tab, 1
    
    ; === ЛЕВАЯ КОЛОНКА ===
    Gui, RageAdvanced:Add, GroupBox, x20 y75 w460 h280, ⚡ Параметры скорости
    Gui, RageAdvanced:Add, Text, x30 y95, Базовая скорость (симв/сек):
    Gui, RageAdvanced:Add, Edit, vRageAdvSpeed x250 y92 w80 Number, 99999
    Gui, RageAdvanced:Add, Slider, vRageAdvSpeedSlider x30 y115 w300 Range100-99999 TickInterval10000 gRageAdvSpeedChanged, 99999
    
    Gui, RageAdvanced:Add, Text, x30 y145, Множитель скорости:
    Gui, RageAdvanced:Add, Edit, vRageAdvSpeedMultiplier x250 y142 w80, 1.0
    Gui, RageAdvanced:Add, UpDown, Range0.1-100, 1.0
    
    Gui, RageAdvanced:Add, Text, x30 y170, Задержка между символами (мс):
    Gui, RageAdvanced:Add, Edit, vRageAdvCharDelay x250 y167 w80 Number, 0
    
    Gui, RageAdvanced:Add, Text, x30 y195, Задержка между словами (мс):
    Gui, RageAdvanced:Add, Edit, vRageAdvWordDelay x250 y192 w80 Number, 0
    
    Gui, RageAdvanced:Add, Text, x30 y220, Задержка между строками (мс):
    Gui, RageAdvanced:Add, Edit, vRageAdvLineDelay x250 y217 w80 Number, 0
    
    Gui, RageAdvanced:Add, Checkbox, vRageAdvAdaptiveSpeed x30 y245, Адаптивная скорость
    Gui, RageAdvanced:Add, Checkbox, vRageAdvProgressiveSpeed x30 y265, Прогрессивное ускорение
    Gui, RageAdvanced:Add, Checkbox, vRageAdvBurstSpeed x30 y285, Burst-ускорение
    Gui, RageAdvanced:Add, Checkbox, vRageAdvTurboMode x30 y305, Turbo-режим (x2)
    Gui, RageAdvanced:Add, Checkbox, vRageAdvHyperMode x30 y325, Hyper-режим (x5)
    
    ; === ПРАВАЯ КОЛОНКА ===
    Gui, RageAdvanced:Add, GroupBox, x490 y75 w480 h280, 🎯 Режимы отправки
    Gui, RageAdvanced:Add, Checkbox, vRageAdvSendText x500 y95, Send {Text} режим
    Gui, RageAdvanced:Add, Checkbox, vRageAdvSendRaw x500 y115, SendRaw режим
    Gui, RageAdvanced:Add, Checkbox, vRageAdvSendInput x500 y135, SendInput режим
    Gui, RageAdvanced:Add, Checkbox, vRageAdvSendPlay x500 y155, SendPlay режим
    Gui, RageAdvanced:Add, Checkbox, vRageAdvSendEvent x500 y175, SendEvent режим
    Gui, RageAdvanced:Add, Checkbox, vRageAdvClipboardMode x500 y195, Clipboard режим
    Gui, RageAdvanced:Add, Checkbox, vRageAdvComObjectMode x500 y215, COM Object режим
    Gui, RageAdvanced:Add, Checkbox, vRageAdvDLLCallMode x500 y235, DLL Call режим
    Gui, RageAdvanced:Add, Checkbox, vRageAdvMemoryWriteMode x500 y255, Memory Write режим
    Gui, RageAdvanced:Add, Checkbox, vRageAdvDirectInputMode x500 y275, Direct Input режим
    Gui, RageAdvanced:Add, Checkbox, vRageAdvPostMessageMode x500 y295, PostMessage режим
    Gui, RageAdvanced:Add, Checkbox, vRageAdvSendMessageMode x500 y315, SendMessage режим
    Gui, RageAdvanced:Add, Checkbox, vRageAdvWMCharMode x500 y335, WM_CHAR режим
    
    ; === НИЖНЯЯ СЕКЦИЯ ===
    Gui, RageAdvanced:Add, GroupBox, x20 y360 w950 h150, 🎨 Дополнительные настройки
    Gui, RageAdvanced:Add, Text, x30 y380, Приоритет процесса:
    Gui, RageAdvanced:Add, DropDownList, vRageAdvProcessPriority x150 y377 w150, Low|BelowNormal|Normal||AboveNormal|High|Realtime
    
    Gui, RageAdvanced:Add, Text, x320 y380, Приоритет потока:
    Gui, RageAdvanced:Add, DropDownList, vRageAdvThreadPriority x440 y377 w150, Lowest|BelowNormal|Normal||AboveNormal|Highest|TimeCritical
    
    Gui, RageAdvanced:Add, Text, x610 y380, Режим батчинга:
    Gui, RageAdvanced:Add, DropDownList, vRageAdvBatchMode x730 y377 w150, Отключен||Малый|Средний|Большой|Огромный
    
    Gui, RageAdvanced:Add, Checkbox, vRageAdvZeroKeyDelay x30 y410, Zero KeyDelay
    Gui, RageAdvanced:Add, Checkbox, vRageAdvZeroMouseDelay x30 y430, Zero MouseDelay
    Gui, RageAdvanced:Add, Checkbox, vRageAdvZeroWinDelay x30 y450, Zero WinDelay
    Gui, RageAdvanced:Add, Checkbox, vRageAdvZeroControlDelay x30 y470, Zero ControlDelay
    
    Gui, RageAdvanced:Add, Checkbox, vRageAdvSetBatchLines x250 y410, SetBatchLines -1
    Gui, RageAdvanced:Add, Checkbox, vRageAdvSetWinDelay x250 y430, SetWinDelay -1
    Gui, RageAdvanced:Add, Checkbox, vRageAdvSetControlDelay x250 y450, SetControlDelay -1
    Gui, RageAdvanced:Add, Checkbox, vRageAdvCritical x250 y470, Critical режим
    
    Gui, RageAdvanced:Add, Checkbox, vRageAdvNoTrayIcon x470 y410, Скрыть иконку в трее
    Gui, RageAdvanced:Add, Checkbox, vRageAdvNoSplash x470 y430, Без заставки
    Gui, RageAdvanced:Add, Checkbox, vRageAdvNoWarnings x470 y450, Без предупреждений
    Gui, RageAdvanced:Add, Checkbox, vRageAdvSilentMode x470 y470, Тихий режим
    
    Gui, RageAdvanced:Add, Checkbox, vRageAdvAutoRestart x690 y410, Авто-перезапуск
    Gui, RageAdvanced:Add, Checkbox, vRageAdvErrorRecovery x690 y430, Восстановление ошибок
    Gui, RageAdvanced:Add, Checkbox, vRageAdvLogging x690 y450, Логирование
    Gui, RageAdvanced:Add, Checkbox, vRageAdvDebugMode x690 y470, Debug-режим
    
    ; === СТАТИСТИКА ===
    Gui, RageAdvanced:Add, GroupBox, x20 y515 w950 h130, 📊 Статистика и мониторинг
    Gui, RageAdvanced:Add, ListView, vRageAdvStatsListView x30 y535 w930 h100 Grid, Параметр|Значение|Статус|Описание
    LV_ModifyCol(1, 200)
    LV_ModifyCol(2, 150)
    LV_ModifyCol(3, 100)
    LV_ModifyCol(4, 450)
    LV_Add("", "Текущая скорость", "0 симв/сек", "Активно", "Скорость печати в реальном времени")
    LV_Add("", "Отправлено символов", "0", "Ожидание", "Всего отправлено символов")
    LV_Add("", "Отправлено строк", "0", "Ожидание", "Всего отправлено строк")
    LV_Add("", "Среднее время", "0 мс", "Ожидание", "Среднее время на символ")
    LV_Add("", "Использование CPU", "0%", "Норма", "Загрузка процессора")
    LV_Add("", "Использование памяти", "0 MB", "Норма", "Использование оперативной памяти")
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ВКЛАДКА: ЭКСПЛОИТЫ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, RageAdvanced:Tab, 2
    
    Gui, RageAdvanced:Add, GroupBox, x20 y75 w460 h280, 💣 Эксплоиты ввода
    yPos := 95
    Gui, RageAdvanced:Add, Checkbox, vRageExploit1 gRageExploitChanged x30 y%yPos%, Zero KeyDelay Exploit
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageExploit2 gRageExploitChanged x30 y%yPos%, Clipboard Hijack
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageExploit3 gRageExploitChanged x30 y%yPos%, SendMessage Exploit
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageExploit4 gRageExploitChanged x30 y%yPos%, PostMessage Exploit
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageExploit5 gRageExploitChanged x30 y%yPos%, WM_CHAR Injection
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageExploit6 gRageExploitChanged x30 y%yPos%, WM_KEYDOWN Bypass
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageExploit7 gRageExploitChanged x30 y%yPos%, Unicode Injection
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageExploit8 gRageExploitChanged x30 y%yPos%, Raw Input Bypass
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageExploit9 gRageExploitChanged x30 y%yPos%, Hook Bypass
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageExploit10 gRageExploitChanged x30 y%yPos%, Anti-Detection Exploit
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageExploit11 gRageExploitChanged x30 y%yPos%, Timing Randomization
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageExploit12 gRageExploitChanged x30 y%yPos%, Pattern Obfuscation
    
    Gui, RageAdvanced:Add, GroupBox, x490 y75 w480 h280, 🔓 Эксплоиты обхода
    yPos := 95
    Gui, RageAdvanced:Add, Checkbox, vRageBypass1 gRageExploitChanged x500 y%yPos%, Anti-Cheat Bypass
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageBypass2 gRageExploitChanged x500 y%yPos%, Rate Limit Bypass
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageBypass3 gRageExploitChanged x500 y%yPos%, Flood Protection Bypass
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageBypass4 gRageExploitChanged x500 y%yPos%, Captcha Bypass
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageBypass5 gRageExploitChanged x500 y%yPos%, Bot Detection Bypass
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageBypass6 gRageExploitChanged x500 y%yPos%, Fingerprint Spoofing
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageBypass7 gRageExploitChanged x500 y%yPos%, Behavior Mimicking
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageBypass8 gRageExploitChanged x500 y%yPos%, Human Pattern Simulation
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageBypass9 gRageExploitChanged x500 y%yPos%, Timing Jitter
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageBypass10 gRageExploitChanged x500 y%yPos%, Mouse Movement Simulation
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageBypass11 gRageExploitChanged x500 y%yPos%, Idle Time Injection
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageBypass12 gRageExploitChanged x500 y%yPos%, Multi-Window Switching
    
    ; === НАСТРОЙКИ ЭКСПЛОЙТОВ ===
    Gui, RageAdvanced:Add, GroupBox, x20 y360 w950 h150, ⚙️ Настройки эксплойтов
    Gui, RageAdvanced:Add, Text, x30 y380, Интенсивность обхода:
    Gui, RageAdvanced:Add, Slider, vRageExploitIntensity x180 y377 w200 Range0-100 TickInterval10 gRageExploitIntensityChanged, 50
    Gui, RageAdvanced:Add, Edit, vRageExploitIntensityValue x390 y377 w50 Number, 50
    Gui, RageAdvanced:Add, Text, x450 y380, `%
    
    Gui, RageAdvanced:Add, Text, x500 y380, Задержка рандомизации (мс):
    Gui, RageAdvanced:Add, Edit, vRageExploitRandomDelay x700 y377 w80 Number, 0
    
    Gui, RageAdvanced:Add, Text, x30 y410, Метод обхода:
    Gui, RageAdvanced:Add, DropDownList, vRageExploitMethod x180 y407 w260, Стандартный||Агрессивный|Скрытный|Гибридный|Адаптивный
    
    Gui, RageAdvanced:Add, Text, x500 y410, Уровень маскировки:
    Gui, RageAdvanced:Add, DropDownList, vRageExploitMaskLevel x700 y407 w200, Нет|Низкий|Средний||Высокий|Максимальный
    
    Gui, RageAdvanced:Add, Checkbox, vRageExploitAutoDetect x30 y440, Авто-определение защиты
    Gui, RageAdvanced:Add, Checkbox, vRageExploitAutoAdapt x30 y460, Авто-адаптация методов
    Gui, RageAdvanced:Add, Checkbox, vRageExploitSafeMode x30 y480, Безопасный режим
    
    Gui, RageAdvanced:Add, Checkbox, vRageExploitStealthMode x250 y440, Stealth-режим
    Gui, RageAdvanced:Add, Checkbox, vRageExploitGhostMode x250 y460, Ghost-режим
    Gui, RageAdvanced:Add, Checkbox, vRageExploitPhantomMode x250 y480, Phantom-режим
    
    Gui, RageAdvanced:Add, Checkbox, vRageExploitAntiLog x470 y440, Anti-Log
    Gui, RageAdvanced:Add, Checkbox, vRageExploitAntiTrace x470 y460, Anti-Trace
    Gui, RageAdvanced:Add, Checkbox, vRageExploitAntiDebug x470 y480, Anti-Debug
    
    Gui, RageAdvanced:Add, Checkbox, vRageExploitEncrypt x690 y440, Шифрование данных
    Gui, RageAdvanced:Add, Checkbox, vRageExploitObfuscate x690 y460, Обфускация
    Gui, RageAdvanced:Add, Checkbox, vRageExploitCompress x690 y480, Сжатие
    
    ; === СПИСОК АКТИВНЫХ ЭКСПЛОЙТОВ ===
    Gui, RageAdvanced:Add, GroupBox, x20 y515 w950 h130, 📋 Активные эксплойты
    Gui, RageAdvanced:Add, ListView, vRageExploitsList gRageExploitsListClick x30 y535 w930 h80 Grid, Эксплойт|Тип|Статус|Эффективность|Описание
    LV_ModifyCol(1, 200)
    LV_ModifyCol(2, 120)
    LV_ModifyCol(3, 100)
    LV_ModifyCol(4, 120)
    LV_ModifyCol(5, 360)
    Gui, RageAdvanced:Add, Button, x30 y620 w140 h22 gRageExploitRefreshTable, 🔄 Обновить
    Gui, RageAdvanced:Add, Button, x180 y620 w140 h22 gRageExploitToggleSelected, 🔁 Вкл/Выкл
    Gui, RageAdvanced:Add, Button, x330 y620 w140 h22 gRageExploitAddCustom, ➕ Добавить
    Gui, RageAdvanced:Add, Button, x480 y620 w140 h22 gRageExploitEditCustom, ✏️ Изменить
    Gui, RageAdvanced:Add, Button, x630 y620 w140 h22 gRageExploitDeleteCustom, ❌ Удалить
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ВКЛАДКА 3: BURST
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, RageAdvanced:Tab, 3
    
    Gui, RageAdvanced:Add, GroupBox, x20 y75 w950 h170, 💥 Отправка сообщений (Burst)
    Gui, RageAdvanced:Add, Checkbox, vRageDispatchEnabled x30 y98 gRageAdvancedToggleBurstControls, Включить отправку сообщений
    Gui, RageAdvanced:Add, Text, x30 y128, Сообщений:
    Gui, RageAdvanced:Add, Edit, vRageDispatchMessageCount x120 y125 w90 Number, 100
    Gui, RageAdvanced:Add, Text, x230 y128, За время:
    Gui, RageAdvanced:Add, Edit, vRageDispatchTimeValue x290 y125 w70 Number, 1
    Gui, RageAdvanced:Add, DropDownList, vRageDispatchTimeUnit x370 y125 w120, Миллисекунды|Секунды||Минуты|Часы
    Gui, RageAdvanced:Add, Text, x510 y128, Текст берётся из текущего режима Rage + ограничений печати
    
    Gui, RageAdvanced:Add, Checkbox, vRageAdvEnablePacketSize x30 y158 gRageAdvancedToggleBurstControls, Использовать размер пакета
    Gui, RageAdvanced:Add, Edit, vRageAdvBurstPacketSize x220 y156 w80 Number, 1000
    Gui, RageAdvanced:Add, Checkbox, vRageAdvEnablePacketDelay x320 y158 gRageAdvancedToggleBurstControls, Задержка между пакетами (мс)
    Gui, RageAdvanced:Add, Edit, vRageAdvBurstPacketDelay x540 y156 w80 Number, 0
    Gui, RageAdvanced:Add, Checkbox, vRageAdvEnableThreads x640 y158 gRageAdvancedToggleBurstControls, Потоки
    Gui, RageAdvanced:Add, Edit, vRageAdvBurstThreads x720 y156 w80 Number, 1
    
    Gui, RageAdvanced:Add, GroupBox, x20 y250 w540 h395, ⚙️ Реальные параметры Burst
    yPos := 272
    Gui, RageAdvanced:Add, Checkbox, vRageBurstOptJitter gRageAdvancedToggleBurstControls x30 y%yPos%, Джиттер задержки
    Gui, RageAdvanced:Add, Text, x200 y%yPos%, Мин/Макс мс:
    Gui, RageAdvanced:Add, Edit, vRageBurstJitterMin x290 y%yPos% w55 Number, 0
    Gui, RageAdvanced:Add, Edit, vRageBurstJitterMax x350 y%yPos% w55 Number, 15
    yPos += 24
    Gui, RageAdvanced:Add, Checkbox, vRageBurstOptRetry gRageAdvancedToggleBurstControls x30 y%yPos%, Повтор при пустом сообщении
    Gui, RageAdvanced:Add, Text, x200 y%yPos%, Попытки/Пауза:
    Gui, RageAdvanced:Add, Edit, vRageBurstRetryCount x300 y%yPos% w45 Number, 2
    Gui, RageAdvanced:Add, Edit, vRageBurstRetryDelay x350 y%yPos% w55 Number, 5
    yPos += 24
    Gui, RageAdvanced:Add, Checkbox, vRageBurstOptCooldown gRageAdvancedToggleBurstControls x30 y%yPos%, Пауза каждые N сообщений
    Gui, RageAdvanced:Add, Text, x200 y%yPos%, N/мс:
    Gui, RageAdvanced:Add, Edit, vRageBurstCooldownEvery x250 y%yPos% w45 Number, 25
    Gui, RageAdvanced:Add, Edit, vRageBurstCooldownMs x300 y%yPos% w60 Number, 150
    yPos += 24
    Gui, RageAdvanced:Add, Checkbox, vRageBurstOptWarmup gRageAdvancedToggleBurstControls x30 y%yPos%, Прогрев скорости
    Gui, RageAdvanced:Add, Text, x200 y%yPos%, Сообщений/Старт мс:
    Gui, RageAdvanced:Add, Edit, vRageBurstWarmupCount x325 y%yPos% w45 Number, 15
    Gui, RageAdvanced:Add, Edit, vRageBurstWarmupStartMs x375 y%yPos% w55 Number, 30
    yPos += 24
    Gui, RageAdvanced:Add, Checkbox, vRageBurstOptDedupe gRageAdvancedToggleBurstControls x30 y%yPos%, Анти-дубликат (пересборка)
    Gui, RageAdvanced:Add, Text, x200 y%yPos%, Макс попыток:
    Gui, RageAdvanced:Add, Edit, vRageBurstDedupeAttempts x300 y%yPos% w45 Number, 3
    yPos += 24
    Gui, RageAdvanced:Add, Checkbox, vRageBurstOptRandomCase gRageAdvancedToggleBurstControls x30 y%yPos%, Случайный регистр
    Gui, RageAdvanced:Add, Text, x200 y%yPos%, Шанс `%:
    Gui, RageAdvanced:Add, Edit, vRageBurstRandomCaseChance x270 y%yPos% w45 Number, 20
    yPos += 24
    Gui, RageAdvanced:Add, Checkbox, vRageBurstOptRandomPunct gRageAdvancedToggleBurstControls x30 y%yPos%, Случайная пунктуация
    Gui, RageAdvanced:Add, Text, x200 y%yPos%, Шанс `%:
    Gui, RageAdvanced:Add, Edit, vRageBurstRandomPunctChance x270 y%yPos% w45 Number, 20
    yPos += 24
    Gui, RageAdvanced:Add, Checkbox, vRageBurstOptAdaptiveRate gRageAdvancedToggleBurstControls x30 y%yPos%, Ограничение сообщений/сек
    Gui, RageAdvanced:Add, Text, x200 y%yPos%, Лимит:
    Gui, RageAdvanced:Add, Edit, vRageBurstRateLimit x250 y%yPos% w55 Number, 30
    yPos += 24
    Gui, RageAdvanced:Add, Checkbox, vRageBurstOptPrefixCounter gRageAdvancedToggleBurstControls x30 y%yPos%, Префикс-счетчик
    Gui, RageAdvanced:Add, Text, x200 y%yPos%, Формат:
    Gui, RageAdvanced:Add, DropDownList, vRageBurstCounterFormat x250 y%yPos% w130, [#n]||(#n)|<n>|n:
    yPos += 24
    Gui, RageAdvanced:Add, Checkbox, vRageBurstOptStats gRageAdvancedToggleBurstControls x30 y%yPos%, Живая статистика Burst
    Gui, RageAdvanced:Add, Text, x200 y%yPos%, Интервал обновл.:
    Gui, RageAdvanced:Add, Edit, vRageBurstStatsInterval x315 y%yPos% w50 Number, 10
    yPos += 24
    Gui, RageAdvanced:Add, Checkbox, vRageBurstOptAutoRebuild gRageAdvancedToggleBurstControls x30 y%yPos%, Пересобирать текст каждого сообщения
    Gui, RageAdvanced:Add, Text, x300 y%yPos%, (для рандома строк/слов)
    yPos += 24
    Gui, RageAdvanced:Add, Checkbox, vRageBurstOptPacketPause gRageAdvancedToggleBurstControls x30 y%yPos%, Пауза между пакетами
    Gui, RageAdvanced:Add, Text, x200 y%yPos%, Размер/мс:
    Gui, RageAdvanced:Add, Edit, vRageBurstPacketSize2 x270 y%yPos% w55 Number, 100
    Gui, RageAdvanced:Add, Edit, vRageBurstPacketPauseMs x330 y%yPos% w60 Number, 40
    yPos += 24
    Gui, RageAdvanced:Add, Checkbox, vRageBurstOptForceInstant gRageAdvancedToggleBurstControls x30 y%yPos%, Форс мгновенной отправки
    Gui, RageAdvanced:Add, Text, x200 y%yPos%, Порог (мс):
    Gui, RageAdvanced:Add, Edit, vRageBurstForceThresholdMs x270 y%yPos% w55 Number, 5
    yPos += 24
    Gui, RageAdvanced:Add, Checkbox, vRageBurstOptStrictUnique gRageAdvancedToggleBurstControls x30 y%yPos%, Строгая уникальность сообщений
    Gui, RageAdvanced:Add, Text, x250 y%yPos%, Попытки:
    Gui, RageAdvanced:Add, Edit, vRageBurstUniqueAttempts x305 y%yPos% w45 Number, 4
    Gui, RageAdvanced:Add, Checkbox, vRageBurstUniqueSuffix gRageAdvancedToggleBurstControls x360 y%yPos%, Добавлять суффикс при дублях
    
    Gui, RageAdvanced:Add, GroupBox, x570 y250 w400 h395, 📊 Изменяемая таблица Burst
    Gui, RageAdvanced:Add, Text, x580 y272, Стратегия отправки:
    Gui, RageAdvanced:Add, Radio, vRageAdvBurstStrategy1 x700 y270 Checked, Последовательно
    Gui, RageAdvanced:Add, Radio, vRageAdvBurstStrategy2 x820 y270, Параллельно
    Gui, RageAdvanced:Add, Radio, vRageAdvBurstStrategy3 x700 y290, Асинхронно
    Gui, RageAdvanced:Add, Radio, vRageAdvBurstStrategy4 x820 y290, Гибридно
    
    Gui, RageAdvanced:Add, ListView, vRageAdvBurstTable gRageBurstTableClick x580 y320 w380 h250 Grid, Опция|Вкл|Параметр 1|Параметр 2|Описание
    LV_ModifyCol(1, 120)
    LV_ModifyCol(2, 40)
    LV_ModifyCol(3, 70)
    LV_ModifyCol(4, 70)
    LV_ModifyCol(5, 160)
    
    Gui, RageAdvanced:Add, Button, x580 y580 w120 h26 gRageBurstRefreshTable, 🔄 Обновить
    Gui, RageAdvanced:Add, Button, x710 y580 w120 h26 gRageBurstToggleSelected, 🔁 Вкл/Выкл
    Gui, RageAdvanced:Add, Button, x840 y580 w120 h26 gRageBurstEditSelected, ✏️ Изменить
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ВКЛАДКА 4: OVERRIDE
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, RageAdvanced:Tab, 4
    
    Gui, RageAdvanced:Add, GroupBox, x20 y75 w960 h280, 👑 Override-режим (игнорирование всех ограничений)
    yPos := 95
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideAll gRageOverrideChanged x30 y%yPos%, Игнорировать ВСЕ ограничения
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideSpeed gRageOverrideChanged x30 y%yPos%, Игнорировать ограничения скорости
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideDelay gRageOverrideChanged x30 y%yPos%, Игнорировать задержки
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideRateLimit gRageOverrideChanged x30 y%yPos%, Игнорировать rate limit
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideFloodProtection gRageOverrideChanged x30 y%yPos%, Игнорировать flood protection
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideAntiSpam gRageOverrideChanged x30 y%yPos%, Игнорировать anti-spam
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideValidation gRageOverrideChanged x30 y%yPos%, Игнорировать валидацию
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideSecurity gRageOverrideChanged x30 y%yPos%, Игнорировать безопасность
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideDetection gRageOverrideChanged x30 y%yPos%, Игнорировать детекцию
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideFilters gRageOverrideChanged x30 y%yPos%, Игнорировать фильтры
    
    yPos := 95
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideLength gRageOverrideChanged x400 y%yPos%, Игнорировать ограничения длины
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideFormat gRageOverrideChanged x400 y%yPos%, Игнорировать форматирование
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideEncoding gRageOverrideChanged x400 y%yPos%, Игнорировать кодировку
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverridePermissions gRageOverrideChanged x400 y%yPos%, Игнорировать права доступа
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideTimeout gRageOverrideChanged x400 y%yPos%, Игнорировать таймауты
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideQueue gRageOverrideChanged x400 y%yPos%, Игнорировать очередь
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverridePriority gRageOverrideChanged x400 y%yPos%, Игнорировать приоритет
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideThrottle gRageOverrideChanged x400 y%yPos%, Игнорировать throttling
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideBackoff gRageOverrideChanged x400 y%yPos%, Игнорировать backoff
    yPos += 20
    Gui, RageAdvanced:Add, Checkbox, vRageOverrideRetry gRageOverrideChanged x400 y%yPos%, Игнорировать retry logic
    
    ; === СПИСОК OVERRIDE ===
    Gui, RageAdvanced:Add, GroupBox, x20 y360 w950 h285, 📋 Активные Override
    Gui, RageAdvanced:Add, ListView, vRageOverrideList gRageOverrideListClick x30 y380 w930 h150 Grid, Параметр|Статус|Оригинальное значение|Override значение|Описание
    LV_ModifyCol(1, 180)
    LV_ModifyCol(2, 100)
    LV_ModifyCol(3, 150)
    LV_ModifyCol(4, 150)
    LV_ModifyCol(5, 320)
    Gui, RageAdvanced:Add, Button, x30 y540 w120 h25 gRageOverrideRefresh, 🔄 Обновить
    Gui, RageAdvanced:Add, Button, x160 y540 w120 h25 gRageOverrideToggleSelected, 🔁 Вкл/Выкл
    Gui, RageAdvanced:Add, Button, x290 y540 w120 h25 gRageOverrideAddCustom, ➕ Добавить
    Gui, RageAdvanced:Add, Button, x420 y540 w120 h25 gRageOverrideEditCustom, ✏️ Изменить
    Gui, RageAdvanced:Add, Button, x550 y540 w120 h25 gRageOverrideDeleteCustom, ❌ Удалить
    
    Gui, RageAdvanced:Add, Button, x680 y540 w120 h25 gRageOverrideEnableAll, ✓ Все ON
    Gui, RageAdvanced:Add, Button, x810 y540 w120 h25 gRageOverrideDisableAll, ✗ Все OFF
    
    Gui, RageAdvanced:Add, Text, x30 y605, Глобальный Override:
    Gui, RageAdvanced:Add, DropDownList, vRageOverrideGlobal x160 y602 w200, Выключен||Частичный|Полный|Экстремальный
    Gui, RageAdvanced:Add, Text, x380 y605, Уровень агрессивности:
    Gui, RageAdvanced:Add, Slider, vRageOverrideAggression x540 y602 w300 Range0-100 TickInterval10, 50
    Gui, RageAdvanced:Add, Edit, vRageOverrideAggressionValue x850 y602 w50 Number, 50
    Gui, RageAdvanced:Add, Text, x910 y605, `%
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; КНОПКИ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, RageAdvanced:Add, Button, x10 y705 w180 h35 gRageAdvancedOK, ✓ Сохранить
    Gui, RageAdvanced:Add, Button, x200 y705 w180 h35 gRageAdvancedCancel, ✗ Отмена
    Gui, RageAdvanced:Add, Button, x390 y705 w200 h35 gRageAdvancedReset, 🔄 Сбросить всё
    Gui, RageAdvanced:Add, Button, x600 y705 w190 h35 gRageAdvancedPresets, 📋 Пресеты
    Gui, RageAdvanced:Add, Button, x800 y705 w190 h35 gRageAdvancedExport, 📤 Экспорт
    
    GuiControl, RageAdvanced:, RageDispatchEnabled, % rageDispatchEnabled
    GuiControl, RageAdvanced:, RageDispatchMessageCount, % rageDispatchMessageCount
    GuiControl, RageAdvanced:, RageDispatchTimeValue, % rageDispatchTimeValue
    GuiControl, RageAdvanced:ChooseString, RageDispatchTimeUnit, %rageDispatchTimeUnit%
    GuiControl, RageAdvanced:, RageAdvEnablePacketSize, % RageAdvEnablePacketSize
    GuiControl, RageAdvanced:, RageAdvBurstPacketSize, % RageAdvBurstPacketSize
    GuiControl, RageAdvanced:, RageAdvEnablePacketDelay, % RageAdvEnablePacketDelay
    GuiControl, RageAdvanced:, RageAdvBurstPacketDelay, % RageAdvBurstPacketDelay
    GuiControl, RageAdvanced:, RageAdvEnableThreads, % RageAdvEnableThreads
    GuiControl, RageAdvanced:, RageAdvBurstThreads, % RageAdvBurstThreads
    GuiControl, RageAdvanced:, RageAdvBurstStrategy1, % RageAdvBurstStrategy1
    GuiControl, RageAdvanced:, RageAdvBurstStrategy2, % RageAdvBurstStrategy2
    GuiControl, RageAdvanced:, RageAdvBurstStrategy3, % RageAdvBurstStrategy3
    GuiControl, RageAdvanced:, RageAdvBurstStrategy4, % RageAdvBurstStrategy4
    GuiControl, RageAdvanced:, RageBurstOptJitter, % RageBurstOptJitter
    GuiControl, RageAdvanced:, RageBurstJitterMin, % RageBurstJitterMin
    GuiControl, RageAdvanced:, RageBurstJitterMax, % RageBurstJitterMax
    GuiControl, RageAdvanced:, RageBurstOptRetry, % RageBurstOptRetry
    GuiControl, RageAdvanced:, RageBurstRetryCount, % RageBurstRetryCount
    GuiControl, RageAdvanced:, RageBurstRetryDelay, % RageBurstRetryDelay
    GuiControl, RageAdvanced:, RageBurstOptCooldown, % RageBurstOptCooldown
    GuiControl, RageAdvanced:, RageBurstCooldownEvery, % RageBurstCooldownEvery
    GuiControl, RageAdvanced:, RageBurstCooldownMs, % RageBurstCooldownMs
    GuiControl, RageAdvanced:, RageBurstOptWarmup, % RageBurstOptWarmup
    GuiControl, RageAdvanced:, RageBurstWarmupCount, % RageBurstWarmupCount
    GuiControl, RageAdvanced:, RageBurstWarmupStartMs, % RageBurstWarmupStartMs
    GuiControl, RageAdvanced:, RageBurstOptDedupe, % RageBurstOptDedupe
    GuiControl, RageAdvanced:, RageBurstDedupeAttempts, % RageBurstDedupeAttempts
    GuiControl, RageAdvanced:, RageBurstOptRandomCase, % RageBurstOptRandomCase
    GuiControl, RageAdvanced:, RageBurstRandomCaseChance, % RageBurstRandomCaseChance
    GuiControl, RageAdvanced:, RageBurstOptRandomPunct, % RageBurstOptRandomPunct
    GuiControl, RageAdvanced:, RageBurstRandomPunctChance, % RageBurstRandomPunctChance
    GuiControl, RageAdvanced:, RageBurstOptAdaptiveRate, % RageBurstOptAdaptiveRate
    GuiControl, RageAdvanced:, RageBurstRateLimit, % RageBurstRateLimit
    GuiControl, RageAdvanced:, RageBurstOptPrefixCounter, % RageBurstOptPrefixCounter
    GuiControl, RageAdvanced:ChooseString, RageBurstCounterFormat, %RageBurstCounterFormat%
    GuiControl, RageAdvanced:, RageBurstOptStats, % RageBurstOptStats
    GuiControl, RageAdvanced:, RageBurstStatsInterval, % RageBurstStatsInterval
    GuiControl, RageAdvanced:, RageBurstOptAutoRebuild, % RageBurstOptAutoRebuild
    GuiControl, RageAdvanced:, RageBurstOptPacketPause, % RageBurstOptPacketPause
    GuiControl, RageAdvanced:, RageBurstPacketSize2, % RageBurstPacketSize2
    GuiControl, RageAdvanced:, RageBurstPacketPauseMs, % RageBurstPacketPauseMs
    GuiControl, RageAdvanced:, RageBurstOptForceInstant, % RageBurstOptForceInstant
    GuiControl, RageAdvanced:, RageBurstForceThresholdMs, % RageBurstForceThresholdMs
    GuiControl, RageAdvanced:, RageBurstOptStrictUnique, % RageBurstOptStrictUnique
    GuiControl, RageAdvanced:, RageBurstUniqueAttempts, % RageBurstUniqueAttempts
    GuiControl, RageAdvanced:, RageBurstUniqueSuffix, % RageBurstUniqueSuffix
    Gosub, RageAdvancedToggleBurstControls
    Gosub, RageBurstRefreshTable
    Gosub, RageExploitRefreshTable
    Gosub, RageOverrideRefresh
    
    Gui, RageAdvanced:Show, w1000 h750, 🔥 Расширенные настройки Rage-режима
return

RageAdvancedOK:
    Gui, RageAdvanced:Submit, NoHide
    MsgBox, 64, Успех, Расширенные настройки Rage-режима сохранены!
    Gui, RageAdvanced:Destroy
return

RageAdvancedCancel:
    Gui, RageAdvanced:Destroy
return

RageAdvancedReset:
    MsgBox, 36, Подтверждение, Сбросить все расширенные настройки?
    IfMsgBox, Yes
    {
        MsgBox, 64, Успех, Все настройки сброшены!
    }
return

RageAdvancedPresets:
    MsgBox, 64, Пресеты, Функция пресетов будет добавлена в следующей версии!
return

RageAdvancedExport:
    MsgBox, 64, Экспорт, Функция экспорта будет добавлена в следующей версии!
return

; === НОВЫЕ ОБРАБОТЧИКИ ===
RageAdvSpeedChanged:
    GuiControlGet, val, RageAdvanced:, RageAdvSpeedSlider
    GuiControl, RageAdvanced:, RageAdvSpeed, %val%
return

RageExploitIntensityChanged:
    GuiControlGet, val, RageAdvanced:, RageExploitIntensity
    GuiControl, RageAdvanced:, RageExploitIntensityValue, %val%
    RefreshRageExploitsTable()
return

RageExploitChanged:
    Gui, RageAdvanced:Submit, NoHide
    RefreshRageExploitsTable()
return

RageExploitsListClick:
    if (A_GuiEvent = "DoubleClick")
        Gosub, RageExploitToggleSelected
return

RageExploitRefreshTable:
    RefreshRageExploitsTable()
return

RageExploitToggleSelected:
    Gui, RageAdvanced:Default
    Gui, ListView, RageExploitsList
    row := LV_GetNext()
    if (!row)
        return
    item := GetRageExploitMeta(row)
    if (!IsObject(item))
        return
    if (item.HasKey("custom")) {
        idx := item.customIndex
        rageCustomExploits[idx].enabled := !rageCustomExploits[idx].enabled
    } else {
        GuiControlGet, cur, RageAdvanced:, % item.varName
        GuiControl, RageAdvanced:, % item.varName, % (cur ? 0 : 1)
    }
    RefreshRageExploitsTable()
return

RageExploitAddCustom:
    InputBox, cName, Новый эксплойт, Название эксплойта:, , 340, 130
    if (ErrorLevel || cName = "")
        return
    InputBox, cType, Новый эксплойт, Тип (Ввод/Обход/Сеть/Память):, , 340, 130, , , , , Ввод
    if (ErrorLevel || cType = "")
        cType := "Ввод"
    rageCustomExploits.Push({name: cName, type: cType, enabled: true, eff: "60%", desc: "Пользовательский эксплойт"})
    RefreshRageExploitsTable()
return

RageExploitEditCustom:
    Gui, RageAdvanced:Default
    Gui, ListView, RageExploitsList
    row := LV_GetNext()
    if (!row)
        return
    item := GetRageExploitMeta(row)
    if (!IsObject(item) || !item.HasKey("custom"))
        return
    idx := item.customIndex
    old := rageCustomExploits[idx]
    InputBox, cName, Редактировать эксплойт, Название:, , 340, 130, , , , , % old.name
    if (ErrorLevel || cName = "")
        return
    InputBox, cType, Редактировать эксплойт, Тип:, , 340, 130, , , , , % old.type
    if (ErrorLevel || cType = "")
        cType := old.type
    rageCustomExploits[idx].name := cName
    rageCustomExploits[idx].type := cType
    RefreshRageExploitsTable()
return

RageExploitDeleteCustom:
    Gui, RageAdvanced:Default
    Gui, ListView, RageExploitsList
    row := LV_GetNext()
    if (!row)
        return
    item := GetRageExploitMeta(row)
    if (!IsObject(item) || !item.HasKey("custom"))
        return
    rageCustomExploits.RemoveAt(item.customIndex)
    RefreshRageExploitsTable()
return

RageOverrideChanged:
    Gui, RageAdvanced:Submit, NoHide
    if (RageOverrideAll) {
        GuiControl, RageAdvanced:, RageOverrideSpeed, 1
        GuiControl, RageAdvanced:, RageOverrideDelay, 1
        GuiControl, RageAdvanced:, RageOverrideRateLimit, 1
        GuiControl, RageAdvanced:, RageOverrideFloodProtection, 1
        GuiControl, RageAdvanced:, RageOverrideAntiSpam, 1
        GuiControl, RageAdvanced:, RageOverrideValidation, 1
        GuiControl, RageAdvanced:, RageOverrideSecurity, 1
        GuiControl, RageAdvanced:, RageOverrideDetection, 1
        GuiControl, RageAdvanced:, RageOverrideFilters, 1
        GuiControl, RageAdvanced:, RageOverrideLength, 1
        GuiControl, RageAdvanced:, RageOverrideFormat, 1
        GuiControl, RageAdvanced:, RageOverrideEncoding, 1
        GuiControl, RageAdvanced:, RageOverridePermissions, 1
        GuiControl, RageAdvanced:, RageOverrideTimeout, 1
        GuiControl, RageAdvanced:, RageOverrideQueue, 1
        GuiControl, RageAdvanced:, RageOverridePriority, 1
        GuiControl, RageAdvanced:, RageOverrideThrottle, 1
        GuiControl, RageAdvanced:, RageOverrideBackoff, 1
        GuiControl, RageAdvanced:, RageOverrideRetry, 1
    }
    RefreshRageOverrideTable()
return

RageOverrideEnableAll:
    GuiControl, RageAdvanced:, RageOverrideAll, 1
    Gosub, RageOverrideChanged
return

RageOverrideDisableAll:
    GuiControl, RageAdvanced:, RageOverrideAll, 0
    GuiControl, RageAdvanced:, RageOverrideSpeed, 0
    GuiControl, RageAdvanced:, RageOverrideDelay, 0
    GuiControl, RageAdvanced:, RageOverrideRateLimit, 0
    GuiControl, RageAdvanced:, RageOverrideFloodProtection, 0
    GuiControl, RageAdvanced:, RageOverrideAntiSpam, 0
    GuiControl, RageAdvanced:, RageOverrideValidation, 0
    GuiControl, RageAdvanced:, RageOverrideSecurity, 0
    GuiControl, RageAdvanced:, RageOverrideDetection, 0
    GuiControl, RageAdvanced:, RageOverrideFilters, 0
    GuiControl, RageAdvanced:, RageOverrideLength, 0
    GuiControl, RageAdvanced:, RageOverrideFormat, 0
    GuiControl, RageAdvanced:, RageOverrideEncoding, 0
    GuiControl, RageAdvanced:, RageOverridePermissions, 0
    GuiControl, RageAdvanced:, RageOverrideTimeout, 0
    GuiControl, RageAdvanced:, RageOverrideQueue, 0
    GuiControl, RageAdvanced:, RageOverridePriority, 0
    GuiControl, RageAdvanced:, RageOverrideThrottle, 0
    GuiControl, RageAdvanced:, RageOverrideBackoff, 0
    GuiControl, RageAdvanced:, RageOverrideRetry, 0
    RefreshRageOverrideTable()
return

RageOverrideRefresh:
    RefreshRageOverrideTable()
return

RageOverrideListClick:
    if (A_GuiEvent = "DoubleClick")
        Gosub, RageOverrideToggleSelected
return

RageOverrideToggleSelected:
    Gui, RageAdvanced:Default
    Gui, ListView, RageOverrideList
    row := LV_GetNext()
    if (!row)
        return
    item := GetRageOverrideMeta(row)
    if (!IsObject(item))
        return
    if (item.HasKey("custom")) {
        idx := item.customIndex
        rageCustomOverrides[idx].enabled := !rageCustomOverrides[idx].enabled
    } else {
        GuiControlGet, cur, RageAdvanced:, % item.varName
        GuiControl, RageAdvanced:, % item.varName, % (cur ? 0 : 1)
    }
    RefreshRageOverrideTable()
return

RageOverrideAddCustom:
    InputBox, oName, Новый Override, Название override-параметра:, , 340, 130
    if (ErrorLevel || oName = "")
        return
    InputBox, oOrig, Новый Override, Исходное значение:, , 340, 130, , , , , default
    if (ErrorLevel)
        oOrig := "default"
    InputBox, oValue, Новый Override, Override значение:, , 340, 130, , , , , forced
    if (ErrorLevel)
        oValue := "forced"
    rageCustomOverrides.Push({name: oName, enabled: true, original: oOrig, value: oValue, desc: "Пользовательский override"})
    RefreshRageOverrideTable()
return

RageOverrideEditCustom:
    Gui, RageAdvanced:Default
    Gui, ListView, RageOverrideList
    row := LV_GetNext()
    if (!row)
        return
    item := GetRageOverrideMeta(row)
    if (!IsObject(item) || !item.HasKey("custom"))
        return
    idx := item.customIndex
    old := rageCustomOverrides[idx]
    InputBox, oName, Редактировать Override, Название:, , 340, 130, , , , , % old.name
    if (ErrorLevel || oName = "")
        return
    InputBox, oOrig, Редактировать Override, Исходное значение:, , 340, 130, , , , , % old.original
    if (ErrorLevel)
        oOrig := old.original
    InputBox, oValue, Редактировать Override, Override значение:, , 340, 130, , , , , % old.value
    if (ErrorLevel)
        oValue := old.value
    rageCustomOverrides[idx].name := oName
    rageCustomOverrides[idx].original := oOrig
    rageCustomOverrides[idx].value := oValue
    RefreshRageOverrideTable()
return

RageOverrideDeleteCustom:
    Gui, RageAdvanced:Default
    Gui, ListView, RageOverrideList
    row := LV_GetNext()
    if (!row)
        return
    item := GetRageOverrideMeta(row)
    if (!IsObject(item) || !item.HasKey("custom"))
        return
    rageCustomOverrides.RemoveAt(item.customIndex)
    RefreshRageOverrideTable()
return

; ═══════════════════════════════════════════════════════════════════════════════
; ⚙️ НАСТРОЙКИ ЭКСПЛОИТОВ
; ═══════════════════════════════════════════════════════════════════════════════

OpenRageExploits:
    MsgBox, 64, Эксплоиты, Окно настроек эксплоитов будет добавлено в следующей версии!
return

; === ФУНКЦИЯ RAGE-ПЕЧАТИ ===
RageTypeText(text) {
    global rageModeEnabled, rageSpeed, rageNoDelay, rageInstantPaste
    global rageBypassDetection, rageRandomizeOrder, rageSpamMode, rageSpamCount
    global RageExploit1, RageExploit2, RageExploit3, RageExploit4, RageExploit5, RageExploit6, RageExploit7, RageExploit8, RageExploit9, RageExploit10, RageExploit11, RageExploit12
    global RageBypass2, RageBypass3, RageBypass9, RageOverrideAll, RageOverrideDelay, RageOverrideSpeed
    global RageSendText, RageSendRaw, RageSendInput, RageSendPlay, RageSendEvent, RageClipboard
    global stealthBlockReason
    global StealthModeEnabled
    global isTyping

    Gui, Submit, NoHide
    
    ; Получаем актуальные настройки и связываем их с Exploit/Override
    useClipboard := RageClipboard
    useSendRaw := RageSendRaw
    useSendInput := RageSendInput
    useSendPlay := RageSendPlay
    useSendEvent := RageSendEvent
    exploitFastSend := RageExploit3 || RageExploit4 || RageExploit5 || RageExploit6 || RageExploit8 || RageExploit9
    exploitKeyDelay := RageExploit1 || RageOverrideAll || RageOverrideDelay || RageOverrideSpeed
    noDelay := RageNoDelay || exploitKeyDelay
    spamMode := RageSpamMode
    spamCount := RageSpamCount
    useTimingRand := RageExploit11 || RageBypass9
    usePatternObf := RageExploit12 || RageExploit10
    
    ; Режим спама
    repeatTimes := spamMode ? spamCount : 1
    
    Loop, %repeatTimes% {
        outText := text
        if (usePatternObf) {
            outText := ApplyBurstRandomCase(outText, 25)
            outText := ApplyBurstRandomPunctuation(outText, 20)
        }

        outText := ApplyStealthMode(outText, "Rage")
        if (outText = "") {
            SB_SetText("Stealth: отправка отменена (" . stealthBlockReason . ")", 3)
            return false
        }

        ; Special tags (pause/time/rand/etc) are evaluated here.
        actions := ParseSpecialTagsToActions(outText)
        for ai, act in actions {
            if (!isTyping)
                break
            if (act.t = "pause") {
                ms := act.ms + 0
                if (ms > 0)
                    Sleep, %ms%
                continue
            }
            seg := act.v
            if (seg = "")
                continue
            seg := ApplyFinalTextStyle(seg)

            if (useClipboard) {
                ; Clipboard send is enabled only when explicitly selected in Rage send method UI.
                oldClip := ClipboardAll
                Clipboard :=
                Clipboard := seg
                Sleep, 5
                Send, ^v
                Sleep, 5
                Clipboard := oldClip
            } else if (useSendRaw) {
                if (exploitKeyDelay)
                    SetKeyDelay, -1, -1
                SendRaw, %seg%
            } else if (useSendInput) {
                if (exploitKeyDelay)
                    SetKeyDelay, -1, -1
                SendInput, {Text}%seg%
            } else if (useSendPlay) {
                if (exploitKeyDelay)
                    SetKeyDelay, -1, -1
                SendPlay, {Text}%seg%
            } else if (useSendEvent) {
                if (exploitKeyDelay)
                    SetKeyDelay, -1, -1
                SendEvent, {Text}%seg%
            } else if (exploitFastSend) {
                if (exploitKeyDelay)
                    SetKeyDelay, -1, -1
                chunkSize := 100
                Loop, % Ceil(StrLen(seg) / chunkSize) {
                    chunk := SubStr(seg, (A_Index - 1) * chunkSize + 1, chunkSize)
                    Send, {Text}%chunk%
                }
            } else {
                if (exploitKeyDelay)
                    SetKeyDelay, -1, -1
                if (noDelay) {
                    Send, {Text}%seg%
                } else {
                    effectiveSpeed := rageSpeed + 0
                    if (effectiveSpeed < 1)
                        effectiveSpeed := 1
                    delay := 1000 / effectiveSpeed
                    if (StealthModeEnabled && StealthOpt(53)) {
                        pct := Random(80, 120)
                        delay := delay * (pct / 100.0)
                    }
                    Loop, Parse, seg
                    {
                        Send, {Text}%A_LoopField%
                        if (delay >= 1)
                            Sleep, %delay%
                    }
                }
            }
        }
        
        if (useTimingRand) {
            Random, td, 0, 10
            Sleep, %td%
        }
        
        ; Bypass RateLimit / Flood может снижать паузы между спам-повторами
        if (spamMode && A_Index < repeatTimes) {
            if (!(RageBypass2 || RageBypass3 || RageOverrideAll || RageOverrideDelay))
                Sleep, 10
        }
    }
    
    return true
}

OpenStealthAdvanced:
    Gui, StealthAdvanced:New, +Owner1
    Gui, StealthAdvanced:Font, s9, Segoe UI
    Gui, StealthAdvanced:Add, Text, x12 y10 w760 h30 c0066CC, Stealth-режим: расширенные параметры (без обхода антиспам/антидетект систем)
    Gui, StealthAdvanced:Add, Tab3, x10 y45 w780 h560, Текст|Формат|Рандомизация|Безопасность

    Gui, StealthAdvanced:Tab, 1
    Gui, StealthAdvanced:Add, GroupBox, x20 y80 w360 h500, Текстовые параметры
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt1 x30 y105, Нормализация пробелов
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt2 x30 y125, Удаление лишних табов
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt3 x30 y145, Трим строк
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt4 x30 y165, Схлопывание пустых строк
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt5 x30 y185, Замена двойных пробелов
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt6 x30 y205, Фикс переносов CRLF/LF
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt7 x30 y225, Единый стиль кавычек
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt8 x30 y245, Единый стиль тире
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt9 x30 y265, Мягкая коррекция пунктуации
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt10 x30 y285, Авто-капитализация начала предложения
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt11 x30 y305, Сохранение регистра аббревиатур
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt12 x30 y325, Пропуск URL-замен
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt13 x30 y345, Пропуск email-замен
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt14 x30 y365, Защита markdown-блоков
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt15 x30 y385, Защита inline-кода

    Gui, StealthAdvanced:Add, GroupBox, x400 y80 w380 h500, Параметры контроля
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt16 x410 y105, Лог изменений
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt17 x410 y125, Превью перед отправкой
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt18 x410 y145, Подтверждение при длинном тексте
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt19 x410 y165, Ограничение длины строки
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt20 x410 y185, Ограничение длины сообщения
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt21 x410 y205, Блокировка пустых сообщений
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt22 x410 y225, Блокировка повторной отправки подряд
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt23 x410 y245, Пауза при совпадении шаблона
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt24 x410 y265, Проверка запрещенных фраз
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt25 x410 y285, Проверка минимального числа слов
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt26 x410 y305, Проверка максимального числа слов
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt27 x410 y325, Порог похожести (локальный)
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt28 x410 y345, Локальный анти-дубликат
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt29 x410 y365, Перестройка текста при полном совпадении
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt30 x410 y385, Нумерация сообщений (опция)

    Gui, StealthAdvanced:Tab, 2
    Gui, StealthAdvanced:Add, GroupBox, x20 y80 w760 h500, Форматирование
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt31 x30 y105, Случайный выбор префикса
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt32 x30 y125, Случайный выбор постфикса
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt33 x30 y145, Перестановка фраз по правилам
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt34 x30 y165, Ротация синонимов (локальный словарь)
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt35 x30 y185, Ротация шаблонов
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt39 x30 y265, Разделитель: точка
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt40 x30 y285, Разделитель: запятая
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt41 x30 y305, Разделитель: тире
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt42 x30 y325, Разделитель: перенос
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt43 x30 y345, Сокращения: мягкий режим
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt44 x30 y365, Сокращения: агрессивный режим
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt45 x30 y385, Стандартизация чисел

    Gui, StealthAdvanced:Tab, 3
    Gui, StealthAdvanced:Add, GroupBox, x20 y80 w760 h500, Рандомизация (видимая и безопасная)
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt46 x30 y105, Вариация знаков препинания
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt47 x30 y125, Вариация длины предложений
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt48 x30 y145, Вариация порядка блоков
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt49 x30 y165, Вариация вводных фраз
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt50 x30 y185, Вариация завершающих фраз
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt51 x30 y205, Вариация регистра (ограниченная)
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt52 x30 y225, Вариация длины пауз
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt53 x30 y245, Вариация скорости печати
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt54 x30 y265, Вариация разбиения на строки
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt55 x30 y285, Вариация словоформ

    Gui, StealthAdvanced:Tab, 4
    Gui, StealthAdvanced:Add, GroupBox, x20 y80 w760 h500, Безопасность и ограничения
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt56 x30 y105, Отключить невидимые символы (рекомендовано)
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt57 x30 y125, Отключить обфускацию
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt58 x30 y145, Отключить обходные пресеты
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt59 x30 y165, Отправлять только читаемый текст
    Gui, StealthAdvanced:Add, Checkbox, vStealthOpt60 x30 y185, Блокировать рискованные комбинации
    Gui, StealthAdvanced:Add, Text, x30 y220 w730 h60 cGray, Примечание: окно Stealth содержит параметры для локальной вариативности и качества текста.`nФункции обхода детекции, антиспама и скрытых символов намеренно не реализуются.

    Gui, StealthAdvanced:Tab
    Gui, StealthAdvanced:Add, Button, x540 y615 w110 h28 gStealthAdvancedOK, OK
    Gui, StealthAdvanced:Add, Button, x660 y615 w110 h28 gStealthAdvancedCancel, Отмена
    Gui, StealthAdvanced:Show, w800 h655, Stealth-режим: расширенные параметры
return

StealthAdvancedOK:
    Gui, StealthAdvanced:Submit
    Gui, StealthAdvanced:Destroy
    SB_SetText("Stealth-параметры сохранены", 1)
return

StealthAdvancedCancel:
    Gui, StealthAdvanced:Destroy
return

RageAdvancedToggleBurstControls:
    Gui, RageAdvanced:Submit, NoHide
    packetSizeState := RageAdvEnablePacketSize ? "Enable" : "Disable"
    packetDelayState := RageAdvEnablePacketDelay ? "Enable" : "Disable"
    threadsState := RageAdvEnableThreads ? "Enable" : "Disable"
    dispatchState := RageDispatchEnabled ? "Enable" : "Disable"
    
    GuiControl, RageAdvanced:%packetSizeState%, RageAdvBurstPacketSize
    GuiControl, RageAdvanced:%packetDelayState%, RageAdvBurstPacketDelay
    GuiControl, RageAdvanced:%threadsState%, RageAdvBurstThreads
    GuiControl, RageAdvanced:%dispatchState%, RageDispatchMessageCount
    GuiControl, RageAdvanced:%dispatchState%, RageDispatchTimeValue
    GuiControl, RageAdvanced:%dispatchState%, RageDispatchTimeUnit
    
    jitterState := RageBurstOptJitter ? "Enable" : "Disable"
    retryState := RageBurstOptRetry ? "Enable" : "Disable"
    cooldownState := RageBurstOptCooldown ? "Enable" : "Disable"
    warmupState := RageBurstOptWarmup ? "Enable" : "Disable"
    dedupeState := RageBurstOptDedupe ? "Enable" : "Disable"
    randCaseState := RageBurstOptRandomCase ? "Enable" : "Disable"
    randPunctState := RageBurstOptRandomPunct ? "Enable" : "Disable"
    rateState := RageBurstOptAdaptiveRate ? "Enable" : "Disable"
    counterState := RageBurstOptPrefixCounter ? "Enable" : "Disable"
    statsState := RageBurstOptStats ? "Enable" : "Disable"
    packetPauseState := RageBurstOptPacketPause ? "Enable" : "Disable"
    forceInstantState := RageBurstOptForceInstant ? "Enable" : "Disable"
    strictUniqueState := RageBurstOptStrictUnique ? "Enable" : "Disable"
    
    GuiControl, RageAdvanced:%jitterState%, RageBurstJitterMin
    GuiControl, RageAdvanced:%jitterState%, RageBurstJitterMax
    GuiControl, RageAdvanced:%retryState%, RageBurstRetryCount
    GuiControl, RageAdvanced:%retryState%, RageBurstRetryDelay
    GuiControl, RageAdvanced:%cooldownState%, RageBurstCooldownEvery
    GuiControl, RageAdvanced:%cooldownState%, RageBurstCooldownMs
    GuiControl, RageAdvanced:%warmupState%, RageBurstWarmupCount
    GuiControl, RageAdvanced:%warmupState%, RageBurstWarmupStartMs
    GuiControl, RageAdvanced:%dedupeState%, RageBurstDedupeAttempts
    GuiControl, RageAdvanced:%randCaseState%, RageBurstRandomCaseChance
    GuiControl, RageAdvanced:%randPunctState%, RageBurstRandomPunctChance
    GuiControl, RageAdvanced:%rateState%, RageBurstRateLimit
    GuiControl, RageAdvanced:%counterState%, RageBurstCounterFormat
    GuiControl, RageAdvanced:%statsState%, RageBurstStatsInterval
    GuiControl, RageAdvanced:%packetPauseState%, RageBurstPacketSize2
    GuiControl, RageAdvanced:%packetPauseState%, RageBurstPacketPauseMs
    GuiControl, RageAdvanced:%forceInstantState%, RageBurstForceThresholdMs
    GuiControl, RageAdvanced:%strictUniqueState%, RageBurstUniqueAttempts
    GuiControl, RageAdvanced:%strictUniqueState%, RageBurstUniqueSuffix
    
    RefreshRageBurstTable()
return

RageBurstTableClick:
    if (A_GuiEvent = "DoubleClick")
        Gosub, RageBurstEditSelected
return

RageBurstRefreshTable:
    RefreshRageBurstTable()
return

RageBurstToggleSelected:
    Gui, RageAdvanced:Default
    Gui, ListView, RageAdvBurstTable
    row := LV_GetNext()
    if (!row)
        return
    
    meta := GetRageBurstOptionMeta(row)
    if (!IsObject(meta))
        return
    
    GuiControlGet, curVal, RageAdvanced:, % meta.enable
    newVal := curVal ? 0 : 1
    GuiControl, RageAdvanced:, % meta.enable, %newVal%
    RefreshRageBurstTable()
return

RageBurstEditSelected:
    Gui, RageAdvanced:Default
    Gui, ListView, RageAdvBurstTable
    row := LV_GetNext()
    if (!row)
        return
    
    meta := GetRageBurstOptionMeta(row)
    if (!IsObject(meta))
        return
    
    if (meta.val1 != "") {
        GuiControlGet, current1, RageAdvanced:, % meta.val1
        title1 := "Burst: " . meta.name
        prompt1 := "Введите " . meta.p1 . ":"
        InputBox, newVal1, %title1%, %prompt1%, , 320, 130, , , , , %current1%
        if (!ErrorLevel)
            GuiControl, RageAdvanced:, % meta.val1, %newVal1%
    }
    
    if (meta.val2 != "") {
        GuiControlGet, current2, RageAdvanced:, % meta.val2
        title2 := "Burst: " . meta.name
        prompt2 := "Введите " . meta.p2 . ":"
        InputBox, newVal2, %title2%, %prompt2%, , 320, 130, , , , , %current2%
        if (!ErrorLevel)
            GuiControl, RageAdvanced:, % meta.val2, %newVal2%
    }
    
    RefreshRageBurstTable()
return

GetRageBurstOptionMeta(row) {
    if (row = 1)
        return ({name: "Джиттер задержки", enable: "RageBurstOptJitter", val1: "RageBurstJitterMin", val2: "RageBurstJitterMax", p1: "минимум (мс)", p2: "максимум (мс)", desc: "Случайное отклонение между сообщениями"})
    if (row = 2)
        return ({name: "Повтор при пустом сообщении", enable: "RageBurstOptRetry", val1: "RageBurstRetryCount", val2: "RageBurstRetryDelay", p1: "кол-во попыток", p2: "пауза (мс)", desc: "Повторная сборка и отправка"})
    if (row = 3)
        return ({name: "Пауза каждые N", enable: "RageBurstOptCooldown", val1: "RageBurstCooldownEvery", val2: "RageBurstCooldownMs", p1: "каждые N", p2: "пауза (мс)", desc: "Периодический сброс нагрузки"})
    if (row = 4)
        return ({name: "Прогрев скорости", enable: "RageBurstOptWarmup", val1: "RageBurstWarmupCount", val2: "RageBurstWarmupStartMs", p1: "сообщений", p2: "стартовая задержка", desc: "Плавный разгон"})
    if (row = 5)
        return ({name: "Анти-дубликат", enable: "RageBurstOptDedupe", val1: "RageBurstDedupeAttempts", val2: "", p1: "попытки", p2: "", desc: "Не отправлять одинаковое подряд"})
    if (row = 6)
        return ({name: "Случайный регистр", enable: "RageBurstOptRandomCase", val1: "RageBurstRandomCaseChance", val2: "", p1: "шанс %", p2: "", desc: "Меняет регистр перед отправкой"})
    if (row = 7)
        return ({name: "Случайная пунктуация", enable: "RageBurstOptRandomPunct", val1: "RageBurstRandomPunctChance", val2: "", p1: "шанс %", p2: "", desc: "Добавляет случайные знаки"})
    if (row = 8)
        return ({name: "Лимит сообщений/сек", enable: "RageBurstOptAdaptiveRate", val1: "RageBurstRateLimit", val2: "", p1: "лимит", p2: "", desc: "Ограничивает интенсивность"})
    if (row = 9)
        return ({name: "Префикс-счетчик", enable: "RageBurstOptPrefixCounter", val1: "RageBurstCounterFormat", val2: "", p1: "формат", p2: "", desc: "Добавляет номер сообщения"})
    if (row = 10)
        return ({name: "Живая статистика", enable: "RageBurstOptStats", val1: "RageBurstStatsInterval", val2: "", p1: "интервал", p2: "", desc: "Обновление статуса по прогрессу"})
    if (row = 11)
        return ({name: "Пересборка каждого", enable: "RageBurstOptAutoRebuild", val1: "", val2: "", p1: "", p2: "", desc: "Каждое сообщение пересобирается заново"})
    if (row = 12)
        return ({name: "Пакетная пауза", enable: "RageBurstOptPacketPause", val1: "RageBurstPacketSize2", val2: "RageBurstPacketPauseMs", p1: "размер пакета", p2: "пауза (мс)", desc: "Пауза после каждого пакета"})
    if (row = 13)
        return ({name: "Форс мгновенной отправки", enable: "RageBurstOptForceInstant", val1: "RageBurstForceThresholdMs", val2: "", p1: "порог (мс)", p2: "", desc: "Если задано слишком мало времени — отправка без пауз"})
    if (row = 14)
        return ({name: "Строгая уникальность", enable: "RageBurstOptStrictUnique", val1: "RageBurstUniqueAttempts", val2: "RageBurstUniqueSuffix", p1: "попытки", p2: "суффикс 0/1", desc: "Избегать повторов между сообщениями"})
    return ""
}

RefreshRageBurstTable() {
    Gui, RageAdvanced:Submit, NoHide
    Gui, RageAdvanced:Default
    Gui, ListView, RageAdvBurstTable
    LV_Delete()
    
    Loop, 14 {
        meta := GetRageBurstOptionMeta(A_Index)
        if (!IsObject(meta))
            continue
        
        GuiControlGet, e, RageAdvanced:, % meta.enable
        v1 := "-"
        v2 := "-"
        if (meta.val1 != "") {
            GuiControlGet, v1, RageAdvanced:, % meta.val1
        }
        if (meta.val2 != "") {
            GuiControlGet, v2, RageAdvanced:, % meta.val2
        }
        LV_Add("", meta.name, e ? "Да" : "Нет", v1, v2, meta.desc)
    }
}

GetRageExploitMeta(row) {
    global rageCustomExploits
    names := ["Zero KeyDelay Exploit","Clipboard Hijack","SendMessage Exploit","PostMessage Exploit","WM_CHAR Injection","WM_KEYDOWN Bypass","Unicode Injection","Raw Input Bypass","Hook Bypass","Anti-Detection Exploit","Timing Randomization","Pattern Obfuscation","Anti-Cheat Bypass","Rate Limit Bypass","Flood Protection Bypass","Captcha Bypass","Bot Detection Bypass","Fingerprint Spoofing","Behavior Mimicking","Human Pattern Simulation","Timing Jitter","Mouse Movement Simulation","Idle Time Injection","Multi-Window Switching"]
    vars := ["RageExploit1","RageExploit2","RageExploit3","RageExploit4","RageExploit5","RageExploit6","RageExploit7","RageExploit8","RageExploit9","RageExploit10","RageExploit11","RageExploit12","RageBypass1","RageBypass2","RageBypass3","RageBypass4","RageBypass5","RageBypass6","RageBypass7","RageBypass8","RageBypass9","RageBypass10","RageBypass11","RageBypass12"]
    types := ["Ввод","Ввод","Ввод","Ввод","Ввод","Ввод","Ввод","Ввод","Ввод","Ввод","Ввод","Ввод","Обход","Обход","Обход","Обход","Обход","Обход","Обход","Обход","Обход","Обход","Обход","Обход"]
    if (row <= names.Length())
        return ({name: names[row], varName: vars[row], type: types[row]})
    customIdx := row - names.Length()
    if (customIdx >= 1 && customIdx <= rageCustomExploits.Length())
        return ({custom: 1, customIndex: customIdx})
    return ""
}

RefreshRageExploitsTable() {
    global rageCustomExploits, RageExploitIntensityValue
    Gui, RageAdvanced:Submit, NoHide
    Gui, RageAdvanced:Default
    Gui, ListView, RageExploitsList
    LV_Delete()
    
    totalBase := 24
    intensity := RageExploitIntensityValue + 0
    if (intensity < 0)
        intensity := 0
    if (intensity > 100)
        intensity := 100
    
    Loop, %totalBase% {
        meta := GetRageExploitMeta(A_Index)
        GuiControlGet, enabled, RageAdvanced:, % meta.varName
        eff := enabled ? intensity . "%" : "0%"
        status := enabled ? "Активен" : "Неактивен"
        LV_Add("", meta.name, meta.type, status, eff, enabled ? "Применяется в Rage/Burst" : "Выключен")
    }
    
    for i, item in rageCustomExploits {
        status := item.enabled ? "Активен" : "Неактивен"
        LV_Add("", item.name, item.type, status, item.eff, item.desc)
    }
}

GetRageOverrideMeta(row) {
    global rageCustomOverrides
    names := ["Скорость","Задержки","Rate Limit","Flood Protection","Anti-Spam","Валидация","Безопасность","Детекция","Фильтры","Ограничения длины","Форматирование","Кодировка","Права доступа","Таймауты","Очередь","Приоритет","Throttling","Backoff","Retry logic"]
    vars := ["RageOverrideSpeed","RageOverrideDelay","RageOverrideRateLimit","RageOverrideFloodProtection","RageOverrideAntiSpam","RageOverrideValidation","RageOverrideSecurity","RageOverrideDetection","RageOverrideFilters","RageOverrideLength","RageOverrideFormat","RageOverrideEncoding","RageOverridePermissions","RageOverrideTimeout","RageOverrideQueue","RageOverridePriority","RageOverrideThrottle","RageOverrideBackoff","RageOverrideRetry"]
    orig := ["По настройкам","По настройкам","По настройкам","По настройкам","По настройкам","Активна","Активна","Активна","Активны","С лимитом","Стандарт","UTF-8","Проверка","Стандарт","FIFO","Нормальный","Включен","Включен","Включен"]
    over := ["Максимум","0 мс","Без лимита","Отключено","Отключено","Отключена","Отключена","Отключена","Отключены","Без лимита","Игнор","Любая","Игнор","Игнор","Игнор","Игнор","Игнор","Игнор","Игнор"]
    if (row <= names.Length())
        return ({name: names[row], varName: vars[row], original: orig[row], value: over[row], desc: "Override системного ограничения"})
    customIdx := row - names.Length()
    if (customIdx >= 1 && customIdx <= rageCustomOverrides.Length())
        return ({custom: 1, customIndex: customIdx})
    return ""
}

RefreshRageOverrideTable() {
    global rageCustomOverrides
    Gui, RageAdvanced:Submit, NoHide
    Gui, RageAdvanced:Default
    Gui, ListView, RageOverrideList
    LV_Delete()
    
    totalBase := 19
    Loop, %totalBase% {
        meta := GetRageOverrideMeta(A_Index)
        GuiControlGet, enabled, RageAdvanced:, % meta.varName
        status := enabled ? "Включен" : "Выключен"
        LV_Add("", meta.name, status, meta.original, meta.value, meta.desc)
    }
    
    for i, item in rageCustomOverrides {
        status := item.enabled ? "Включен" : "Выключен"
        LV_Add("", item.name, status, item.original, item.value, item.desc)
    }
}

BuildRageMessageText() {
    global TypeText, RageWorkModeNormal, RageWorkModeGenerator, RageWorkModeHybrid
    global genCurrentTemplate, genCurrentCategory, genCurrentSubcategory
    
    baseText := ""
    if (RageWorkModeGenerator) {
        if (genCurrentTemplate != "" && genCurrentCategory != "" && genCurrentSubcategory != "")
            baseText := GenerateTextNew()
        if (baseText = "")
            baseText := GenerateFromTemplate()
    } else if (RageWorkModeHybrid) {
        genPart := ""
        if (genCurrentTemplate != "" && genCurrentCategory != "" && genCurrentSubcategory != "")
            genPart := GenerateTextNew()
        if (genPart = "")
            genPart := GenerateFromTemplate()
        if (TypeText != "" && genPart != "")
            baseText := TypeText . "`n" . genPart
        else if (TypeText != "")
            baseText := TypeText
        else
            baseText := genPart
    } else {
        baseText := TypeText
    }
    
    return ApplyMainPrintLimits(baseText)
}

ApplyMainPrintLimits(sourceText) {
    global PrintLimitType, PrintWordLimit, PrintLineLimit, RageOverrideLength, RageOverrideAll
    
    sourceText := Trim(sourceText, "`r`n`t ")
    if (sourceText = "")
        return ""
    
    if (RageOverrideAll || RageOverrideLength)
        return sourceText
    
    if (PrintLimitType = 2 && PrintWordLimit > 0) {
        ; Для лимита по словам сначала перемешиваем строки,
        ; чтобы каждый цикл давал новый набор слов.
        shuffledText := ShuffleTextLinesRandom(sourceText)
        wordsRaw := StrSplit(shuffledText, [" ", "`n", "`r", "`t"])
        words := []
        for i, w in wordsRaw {
            w := Trim(w)
            if (w != "")
                words.Push(w)
        }
        if (words.Length() = 0)
            return ""
        
        outWords := ""
        Loop, % Min(PrintWordLimit, words.Length()) {
            outWords .= (A_Index > 1 ? " " : "") . words[A_Index]
        }
        return outWords
    }
    
    if (PrintLimitType = 3 && PrintLineLimit > 0) {
        linesRaw := StrSplit(sourceText, "`n", "`r")
        lines := []
        for i, ln in linesRaw {
            ln := Trim(ln)
            if (ln != "")
                lines.Push(ln)
        }
        if (lines.Length() = 0)
            return ""
        
        picked := []
        used := {}
        usedCount := 0
        Loop, % Min(PrintLineLimit, lines.Length()) {
            Random, idx, 1, % lines.Length()
            while (used.HasKey(idx)) {
                Random, idx, 1, % lines.Length()
            }
            if (!used.HasKey(idx)) {
                used[idx] := 1
                usedCount++
            }
            picked.Push(lines[idx])
        }
        
        result := ""
        for i, ln in picked
            result .= (i > 1 ? " " : "") . ln
        return result
    }
    
    return sourceText
}

ApplyBurstRandomCase(text, chancePercent) {
    if (text = "")
        return text
    
    chance := chancePercent + 0
    if (chance < 1)
        return text
    if (chance > 100)
        chance := 100
    
    result := ""
    Loop, Parse, text
    {
        ch := A_LoopField
        if (RegExMatch(ch, "[A-Za-zА-Яа-яЁё]")) {
            Random, r, 1, 100
            if (r <= chance) {
                Random, mode, 1, 2
                if (mode = 1)
                    StringUpper, ch, ch
                else
                    StringLower, ch, ch
            }
        }
        result .= ch
    }
    return result
}

ApplyBurstRandomPunctuation(text, chancePercent) {
    chance := chancePercent + 0
    if (chance < 1)
        return text
    if (chance > 100)
        chance := 100
    
    Random, r, 1, 100
    if (r <= chance)
        return AddRandomPunctuation(text)
    return text
}

ApplyBurstCounterPrefix(text, msgNum, formatStyle) {
    prefix := ""
    if (formatStyle = "(#n)")
        prefix := "(#" . msgNum . ") "
    else if (formatStyle = "<n>")
        prefix := "<" . msgNum . "> "
    else if (formatStyle = "n:")
        prefix := msgNum . ": "
    else
        prefix := "[#" . msgNum . "] "
    
    return prefix . text
}

ShuffleTextLinesRandom(text) {
    linesRaw := StrSplit(text, "`n", "`r")
    lines := []
    
    for i, ln in linesRaw {
        ln := Trim(ln)
        if (ln != "")
            lines.Push(ln)
    }
    
    if (lines.Length() <= 1)
        return text
    
    ; Fisher-Yates
    Loop, % lines.Length() {
        Random, j, %A_Index%, % lines.Length()
        temp := lines[A_Index]
        lines[A_Index] := lines[j]
        lines[j] := temp
    }
    
    result := ""
    for i, ln in lines
        result .= (i > 1 ? "`n" : "") . ln
    
    return result
}

RageDispatchToMs(timeValue, timeUnit) {
    ms := timeValue + 0
    if (ms < 0)
        ms := 0
    
    if (timeUnit = "Миллисекунды")
        return ms
    else if (timeUnit = "Секунды")
        return ms * 1000
    else if (timeUnit = "Минуты")
        return ms * 60000
    else if (timeUnit = "Часы")
        return ms * 3600000
    return ms
}

; ============================================
; === ПЕЧАТЬ ПО БИНДАМ ОБРАБОТЧИКИ ===
; ============================================

AddBindTemplate:
    Gui, BindTemplateAdd:New, +Owner1
    Gui, BindTemplateAdd:Font, s10, Segoe UI
    Gui, BindTemplateAdd:Color, White
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; 📝 ЗАГОЛОВОК
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, BindTemplateAdd:Add, Text, x15 y10 w370 h25 c0066CC Center, ➕ ДОБАВИТЬ ШАБЛОН БИНДА
    Gui, BindTemplateAdd:Font, s9, Segoe UI
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ⌨️ ГОРЯЧАЯ КЛАВИША (С ЗАХВАТОМ)
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, BindTemplateAdd:Add, GroupBox, x10 y40 w380 h60, ⌨️ Горячая клавиша
    Gui, BindTemplateAdd:Add, Edit, vBindHotkey x20 y60 w250 ReadOnly
    Gui, BindTemplateAdd:Add, Button, vBindCaptureBtn x280 y58 w100 h24 gCaptureBindHotkey, 🎯 Захват
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; 📄 ТЕКСТ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, BindTemplateAdd:Add, GroupBox, x10 y105 w380 h90, 📄 Текст шаблона
    Gui, BindTemplateAdd:Add, Edit, vBindText x20 y125 w360 h60 Multi
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; ⚙️ НАСТРОЙКИ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, BindTemplateAdd:Add, GroupBox, x10 y200 w185 h110, ⚡ Скорость
    Gui, BindTemplateAdd:Add, Text, x20 y220, Тип:
    Gui, BindTemplateAdd:Add, DropDownList, vBindSpeedType x60 y217 w125, Букв в секунду|Слов в минуту|Мгновенно|Буфер обмена
    Gui, BindTemplateAdd:Add, Text, x20 y250, Значение:
    Gui, BindTemplateAdd:Add, Edit, vBindSpeedValue x80 y247 w60 Number, 50
    
    Gui, BindTemplateAdd:Add, GroupBox, x205 y200 w185 h110, 🔤 Форматирование
    Gui, BindTemplateAdd:Add, Text, x215 y220, Регистр:
    Gui, BindTemplateAdd:Add, DropDownList, vBindCase x270 y217 w110, Обычный|ВЕРХНИЙ|нижний|Первая Заглавная
    Gui, BindTemplateAdd:Add, Text, x215 y250, Ошибки:
    Gui, BindTemplateAdd:Add, DropDownList, vBindErrors x270 y247 w110, Нет|Низкий|Средний|Высокий
    
    ; ═══════════════════════════════════════════════════════════════════════════════
    ; 🔘 КНОПКИ
    ; ═══════════════════════════════════════════════════════════════════════════════
    Gui, BindTemplateAdd:Add, Button, x10 y320 w185 h30 gBindTemplateSave, ✓ Сохранить
    Gui, BindTemplateAdd:Add, Button, x205 y320 w185 h30 gBindTemplateCancel, ✗ Отмена
    
    Gui, BindTemplateAdd:Show, w400 h365, ➕ Добавить шаблон бинда
return

CaptureBindHotkey:
    global isCapturingHotkey, capturedHotkey, captureTargetControl
    isCapturingHotkey := true
    capturedHotkey := ""
    captureTargetControl := "BindHotkey"
    GuiControl, BindTemplateAdd:, BindCaptureBtn, ⏳ Ждём...
    GuiControl, BindTemplateAdd:, BindHotkey, Нажмите клавишу...
    SetTimer, CaptureBindKeyboardInput, 50
return

CaptureBindKeyboardInput:
    global isCapturingHotkey, capturedHotkey, captureTargetControl
    
    if (!isCapturingHotkey) {
        SetTimer, CaptureBindKeyboardInput, Off
        return
    }
    
    ; Проверяем модификаторы
    mods := ""
    if GetKeyState("Ctrl", "P")
        mods .= "^"
    if GetKeyState("Alt", "P")
        mods .= "!"
    if GetKeyState("Shift", "P")
        mods .= "+"
    if GetKeyState("LWin", "P") || GetKeyState("RWin", "P")
        mods .= "#"
    
    ; Проверяем основные клавиши
    keyList := "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z"
    keyList .= ",0,1,2,3,4,5,6,7,8,9"
    keyList .= ",F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,F11,F12"
    keyList .= ",Space,Enter,Tab,Escape,Backspace,Delete,Insert,Home,End,PgUp,PgDn"
    keyList .= ",Up,Down,Left,Right"
    keyList .= ",Numpad0,Numpad1,Numpad2,Numpad3,Numpad4,Numpad5,Numpad6,Numpad7,Numpad8,Numpad9"
    
    Loop, Parse, keyList, `,
    {
        if GetKeyState(A_LoopField, "P") {
            capturedHotkey := mods . A_LoopField
            isCapturingHotkey := false
            SetTimer, CaptureBindKeyboardInput, Off
            
            GuiControl, BindTemplateAdd:, BindHotkey, %capturedHotkey%
            GuiControl, BindTemplateAdd:, BindCaptureBtn, 🎯 Захват
            return
        }
    }
return

BindTemplateSave:
    Gui, BindTemplateAdd:Submit
    if (BindHotkey = "" || BindText = "") {
        MsgBox, 48, Ошибка, Заполните горячую клавишу и текст!
        return
    }
    
    global bindTemplates
    if (!bindTemplates)
        bindTemplates := []
    
    ; Добавляем шаблон
    bindTemplates.Push({hotkey: BindHotkey, text: BindText, speedType: BindSpeedType, speedValue: BindSpeedValue, textCase: BindCase, errorLevel: BindErrors, enabled: true})
    
    ; Обновляем ListView
    Gui, 1:Default
    Gui, 1:ListView, BindTemplatesList
    status := "Вкл"
    LV_Add("", BindHotkey, BindText, BindSpeedType . " " . BindSpeedValue, BindCase, BindErrors, status)
    
    ; Регистрируем хоткей
    RegisterBindHotkey(bindTemplates.Length())
    
    Gui, BindTemplateAdd:Destroy
    SB_SetText("Шаблон бинда добавлен: " . BindHotkey, 1)
return

BindTemplateCancel:
BindTemplateAddGuiClose:
    Gui, BindTemplateAdd:Destroy
return

EditBindTemplate:
    Gui, 1:Default
    Gui, 1:ListView, BindTemplatesList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите шаблон для редактирования!
        return
    }
    
    global bindTemplates
    item := bindTemplates[row]
    
    Gui, BindTemplateEdit:New, +Owner1
    Gui, BindTemplateEdit:Font, s9, Segoe UI
    Gui, BindTemplateEdit:Add, Text, x10 y10, Горячая клавиша:
    Gui, BindTemplateEdit:Add, Hotkey, vBindHotkeyEdit x120 y7 w150, % item.hotkey
    Gui, BindTemplateEdit:Add, Text, x10 y40, Текст шаблона:
    Gui, BindTemplateEdit:Add, Edit, vBindTextEdit x10 y60 w350 h60, % item.text
    Gui, BindTemplateEdit:Add, Text, x10 y130, Тип скорости:
    Gui, BindTemplateEdit:Add, DropDownList, vBindSpeedTypeEdit x100 y127 w170, Букв в секунду|Слов в минуту|Мгновенно|Буфер обмена
    GuiControl, BindTemplateEdit:ChooseString, BindSpeedTypeEdit, % item.speedType
    Gui, BindTemplateEdit:Add, Text, x10 y160, Скорость:
    Gui, BindTemplateEdit:Add, Edit, vBindSpeedValueEdit x100 y157 w80 Number, % item.speedValue
    Gui, BindTemplateEdit:Add, Text, x10 y190, Регистр:
    Gui, BindTemplateEdit:Add, DropDownList, vBindCaseEdit x100 y187 w170, Обычный|ВЕРХНИЙ|нижний|Первая Заглавная
    GuiControl, BindTemplateEdit:ChooseString, BindCaseEdit, % item.textCase
    Gui, BindTemplateEdit:Add, Text, x10 y220, Ошибки:
    Gui, BindTemplateEdit:Add, DropDownList, vBindErrorsEdit x100 y217 w170, Нет|Низкий|Средний|Высокий
    GuiControl, BindTemplateEdit:ChooseString, BindErrorsEdit, % item.errorLevel
    Gui, BindTemplateEdit:Add, Button, x10 y260 w170 gBindTemplateUpdate, ✓ Обновить
    Gui, BindTemplateEdit:Add, Button, x190 y260 w170 gBindTemplateEditCancel, ✗ Отмена
    
    global editBindRow := row
    Gui, BindTemplateEdit:Show, w370 h300, Редактировать шаблон бинда
return

BindTemplateUpdate:
    Gui, BindTemplateEdit:Submit
    global bindTemplates, editBindRow
    
    if (BindHotkeyEdit = "" || BindTextEdit = "") {
        MsgBox, 48, Ошибка, Заполните горячую клавишу и текст!
        return
    }
    
    ; Отключаем старый хоткей
    oldHotkey := bindTemplates[editBindRow].hotkey
    try Hotkey, %oldHotkey%, Off
    
    ; Обновляем данные
    bindTemplates[editBindRow] := {hotkey: BindHotkeyEdit, text: BindTextEdit, speedType: BindSpeedTypeEdit, speedValue: BindSpeedValueEdit, textCase: BindCaseEdit, errorLevel: BindErrorsEdit, enabled: true}
    
    ; Обновляем ListView
    Gui, 1:Default
    Gui, 1:ListView, BindTemplatesList
    LV_Modify(editBindRow, "", BindHotkeyEdit, BindTextEdit, BindSpeedTypeEdit . " " . BindSpeedValueEdit, BindCaseEdit, BindErrorsEdit, "Вкл")
    
    ; Регистрируем новый хоткей
    RegisterBindHotkey(editBindRow)
    
    Gui, BindTemplateEdit:Destroy
    SB_SetText("Шаблон бинда обновлён", 1)
return

BindTemplateEditCancel:
BindTemplateEditGuiClose:
    Gui, BindTemplateEdit:Destroy
return

DeleteBindTemplate:
    Gui, 1:Default
    Gui, 1:ListView, BindTemplatesList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите шаблон для удаления!
        return
    }
    
    global bindTemplates
    
    ; Отключаем хоткей
    oldHotkey := bindTemplates[row].hotkey
    try Hotkey, %oldHotkey%, Off
    
    ; Удаляем из массива и ListView
    bindTemplates.RemoveAt(row)
    LV_Delete(row)
    
    SB_SetText("Шаблон бинда удалён", 1)
return

ToggleBindTemplate:
    Gui, 1:Default
    Gui, 1:ListView, BindTemplatesList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите шаблон!
        return
    }
    
    global bindTemplates
    item := bindTemplates[row]
    item.enabled := !item.enabled
    bindTemplates[row] := item
    
    status := item.enabled ? "Вкл" : "Выкл"
    LV_Modify(row, "Col6", status)
    
    ; Включаем/выключаем хоткей
    hk := item.hotkey
    if (item.enabled) {
        RegisterBindHotkey(row)
    } else {
        try Hotkey, %hk%, Off
    }
    
    SB_SetText("Статус бинда: " . status, 1)
return

ClearBindTemplates:
    MsgBox, 36, Подтверждение, Удалить все шаблоны биндов?
    IfMsgBox, No
        return
    
    global bindTemplates
    
    ; Отключаем все хоткеи
    for i, item in bindTemplates {
        try Hotkey, % item.hotkey, Off
    }
    
    bindTemplates := []
    
    Gui, 1:Default
    Gui, 1:ListView, BindTemplatesList
    LV_Delete()
    
    SB_SetText("Все шаблоны биндов удалены", 1)
return

TestBindTemplate:
    Gui, 1:Default
    Gui, 1:ListView, BindTemplatesList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите шаблон для теста!
        return
    }
    
    global bindTemplates
    item := bindTemplates[row]
    itemText := item.text
    
    MsgBox, 64, Тест бинда, Через 2 секунды будет введён текст:`n`n%itemText%`n`nПереключитесь на нужное окно!
    Sleep, 2000
    
    ExecuteBindTemplate(row)
return

ImportBindTemplates:
    FileSelectFile, importFile, 3,, Выберите файл для импорта, Текстовые файлы (*.txt)
    if (importFile = "")
        return
    
    FileRead, content, %importFile%
    if (ErrorLevel) {
        MsgBox, 16, Ошибка, Не удалось прочитать файл!
        return
    }
    
    ; Формат: hotkey|text|speedType|speedValue|case|errors
    global bindTemplates
    if (!bindTemplates)
        bindTemplates := []
    
    imported := 0
    Loop, Parse, content, `n, `r
    {
        if (A_LoopField = "")
            continue
        parts := StrSplit(A_LoopField, "|")
        if (parts.Length() >= 6) {
            bindTemplates.Push({hotkey: parts[1], text: parts[2], speedType: parts[3], speedValue: parts[4], textCase: parts[5], errorLevel: parts[6], enabled: true})
            
            Gui, 1:Default
            Gui, 1:ListView, BindTemplatesList
            LV_Add("", parts[1], parts[2], parts[3] . " " . parts[4], parts[5], parts[6], "Вкл")
            
            RegisterBindHotkey(bindTemplates.Length())
            imported++
        }
    }
    
    SB_SetText("Импортировано шаблонов: " . imported, 1)
return

; === РЕГИСТРАЦИЯ ХОТКЕЯ БИНДА ===
RegisterBindHotkey(index) {
    global bindTemplates
    item := bindTemplates[index]
    hk := item.hotkey
    
    ; Создаём функцию-обработчик
    fn := Func("ExecuteBindTemplate").Bind(index)
    try Hotkey, %hk%, %fn%, On
}

; === ВЫПОЛНЕНИЕ ШАБЛОНА БИНДА ===
ExecuteBindTemplate(index) {
    global bindTemplates, isTyping
    
    if (isTyping)
        return
    
    item := bindTemplates[index]
    if (!item.enabled)
        return
    
    text := item.text
    
    ; Применяем регистр
    if (item.textCase = "ВЕРХНИЙ") {
        StringUpper, text, text
    } else if (item.textCase = "нижний") {
        StringLower, text, text
    } else if (item.textCase = "Первая Заглавная") {
        StringLower, text, text
        text := RegExReplace(text, "(^|[.!?]\s*)(\w)", "$1$U2")
    }
    
    ; Применяем ошибки
    if (item.errorLevel != "Нет") {
        text := ApplyBindErrors(text, item.errorLevel)
    }
    
    ; Печатаем (с поддержкой спец-меток и ускорения)
    mult := GetSpeedMultiplierNum()
    useClipboard := (item.speedType = "Мгновенно" || item.speedType = "Буфер обмена")
    charDelay := 0
    if (!useClipboard) {
        speed := item.speedValue + 0
        if (speed < 1)
            speed := 1
        if (item.speedType = "Слов в минуту") {
            charDelay := Floor((60 / (speed * mult * 5)) * 1000)
        } else {
            charDelay := Floor(1000 / (speed * mult))
        }
    }
    SendTextWithSpecialTags(text, useClipboard, charDelay, mult)
}

; === ПРИМЕНЕНИЕ ОШИБОК К ТЕКСТУ БИНДА ===
ApplyBindErrors(text, level) {
    if (level = "Низкий")
        errorChance := 2
    else if (level = "Средний")
        errorChance := 5
    else if (level = "Высокий")
        errorChance := 10
    else
        return text
    
    result := ""
    Loop, Parse, text
    {
        char := A_LoopField
        Random, roll, 1, 100
        if (roll <= errorChance && RegExMatch(char, "[а-яА-Яa-zA-Z]")) {
            ; Генерируем опечатку
            char := GetTypoChar(char)
        }
        result .= char
    }
    return result
}


; ============================================
; === УСКОРЕНИЕ / НАСТРОЙКИ СКОРОСТИ ===
; ============================================

OpenAccelerationAdvanced:
    global accelCfgRowKey
    accelCfgRowKey := {}

    Gui, AccelSettings:New, +Owner1 +Resize +MinSize900x600
    Gui, AccelSettings:Font, s10, Segoe UI
    Gui, AccelSettings:Color, White
    Gui, AccelSettings:Add, Text, x10 y10 w880 h28 c0066CC Center, ⚙ Ускорение: расширенные параметры (100+)
    Gui, AccelSettings:Font, s9, Segoe UI
    Gui, AccelSettings:Add, Text, x10 y45, Поиск:
    Gui, AccelSettings:Add, Edit, vAccelCfgSearch x55 y42 w300 gAccelCfgFilter
    Gui, AccelSettings:Add, Text, x370 y45, Группа:
    Gui, AccelSettings:Add, DropDownList, vAccelCfgGroup x420 y42 w160 gAccelCfgFilter, Все|Общее|SendInput|SendEvent|SendPlay|Буфер
    GuiControl, AccelSettings:Choose, AccelCfgGroup, 1

    Gui, AccelSettings:Add, ListView, vAccelCfgList x10 y75 w880 h455 Grid, Параметр|Значение|Описание
    LV_ModifyCol(1, 320), LV_ModifyCol(2, 130), LV_ModifyCol(3, 410)

    Gui, AccelSettings:Add, Button, x10 y540 w120 h30 gAccelCfgEdit, ✏️ Изменить
    Gui, AccelSettings:Add, Button, x140 y540 w120 h30 gAccelCfgToggle, 🔁 0/1
    Gui, AccelSettings:Add, Button, x270 y540 w120 h30 gAccelCfgResetSel, ♻️ Сброс
    Gui, AccelSettings:Add, Button, x400 y540 w150 h30 gAccelCfgResetAll, ♻️ Сбросить все
    Gui, AccelSettings:Add, Button, x670 y540 w105 h30 gAccelCfgSave, 💾 OK
    Gui, AccelSettings:Add, Button, x785 y540 w105 h30 gAccelCfgCancel, ✗ Отмена

    Gosub, AccelCfgFilter
    Gui, AccelSettings:Show, w900 h600, ⚙ Ускорение
return

AccelCfgFilter:
    global speedCfgDefs, speedCfg, accelCfgRowKey
    Gui, AccelSettings:Default
    Gui, ListView, AccelCfgList
    LV_Delete()
    accelCfgRowKey := {}

    GuiControlGet, q, AccelSettings:, AccelCfgSearch
    GuiControlGet, gtxt, AccelSettings:, AccelCfgGroup
    q := Trim(q)
    ql := Format("{:L}", q)

    grp := ""
    if (gtxt = "Общее")
        grp := "common"
    else if (gtxt = "SendInput")
        grp := "input"
    else if (gtxt = "SendEvent")
        grp := "event"
    else if (gtxt = "SendPlay")
        grp := "play"
    else if (gtxt = "Буфер")
        grp := "clip"

    for i, d in speedCfgDefs {
        if (grp != "" && d.group != grp)
            continue
        hay := Format("{:L}", d.key . " " . d.label . " " . d.desc)
        if (ql != "" && !InStr(hay, ql))
            continue
        val := speedCfg[d.key]
        showVal := val
        if (showVal = "") {
            showVal := (d.group = "common") ? d.def : "—"
        }
        row := LV_Add("", d.label, showVal, d.desc)
        accelCfgRowKey[row] := d.key
    }
return

AccelCfgEdit:
    global accelCfgRowKey, speedCfg
    Gui, AccelSettings:Default
    Gui, ListView, AccelCfgList
    row := LV_GetNext()
    if (!row)
        return
    key := accelCfgRowKey[row]
    d := SpeedCfgDefByKey(key)
    cur := speedCfg[key]
    InputBox, newVal, Параметр ускорения, % "Введите значение для:`n" . d.label . "`n`nПусто = наследовать (для групп кроме 'Общее')", , 520, 180, , , , , %cur%
    if (ErrorLevel)
        return
    newVal := Trim(newVal)
    if (d.group = "common" && newVal = "")
        newVal := d.def

    if (newVal != "") {
        if (d.type = "bool") {
            if !(newVal = "0" || newVal = "1" || newVal = "true" || newVal = "false" || newVal = "True" || newVal = "False") {
                MsgBox, 48, Ошибка, Для булевого параметра используйте 0/1 или true/false.
                return
            }
            if (newVal = "true" || newVal = "True")
                newVal := 1
            else if (newVal = "false" || newVal = "False")
                newVal := 0
        } else if (d.type = "int") {
            if !RegExMatch(newVal, "^-?\\d+$") {
                MsgBox, 48, Ошибка, Нужно целое число.
                return
            }
        } else if (d.type = "float") {
            if !RegExMatch(newVal, "^-?\\d+(?:\\.\\d+)?$") {
                MsgBox, 48, Ошибка, Нужно число (дробное через точку).
                return
            }
        }
    }

    speedCfg[key] := newVal
    d2 := SpeedCfgDefByKey(key)
    showVal := speedCfg[key]
    if (showVal = "")
        showVal := (d2.group = "common") ? d2.def : "—"
    LV_Modify(row, "", d2.label, showVal, d2.desc)
return

AccelCfgToggle:
    global accelCfgRowKey, speedCfg
    Gui, AccelSettings:Default
    Gui, ListView, AccelCfgList
    row := LV_GetNext()
    if (!row)
        return
    key := accelCfgRowKey[row]
    d := SpeedCfgDefByKey(key)
    if (d.type != "bool")
        return
    cur := speedCfg[key]
    if (cur = "")
        cur := SpeedCfgEff(d.group, d.name)
    speedCfg[key] := (cur = 1 || cur = "1") ? 0 : 1
    Gosub, AccelCfgFilter
return

AccelCfgResetSel:
    global accelCfgRowKey, speedCfg
    Gui, AccelSettings:Default
    Gui, ListView, AccelCfgList
    row := LV_GetNext()
    if (!row)
        return
    key := accelCfgRowKey[row]
    d := SpeedCfgDefByKey(key)
    speedCfg[key] := (d.group = "common") ? d.def : ""
    Gosub, AccelCfgFilter
return

AccelCfgResetAll:
    SpeedCfgResetAll()
    Gosub, AccelCfgFilter
return

AccelCfgSave:
    SpeedCfgSave()
    Gui, AccelSettings:Destroy
    SB_SetText("Ускорение: параметры сохранены", 1)
return

AccelCfgCancel:
AccelSettingsGuiClose:
    Gui, AccelSettings:Destroy
return

OpenSpeedSettings:
    global speedCfgRowKey
    speedCfgRowKey := {}

    Gui, SpeedSettings:New, +Owner1 +Resize +MinSize900x650
    Gui, SpeedSettings:Font, s10, Segoe UI
    Gui, SpeedSettings:Color, White
    Gui, SpeedSettings:Add, Text, x10 y10 w880 h28 c0066CC Center, ⚡ Настройки скорости (Burst, движок, 150+ параметров)

    Gui, SpeedSettings:Font, s9, Segoe UI
    Gui, SpeedSettings:Add, Tab2, vSpeedSettingsTabs x10 y45 w880 h535, ⚡ Burst-слова|🧠 Движок|🧰 Параметры (150+)

    ; === TAB 1: Burst ===
    Gui, SpeedSettings:Tab, 1
    Gui, SpeedSettings:Add, GroupBox, x20 y85 w860 h420, ⚡ Burst-слова (мгновенный ввод)
    Gui, SpeedSettings:Add, Text, x35 y110, Эти слова будут вводиться без посимвольных задержек.
    Gui, SpeedSettings:Add, ListView, vSpeedBurstList x35 y135 w520 h320 Grid, Слово
    LV_ModifyCol(1, 500)
    Gui, SpeedSettings:Add, Edit, vSpeedBurstWord x570 y135 w200
    Gui, SpeedSettings:Add, Button, x780 y133 w90 h24 gSpeedBurstAdd, ➕ Добавить
    Gui, SpeedSettings:Add, Button, x570 y165 w300 h24 gSpeedBurstRemove, ❌ Удалить выбранное
    Gui, SpeedSettings:Add, Button, x570 y195 w300 h24 gSpeedBurstImport, 📋 Импорт из буфера

    global speedBurstWords
    if (speedBurstWords && speedBurstWords.Length() > 0) {
        Gui, SpeedSettings:Default
        Gui, ListView, SpeedBurstList
        for i, word in speedBurstWords
            LV_Add("", word)
    }

    ; === TAB 2: Engine ===
    Gui, SpeedSettings:Tab, 2
    Gui, SpeedSettings:Add, GroupBox, x20 y85 w860 h420, 🧠 Движок отправки и эффекты скорости
    Gui, SpeedSettings:Add, Text, x35 y115, Посимвольный ввод:
    Gui, SpeedSettings:Add, DropDownList, vSpeedSendEngineUi x180 y112 w220 gSpeedEngineChanged, SendInput|SendEvent|SendPlay
    Gui, SpeedSettings:Add, Text, x35 y145, Вставка Ctrl+V:
    Gui, SpeedSettings:Add, DropDownList, vSpeedClipboardEngineUi x180 y142 w220 gSpeedEngineChanged, SendInput|SendEvent|SendPlay
    GuiControl, SpeedSettings:ChooseString, SpeedSendEngineUi, %SpeedSendEngine%
    GuiControl, SpeedSettings:ChooseString, SpeedClipboardEngineUi, %SpeedClipboardEngine%

    Gui, SpeedSettings:Add, GroupBox, x35 y180 w820 h150, 🎛 Реализм скорости (работает)
    Gui, SpeedSettings:Add, Checkbox, vArrhythmiaEnabled x50 y205, Аритмия (случайные задержки)
    Gui, SpeedSettings:Add, Text, x260 y207, Интенсивность:
    Gui, SpeedSettings:Add, Slider, vArrhythmiaIntensity x350 y205 w200 Range1-100 ToolTip, %arrhythmiaIntensity%
    Gui, SpeedSettings:Add, Edit, vArrhythmiaIntensityVal x560 y205 w50 Number, %arrhythmiaIntensity%
    Gui, SpeedSettings:Add, Checkbox, vSmoothnessEnabled x50 y235, Плавность (сглаживание)
    Gui, SpeedSettings:Add, Text, x260 y237, Уровень:
    Gui, SpeedSettings:Add, Slider, vSmoothnessLevel x350 y235 w200 Range1-100 ToolTip, %smoothnessLevel%
    Gui, SpeedSettings:Add, Edit, vSmoothnessLevelVal x560 y235 w50 Number, %smoothnessLevel%
    GuiControl, SpeedSettings:, ArrhythmiaEnabled, %arrhythmiaEnabled%
    GuiControl, SpeedSettings:, SmoothnessEnabled, %smoothnessEnabled%

    Gui, SpeedSettings:Add, Text, x50 y270, Точность:
    Gui, SpeedSettings:Add, Edit, vAccuracyLevel x130 y267 w60 Number, %accuracyLevel%
    Gui, SpeedSettings:Add, Text, x210 y270, Ошибки:
    Gui, SpeedSettings:Add, Edit, vErrorPercent x270 y267 w60 Number, %errorPercent%
    Gui, SpeedSettings:Add, Text, x350 y270, Консистенция:
    Gui, SpeedSettings:Add, Edit, vConsistencyLevel x455 y267 w60 Number, %consistencyLevel%

    Gui, SpeedSettings:Add, Text, x50 y300 cGray, Примечание: множитель "Ускорение" в Основных масштабирует также MainDelay/MessageDelay и задержки Ctrl+V.

    ; === TAB 3: 150+ params ===
    Gui, SpeedSettings:Tab, 3
    Gui, SpeedSettings:Add, GroupBox, x20 y85 w860 h420, 🧰 Параметры движка скорости (150+)
    Gui, SpeedSettings:Add, Text, x35 y110, Поиск:
    Gui, SpeedSettings:Add, Edit, vSpeedCfgSearch x80 y107 w280 gSpeedCfgFilter
    Gui, SpeedSettings:Add, Text, x375 y110, Группа:
    Gui, SpeedSettings:Add, DropDownList, vSpeedCfgGroup x425 y107 w160 gSpeedCfgFilter, Все|Общее|SendInput|SendEvent|SendPlay|Буфер
    GuiControl, SpeedSettings:Choose, SpeedCfgGroup, 1
    Gui, SpeedSettings:Add, ListView, vSpeedCfgList x35 y140 w830 h305 Grid, Параметр|Значение|Описание
    LV_ModifyCol(1, 320), LV_ModifyCol(2, 130), LV_ModifyCol(3, 360)
    Gui, SpeedSettings:Add, Button, x35 y455 w120 h26 gSpeedCfgEdit, ✏️ Изменить
    Gui, SpeedSettings:Add, Button, x165 y455 w120 h26 gSpeedCfgToggle, 🔁 0/1
    Gui, SpeedSettings:Add, Button, x295 y455 w120 h26 gSpeedCfgResetSel, ♻️ Сброс
    Gui, SpeedSettings:Add, Button, x425 y455 w160 h26 gSpeedCfgResetAll, ♻️ Сбросить все

    Gui, SpeedSettings:Tab
    Gui, SpeedSettings:Add, Button, x10 y590 w200 h35 gSpeedSettingsSave, 💾 Сохранить
    Gui, SpeedSettings:Add, Button, x690 y590 w200 h35 gSpeedSettingsCancel, ✗ Закрыть

    Gosub, SpeedCfgFilter
    Gui, SpeedSettings:Show, w900 h650, Настройки скорости
return

SpeedEngineChanged:
    Gui, SpeedSettings:Submit, NoHide
    SpeedSendEngine := SpeedSendEngineUi
    SpeedClipboardEngine := SpeedClipboardEngineUi
return

SpeedBurstAdd:
    Gui, SpeedSettings:Submit, NoHide
    if (SpeedBurstWord = "")
        return
    global speedBurstWords
    if (!speedBurstWords)
        speedBurstWords := []
    speedBurstWords.Push(Trim(SpeedBurstWord))
    Gui, SpeedSettings:Default
    Gui, ListView, SpeedBurstList
    LV_Add("", Trim(SpeedBurstWord))
    GuiControl, SpeedSettings:, SpeedBurstWord,
return

SpeedBurstRemove:
    Gui, SpeedSettings:Default
    Gui, ListView, SpeedBurstList
    row := LV_GetNext()
    if (!row)
        return
    global speedBurstWords
    speedBurstWords.RemoveAt(row)
    LV_Delete(row)
return

SpeedBurstImport:
    global speedBurstWords
    ClipSaved := ClipboardAll
    ClipWait, 0.2
    txt := Clipboard
    Clipboard := ClipSaved
    txt := Trim(txt, " `t`r`n")
    if (txt = "")
        return
    lines := StrSplit(txt, "`n")
    for i, ln in lines {
        ln := Trim(ln, " `t`r")
        if (ln = "")
            continue
        speedBurstWords.Push(ln)
    }
    Gui, SpeedSettings:Default
    Gui, ListView, SpeedBurstList
    LV_Delete()
    for i, w in speedBurstWords
        LV_Add("", w)
return

SpeedCfgFilter:
    global speedCfgDefs, speedCfg, speedCfgRowKey
    Gui, SpeedSettings:Default
    Gui, ListView, SpeedCfgList
    LV_Delete()
    speedCfgRowKey := {}

    GuiControlGet, q, SpeedSettings:, SpeedCfgSearch
    GuiControlGet, gtxt, SpeedSettings:, SpeedCfgGroup
    q := Trim(q)
    ql := Format("{:L}", q)

    grp := ""
    if (gtxt = "Общее")
        grp := "common"
    else if (gtxt = "SendInput")
        grp := "input"
    else if (gtxt = "SendEvent")
        grp := "event"
    else if (gtxt = "SendPlay")
        grp := "play"
    else if (gtxt = "Буфер")
        grp := "clip"

    for i, d in speedCfgDefs {
        if (grp != "" && d.group != grp)
            continue
        hay := Format("{:L}", d.key . " " . d.label . " " . d.desc)
        if (ql != "" && !InStr(hay, ql))
            continue
        val := speedCfg[d.key]
        showVal := val
        if (showVal = "") {
            showVal := (d.group = "common") ? d.def : "—"
        }
        row := LV_Add("", d.label, showVal, d.desc)
        speedCfgRowKey[row] := d.key
    }
return

SpeedCfgEdit:
    global speedCfgRowKey, speedCfg
    Gui, SpeedSettings:Default
    Gui, ListView, SpeedCfgList
    row := LV_GetNext()
    if (!row)
        return
    key := speedCfgRowKey[row]
    d := SpeedCfgDefByKey(key)
    cur := speedCfg[key]
    InputBox, newVal, Параметр скорости, % "Введите значение для:`n" . d.label . "`n`nПусто = наследовать (для групп кроме 'Общее')", , 520, 180, , , , , %cur%
    if (ErrorLevel)
        return
    newVal := Trim(newVal)
    if (d.group = "common" && newVal = "")
        newVal := d.def

    if (newVal != "") {
        if (d.type = "bool") {
            if !(newVal = "0" || newVal = "1" || newVal = "true" || newVal = "false" || newVal = "True" || newVal = "False") {
                MsgBox, 48, Ошибка, Для булевого параметра используйте 0/1 или true/false.
                return
            }
            if (newVal = "true" || newVal = "True")
                newVal := 1
            else if (newVal = "false" || newVal = "False")
                newVal := 0
        } else if (d.type = "int") {
            if !RegExMatch(newVal, "^-?\\d+$") {
                MsgBox, 48, Ошибка, Нужно целое число.
                return
            }
        } else if (d.type = "float") {
            if !RegExMatch(newVal, "^-?\\d+(?:\\.\\d+)?$") {
                MsgBox, 48, Ошибка, Нужно число (дробное через точку).
                return
            }
        }
    }

    speedCfg[key] := newVal
    Gosub, SpeedCfgFilter
return

SpeedCfgToggle:
    global speedCfgRowKey, speedCfg
    Gui, SpeedSettings:Default
    Gui, ListView, SpeedCfgList
    row := LV_GetNext()
    if (!row)
        return
    key := speedCfgRowKey[row]
    d := SpeedCfgDefByKey(key)
    if (d.type != "bool")
        return
    cur := speedCfg[key]
    if (cur = "")
        cur := SpeedCfgEff(d.group, d.name)
    speedCfg[key] := (cur = 1 || cur = "1") ? 0 : 1
    Gosub, SpeedCfgFilter
return

SpeedCfgResetSel:
    global speedCfgRowKey, speedCfg
    Gui, SpeedSettings:Default
    Gui, ListView, SpeedCfgList
    row := LV_GetNext()
    if (!row)
        return
    key := speedCfgRowKey[row]
    d := SpeedCfgDefByKey(key)
    speedCfg[key] := (d.group = "common") ? d.def : ""
    Gosub, SpeedCfgFilter
return

SpeedCfgResetAll:
    SpeedCfgResetAll()
    Gosub, SpeedCfgFilter
return

SpeedSettingsSave:
    Gui, SpeedSettings:Submit
    global arrhythmiaEnabled, arrhythmiaIntensity, smoothnessEnabled, smoothnessLevel
    global accuracyLevel, errorPercent, consistencyLevel
    global SpeedSendEngine, SpeedClipboardEngine
    global speedBurstWords, appDataDir

    arrhythmiaEnabled := ArrhythmiaEnabled ? true : false
    arrhythmiaIntensity := ArrhythmiaIntensity + 0
    smoothnessEnabled := SmoothnessEnabled ? true : false
    smoothnessLevel := SmoothnessLevel + 0
    accuracyLevel := AccuracyLevel + 0
    errorPercent := ErrorPercent + 0
    consistencyLevel := ConsistencyLevel + 0

    SpeedSendEngine := SpeedSendEngineUi
    SpeedClipboardEngine := SpeedClipboardEngineUi

    ; Save engines
    IniWrite, %SpeedSendEngine%, %appDataDir%\AutoTyper.ini, SpeedEngine, SendEngine
    IniWrite, %SpeedClipboardEngine%, %appDataDir%\AutoTyper.ini, SpeedEngine, ClipboardEngine

    ; Save SpeedSettings
    IniWrite, %arrhythmiaEnabled%, %appDataDir%\AutoTyper.ini, SpeedSettings, ArrhythmiaEnabled
    IniWrite, %arrhythmiaIntensity%, %appDataDir%\AutoTyper.ini, SpeedSettings, ArrhythmiaIntensity
    IniWrite, %smoothnessEnabled%, %appDataDir%\AutoTyper.ini, SpeedSettings, SmoothnessEnabled
    IniWrite, %smoothnessLevel%, %appDataDir%\AutoTyper.ini, SpeedSettings, SmoothnessLevel
    IniWrite, %accuracyLevel%, %appDataDir%\AutoTyper.ini, SpeedSettings, AccuracyLevel
    IniWrite, %errorPercent%, %appDataDir%\AutoTyper.ini, SpeedSettings, ErrorPercent
    IniWrite, %consistencyLevel%, %appDataDir%\AutoTyper.ini, SpeedSettings, ConsistencyLevel

    ; Save burst words
    burstStr := ""
    if (speedBurstWords) {
        for i, word in speedBurstWords {
            word := Trim(word)
            if (word != "")
                burstStr .= word . "|"
        }
    }
    IniWrite, %burstStr%, %appDataDir%\AutoTyper.ini, SpeedSettings, BurstWords

    ; Save 150+ engine params
    SpeedCfgSave()

    Gui, SpeedSettings:Destroy
    SB_SetText("Настройки скорости сохранены", 1)
return

SpeedSettingsCancel:
SpeedSettingsGuiClose:
    Gui, SpeedSettings:Destroy
return

; ============================================
; === НАСТРОЙКИ РЕГИСТРА СЛОВ ===
; ============================================

OpenCaseSettings:
    Gui, CaseSettings:New, +Owner1
    Gui, CaseSettings:Font, s9, Segoe UI
    Gui, CaseSettings:Add, Text, x10 y10, Слова с определённым регистром:
    Gui, CaseSettings:Add, ListView, vCaseWordsList x10 y30 w380 h200 Grid, Слово|Регистр|Частота|Счётчик
    LV_ModifyCol(1, 120)
    LV_ModifyCol(2, 100)
    LV_ModifyCol(3, 80)
    LV_ModifyCol(4, 60)
    
    global caseWords
    if (caseWords && caseWords.Length() > 0) {
        Gui, CaseSettings:Default
        for i, item in caseWords
            LV_Add("", item.word, item.case, item.frequency, item.currentCount)
    }
    
    Gui, CaseSettings:Add, Text, x10 y240, Слово:
    Gui, CaseSettings:Add, Edit, vCaseWord x70 y237 w120
    Gui, CaseSettings:Add, Text, x200 y240, Регистр:
    Gui, CaseSettings:Add, DropDownList, vCaseType x260 y237 w130, ВЕРХНИЙ|нижний|Первая Заглавная|кАЖДАЯ вТОРАЯ
    Gui, CaseSettings:Add, Text, x10 y270, Частота (каждые N раз):
    Gui, CaseSettings:Add, Edit, vCaseFrequency x160 y267 w60 Number, 1
    
    Gui, CaseSettings:Add, Button, x10 y300 w120 gCaseWordAdd, ➕ Добавить
    Gui, CaseSettings:Add, Button, x140 y300 w120 gCaseWordEdit, ✏️ Изменить
    Gui, CaseSettings:Add, Button, x270 y300 w120 gCaseWordRemove, ❌ Удалить
    Gui, CaseSettings:Add, Button, x10 y335 w380 gCaseSettingsSave, 💾 Сохранить
    Gui, CaseSettings:Show, w400 h375, Настройки регистра слов
return

CaseWordAdd:
    Gui, CaseSettings:Submit, NoHide
    if (CaseWord = "")
        return
    
    global caseWords
    if (!caseWords)
        caseWords := []
    
    caseWords.Push({word: CaseWord, case: CaseType, frequency: CaseFrequency, currentCount: 0})
    Gui, CaseSettings:Default
    LV_Add("", CaseWord, CaseType, CaseFrequency, 0)
    GuiControl, CaseSettings:, CaseWord,
return

CaseWordEdit:
    Gui, CaseSettings:Default
    row := LV_GetNext()
    if (row = 0)
        return
    
    Gui, CaseSettings:Submit, NoHide
    global caseWords
    caseWords[row] := {word: CaseWord, case: CaseType, frequency: CaseFrequency, currentCount: 0}
    LV_Modify(row, "", CaseWord, CaseType, CaseFrequency, 0)
return

CaseWordRemove:
    Gui, CaseSettings:Default
    row := LV_GetNext()
    if (row = 0)
        return
    
    global caseWords
    caseWords.RemoveAt(row)
    LV_Delete(row)
return

CaseSettingsSave:
    Gui, CaseSettings:Submit
    
    ; Сохраняем в INI
    global caseWords
    caseStr := ""
    for i, item in caseWords
        caseStr .= item.word . ":" . item.case . ":" . item.frequency . "|"
    IniWrite, %caseStr%, %appDataDir%\AutoTyper.ini, CaseSettings, Words
    
    Gui, CaseSettings:Destroy
    SB_SetText("Настройки регистра сохранены", 1)
return

CaseSettingsGuiClose:
    Gui, CaseSettings:Destroy
return

; ============================================
; === ВСТАВКА БУКВ ВНУТРИ СЛОВ ===
; ============================================

AddLetterInsert:
    Gui, LetterInsertAdd:New, +Owner1
    Gui, LetterInsertAdd:Font, s9, Segoe UI
    Gui, LetterInsertAdd:Add, GroupBox, x10 y10 w380 h120, Вариации букв для вставки
    Gui, LetterInsertAdd:Add, ListView, vLetterVariationsList x20 y30 w280 h70 Grid, Буква
    Gui, LetterInsertAdd:Add, Edit, vNewLetterVariation x20 y105 w100
    Gui, LetterInsertAdd:Add, Button, x125 y103 w60 gAddLetterVariation, +
    Gui, LetterInsertAdd:Add, Button, x190 y103 w60 gRemoveLetterVariation, -
    Gui, LetterInsertAdd:Add, Button, x255 y103 w45 gClearLetterVariations, X
    Gui, LetterInsertAdd:Add, Text, x310 y35, Буквы будут
    Gui, LetterInsertAdd:Add, Text, x310 y50, вставляться
    Gui, LetterInsertAdd:Add, Text, x310 y65, во ВСЕ слова
    
    Gui, LetterInsertAdd:Add, Text, x10 y140, Позиция вставки:
    Gui, LetterInsertAdd:Add, DropDownList, vLetterInsertPos x10 y160 w180, Поочерёдно|В начало|В конец|Случайно|После гласных|После согласных|Каждые N символов|На позиции N
    Gui, LetterInsertAdd:Add, Text, x200 y140, N (позиция/интервал):
    Gui, LetterInsertAdd:Add, Edit, vLetterInsertN x200 y160 w60 Number, 2
    
    Gui, LetterInsertAdd:Add, Text, x10 y195, N-раз вставки в слово:
    Gui, LetterInsertAdd:Add, Edit, vLetterInsertCount x150 y192 w50 Number, 1
    Gui, LetterInsertAdd:Add, Text, x205 y195, раз
    
    Gui, LetterInsertAdd:Add, Button, x10 y230 w185 gLetterInsertSave, ✓ Добавить
    Gui, LetterInsertAdd:Add, Button, x205 y230 w185 gLetterInsertCancel, ✗ Отмена
    
    ; Инициализируем временный массив вариаций
    global tempLetterVariations := []
    
    Gui, LetterInsertAdd:Show, w400 h270, Добавить вставку букв
return

AddLetterVariation:
    Gui, LetterInsertAdd:Submit, NoHide
    if (NewLetterVariation = "")
        return
    
    global tempLetterVariations
    if (!tempLetterVariations)
        tempLetterVariations := []
    
    tempLetterVariations.Push(NewLetterVariation)
    Gui, LetterInsertAdd:Default
    Gui, LetterInsertAdd:ListView, LetterVariationsList
    LV_Add("", NewLetterVariation)
    GuiControl, LetterInsertAdd:, NewLetterVariation,
return

RemoveLetterVariation:
    Gui, LetterInsertAdd:Default
    Gui, LetterInsertAdd:ListView, LetterVariationsList
    row := LV_GetNext()
    if (row = 0)
        return
    
    global tempLetterVariations
    tempLetterVariations.RemoveAt(row)
    LV_Delete(row)
return

ClearLetterVariations:
    global tempLetterVariations
    tempLetterVariations := []
    Gui, LetterInsertAdd:Default
    Gui, LetterInsertAdd:ListView, LetterVariationsList
    LV_Delete()
return

LetterInsertSave:
    Gui, LetterInsertAdd:Submit
    global tempLetterVariations
    
    if (!tempLetterVariations || tempLetterVariations.Length() = 0) {
        MsgBox, 48, Ошибка, Добавьте хотя бы одну букву для вставки!
        return
    }
    
    global letterInserts
    if (!letterInserts)
        letterInserts := []
    
    ; Собираем буквы в строку
    lettersStr := ""
    for i, letter in tempLetterVariations {
        lettersStr .= letter
        if (i < tempLetterVariations.Length())
            lettersStr .= ", "
    }
    
    letterInserts.Push({letters: tempLetterVariations.Clone(), position: LetterInsertPos, n: LetterInsertN, count: LetterInsertCount, enabled: true})
    
    ; Обновляем ListView в настройках
    Gui, 1:Default
    Gui, 1:ListView, LetterInsertsList
    LV_Add("", lettersStr, LetterInsertPos, LetterInsertCount, "Вкл")
    
    tempLetterVariations := []
    Gui, LetterInsertAdd:Destroy
    SB_SetText("Вставка букв добавлена", 1)
return

LetterInsertCancel:
LetterInsertAddGuiClose:
    global tempLetterVariations
    tempLetterVariations := []
    Gui, LetterInsertAdd:Destroy
return

EditLetterInsert:
    Gui, 1:Default
    Gui, 1:ListView, LetterInsertsList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите вставку для редактирования!
        return
    }
    
    global letterInserts, tempLetterVariationsEdit
    item := letterInserts[row]
    tempLetterVariationsEdit := item.letters.Clone()
    
    Gui, LetterInsertEdit:New, +Owner1
    Gui, LetterInsertEdit:Font, s9, Segoe UI
    Gui, LetterInsertEdit:Add, GroupBox, x10 y10 w380 h120, Вариации букв
    Gui, LetterInsertEdit:Add, ListView, vLetterVariationsListEdit x20 y30 w280 h70 Grid, Буква
    
    ; Заполняем список
    Gui, LetterInsertEdit:Default
    for i, letter in tempLetterVariationsEdit
        LV_Add("", letter)
    
    Gui, LetterInsertEdit:Add, Edit, vNewLetterVariationEdit x20 y105 w100
    Gui, LetterInsertEdit:Add, Button, x125 y103 w60 gAddLetterVariationEdit, +
    Gui, LetterInsertEdit:Add, Button, x190 y103 w60 gRemoveLetterVariationEdit, -
    
    Gui, LetterInsertEdit:Add, Text, x10 y140, Позиция:
    Gui, LetterInsertEdit:Add, DropDownList, vLetterInsertPosEdit x10 y160 w180, Поочерёдно|В начало|В конец|Случайно|После гласных|После согласных|Каждые N символов|На позиции N
    GuiControl, LetterInsertEdit:ChooseString, LetterInsertPosEdit, % item.position
    Gui, LetterInsertEdit:Add, Text, x200 y140, N:
    Gui, LetterInsertEdit:Add, Edit, vLetterInsertNEdit x200 y160 w60 Number, % item.n
    
    Gui, LetterInsertEdit:Add, Text, x10 y195, N-раз:
    Gui, LetterInsertEdit:Add, Edit, vLetterInsertCountEdit x60 y192 w50 Number, % item.count
    
    Gui, LetterInsertEdit:Add, Button, x10 y230 w185 gLetterInsertUpdate, ✓ Обновить
    Gui, LetterInsertEdit:Add, Button, x205 y230 w185 gLetterInsertEditCancel, ✗ Отмена
    
    global editLetterInsertRow := row
    Gui, LetterInsertEdit:Show, w400 h270, Редактировать вставку
return

AddLetterVariationEdit:
    Gui, LetterInsertEdit:Submit, NoHide
    if (NewLetterVariationEdit = "")
        return
    
    global tempLetterVariationsEdit
    tempLetterVariationsEdit.Push(NewLetterVariationEdit)
    Gui, LetterInsertEdit:Default
    Gui, LetterInsertEdit:ListView, LetterVariationsListEdit
    LV_Add("", NewLetterVariationEdit)
    GuiControl, LetterInsertEdit:, NewLetterVariationEdit,
return

RemoveLetterVariationEdit:
    Gui, LetterInsertEdit:Default
    Gui, LetterInsertEdit:ListView, LetterVariationsListEdit
    row := LV_GetNext()
    if (row = 0)
        return
    
    global tempLetterVariationsEdit
    tempLetterVariationsEdit.RemoveAt(row)
    LV_Delete(row)
return

LetterInsertUpdate:
    Gui, LetterInsertEdit:Submit
    global letterInserts, editLetterInsertRow, tempLetterVariationsEdit
    
    if (!tempLetterVariationsEdit || tempLetterVariationsEdit.Length() = 0) {
        MsgBox, 48, Ошибка, Добавьте хотя бы одну букву!
        return
    }
    
    ; Собираем буквы в строку
    lettersStr := ""
    for i, letter in tempLetterVariationsEdit {
        lettersStr .= letter
        if (i < tempLetterVariationsEdit.Length())
            lettersStr .= ", "
    }
    
    letterInserts[editLetterInsertRow] := {letters: tempLetterVariationsEdit.Clone(), position: LetterInsertPosEdit, n: LetterInsertNEdit, count: LetterInsertCountEdit, enabled: true}
    
    Gui, 1:Default
    Gui, 1:ListView, LetterInsertsList
    LV_Modify(editLetterInsertRow, "", lettersStr, LetterInsertPosEdit, LetterInsertCountEdit, "Вкл")
    
    tempLetterVariationsEdit := []
    Gui, LetterInsertEdit:Destroy
return

LetterInsertEditCancel:
LetterInsertEditGuiClose:
    global tempLetterVariationsEdit
    tempLetterVariationsEdit := []
    Gui, LetterInsertEdit:Destroy
return

DeleteLetterInsert:
    Gui, 1:Default
    Gui, 1:ListView, LetterInsertsList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите вставку для удаления!
        return
    }
    
    global letterInserts
    letterInserts.RemoveAt(row)
    LV_Delete(row)
    SB_SetText("Вставка буквы удалена", 1)
return

ClearLetterInserts:
    MsgBox, 36, Подтверждение, Удалить все вставки букв?
    IfMsgBox, No
        return
    
    global letterInserts
    letterInserts := []
    
    Gui, 1:Default
    Gui, 1:ListView, LetterInsertsList
    LV_Delete()
    SB_SetText("Все вставки букв удалены", 1)
return

; === ПРИМЕНЕНИЕ ВСТАВКИ БУКВ К СЛОВУ (ко всем словам) ===
ApplyLetterInserts(word) {
    global letterInserts
    if (!letterInserts || letterInserts.Length() = 0)
        return word
    
    result := word
    
    for i, item in letterInserts {
        if (!item.enabled)
            continue
        
        ; Получаем случайную букву из списка вариаций
        letters := item.letters
        if (!letters || letters.Length() = 0)
            continue
        
        Random, letterIdx, 1, % letters.Length()
        letter := letters[letterIdx]
        
        pos := item.position
        insertCount := item.count > 0 ? item.count : 1
        n := item.n > 0 ? item.n : 2
        
        ; Применяем вставку N раз
        Loop, %insertCount% {
            if (pos = "В начало") {
                result := letter . result
            } else if (pos = "В конец") {
                result := result . letter
            } else if (pos = "Случайно") {
                if (StrLen(result) > 0) {
                    Random, insertPos, 1, % StrLen(result)
                    result := SubStr(result, 1, insertPos) . letter . SubStr(result, insertPos + 1)
                }
            } else if (pos = "После гласных") {
                vowels := "аеёиоуыэюяАЕЁИОУЫЭЮЯaeiouAEIOU"
                newResult := ""
                insertedCount := 0
                Loop, Parse, result
                {
                    newResult .= A_LoopField
                    if (InStr(vowels, A_LoopField) && insertedCount < insertCount) {
                        newResult .= letter
                        insertedCount++
                    }
                }
                result := newResult
                break  ; Уже обработали все вставки
            } else if (pos = "После согласных") {
                consonants := "бвгджзйклмнпрстфхцчшщБВГДЖЗЙКЛМНПРСТФХЦЧШЩbcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ"
                newResult := ""
                insertedCount := 0
                Loop, Parse, result
                {
                    newResult .= A_LoopField
                    if (InStr(consonants, A_LoopField) && insertedCount < insertCount) {
                        newResult .= letter
                        insertedCount++
                    }
                }
                result := newResult
                break  ; Уже обработали все вставки
            } else if (pos = "Поочерёдно") {
                ; Вставляем букву поочерёдно в каждую позицию
                static letterInsertCounter := 0
                letterInsertCounter++
                insertPos := Mod(letterInsertCounter - 1, StrLen(result)) + 1
                result := SubStr(result, 1, insertPos) . letter . SubStr(result, insertPos + 1)
            } else if (pos = "Каждые N символов") {
                newResult := ""
                Loop, Parse, result
                {
                    newResult .= A_LoopField
                    if (Mod(A_Index, n) = 0)
                        newResult .= letter
                }
                result := newResult
                break  ; Уже обработали
            } else if (pos = "На позиции N") {
                ; Вставляем на конкретную позицию
                if (n <= StrLen(result) && n > 0) {
                    result := SubStr(result, 1, n) . letter . SubStr(result, n + 1)
                }
            }
        }
    }
    
    return result
}


; ============================================
; === ПЕРЕВОДЧИК ===
; ============================================

OpenTranslator:
    Gui, Translator:New, +Owner1
    Gui, Translator:Font, s9, Segoe UI
    Gui, Translator:Add, GroupBox, x10 y10 w400 h100, 🌐 Настройки переводчика
    Gui, Translator:Add, Checkbox, vTranslatorEnabled x20 y30, Включить перевод текста
    Gui, Translator:Add, Text, x20 y55, Исходный язык:
    Gui, Translator:Add, DropDownList, vTranslatorSource x120 y52 w130, ru - Русский|en - English|de - Deutsch|fr - Français|es - Español|it - Italiano|pt - Português|zh - 中文|ja - 日本語|ko - 한국어
    Gui, Translator:Add, Text, x260 y55, Целевой язык:
    Gui, Translator:Add, DropDownList, vTranslatorTarget x350 y52 w60, en|ru|de|fr|es|it|pt|zh|ja|ko
    
    Gui, Translator:Add, GroupBox, x10 y120 w400 h150, 📝 Тест перевода
    Gui, Translator:Add, Text, x20 y140, Введите текст:
    Gui, Translator:Add, Edit, vTranslatorInput x20 y160 w380 h40
    Gui, Translator:Add, Button, x20 y210 w380 gTranslatorTest, 🔄 Перевести
    Gui, Translator:Add, Text, x20 y240, Результат:
    Gui, Translator:Add, Edit, vTranslatorOutput x20 y255 w380 h30 ReadOnly
    
    Gui, Translator:Add, Button, x10 y290 w400 gTranslatorSave, 💾 Сохранить настройки
    Gui, Translator:Show, w420 h330, Переводчик
return

TranslatorTest:
    Gui, Translator:Submit, NoHide
    if (TranslatorInput = "") {
        MsgBox, 48, Ошибка, Введите текст для перевода!
        return
    }
    
    ; Получаем код языка
    sourceLang := SubStr(TranslatorSource, 1, 2)
    targetLang := TranslatorTarget
    
    ; Используем простой словарь для базового перевода
    translated := TranslateText(TranslatorInput, sourceLang, targetLang)
    GuiControl, Translator:, TranslatorOutput, %translated%
return

TranslatorSave:
    Gui, Translator:Submit
    global translatorEnabled, translatorSourceLang, translatorTargetLang
    
    translatorEnabled := TranslatorEnabled
    translatorSourceLang := SubStr(TranslatorSource, 1, 2)
    translatorTargetLang := TranslatorTarget
    
    IniWrite, %translatorEnabled%, %appDataDir%\AutoTyper.ini, Translator, Enabled
    IniWrite, %translatorSourceLang%, %appDataDir%\AutoTyper.ini, Translator, SourceLang
    IniWrite, %translatorTargetLang%, %appDataDir%\AutoTyper.ini, Translator, TargetLang
    
    Gui, Translator:Destroy
    SB_SetText("Настройки переводчика сохранены", 1)
return

TranslatorGuiClose:
    Gui, Translator:Destroy
return

; === ФУНКЦИЯ ПЕРЕВОДА ===
TranslateText(text, sourceLang, targetLang) {
    ; Базовый словарь русско-английский
    static dictRuEn := {}
    if (dictRuEn.Count() = 0) {
        dictRuEn["привет"] := "hello"
        dictRuEn["мир"] := "world"
        dictRuEn["как"] := "how"
        dictRuEn["дела"] := "are you"
        dictRuEn["хорошо"] := "good"
        dictRuEn["плохо"] := "bad"
        dictRuEn["да"] := "yes"
        dictRuEn["нет"] := "no"
        dictRuEn["спасибо"] := "thank you"
        dictRuEn["пожалуйста"] := "please"
        dictRuEn["я"] := "I"
        dictRuEn["ты"] := "you"
        dictRuEn["он"] := "he"
        dictRuEn["она"] := "she"
        dictRuEn["мы"] := "we"
        dictRuEn["они"] := "they"
        dictRuEn["это"] := "this"
        dictRuEn["что"] := "what"
        dictRuEn["где"] := "where"
        dictRuEn["когда"] := "when"
        dictRuEn["почему"] := "why"
        dictRuEn["потому"] := "because"
        dictRuEn["и"] := "and"
        dictRuEn["или"] := "or"
        dictRuEn["но"] := "but"
        dictRuEn["если"] := "if"
        dictRuEn["тогда"] := "then"
        dictRuEn["сейчас"] := "now"
        dictRuEn["здесь"] := "here"
        dictRuEn["там"] := "there"
    }
    
    ; Базовый словарь англо-русский
    static dictEnRu := {}
    if (dictEnRu.Count() = 0) {
        dictEnRu["hello"] := "привет"
        dictEnRu["world"] := "мир"
        dictEnRu["how"] := "как"
        dictEnRu["good"] := "хорошо"
        dictEnRu["bad"] := "плохо"
        dictEnRu["yes"] := "да"
        dictEnRu["no"] := "нет"
        dictEnRu["thank"] := "спасибо"
        dictEnRu["please"] := "пожалуйста"
        dictEnRu["i"] := "я"
        dictEnRu["you"] := "ты"
        dictEnRu["he"] := "он"
        dictEnRu["she"] := "она"
        dictEnRu["we"] := "мы"
        dictEnRu["they"] := "они"
        dictEnRu["this"] := "это"
        dictEnRu["what"] := "что"
        dictEnRu["where"] := "где"
        dictEnRu["when"] := "когда"
        dictEnRu["why"] := "почему"
        dictEnRu["because"] := "потому что"
        dictEnRu["and"] := "и"
        dictEnRu["or"] := "или"
        dictEnRu["but"] := "но"
        dictEnRu["if"] := "если"
        dictEnRu["then"] := "тогда"
        dictEnRu["now"] := "сейчас"
        dictEnRu["here"] := "здесь"
        dictEnRu["there"] := "там"
    }
    
    ; Выбираем словарь
    if (sourceLang = "ru" && targetLang = "en")
        dict := dictRuEn
    else if (sourceLang = "en" && targetLang = "ru")
        dict := dictEnRu
    else
        return text  ; Нет словаря для этой пары языков
    
    ; Переводим слово за словом
    result := ""
    words := StrSplit(text, " ")
    for i, word in words {
        wordLower := Format("{:L}", word)
        if (dict.HasKey(wordLower))
            result .= dict[wordLower]
        else
            result .= word
        
        if (i < words.Length())
            result .= " "
    }
    
    return result
}

; ============================================
; === АВТО-КОРРЕКЦИЯ ===
; ============================================

OpenAutoCorrectSettings:
    Gui, AutoCorrectSettings:New, +Owner1
    Gui, AutoCorrectSettings:Font, s9, Segoe UI
    Gui, AutoCorrectSettings:Add, GroupBox, x10 y10 w400 h80, ⚙️ Настройки авто-коррекции
    Gui, AutoCorrectSettings:Add, Checkbox, vAutoCorrectEnabled x20 y30, Включить авто-коррекцию
    Gui, AutoCorrectSettings:Add, Text, x20 y55, Авто-коррекция исправляет опечатки в реальном времени
    
    Gui, AutoCorrectSettings:Add, GroupBox, x10 y100 w400 h200, 📖 Словарь исправлений
    Gui, AutoCorrectSettings:Add, ListView, vAutoCorrectList x20 y120 w380 h120 Grid, Ошибка|Исправление
    LV_ModifyCol(1, 180)
    LV_ModifyCol(2, 180)
    
    global autoCorrectDictionary
    if (autoCorrectDictionary && autoCorrectDictionary.Count() > 0) {
        Gui, AutoCorrectSettings:Default
        for wrong, correct in autoCorrectDictionary
            LV_Add("", wrong, correct)
    }
    
    Gui, AutoCorrectSettings:Add, Edit, vAutoCorrectWrong x20 y250 w150, 
    Gui, AutoCorrectSettings:Add, Text, x175 y253, →
    Gui, AutoCorrectSettings:Add, Edit, vAutoCorrectCorrect x190 y250 w150
    Gui, AutoCorrectSettings:Add, Button, x350 y248 w50 gAutoCorrectAdd, +
    
    Gui, AutoCorrectSettings:Add, Button, x20 y280 w120 gAutoCorrectRemove, Удалить
    Gui, AutoCorrectSettings:Add, Button, x150 y280 w120 gAutoCorrectClear, Очистить
    Gui, AutoCorrectSettings:Add, Button, x280 y280 w120 gAutoCorrectImport, Импорт
    
    Gui, AutoCorrectSettings:Add, Button, x10 y320 w400 gAutoCorrectSave, 💾 Сохранить
    Gui, AutoCorrectSettings:Show, w420 h360, Настройки авто-коррекции
return

AutoCorrectAdd:
    Gui, AutoCorrectSettings:Submit, NoHide
    if (AutoCorrectWrong = "" || AutoCorrectCorrect = "")
        return
    
    global autoCorrectDictionary
    if (!autoCorrectDictionary)
        autoCorrectDictionary := {}
    
    autoCorrectDictionary[AutoCorrectWrong] := AutoCorrectCorrect
    Gui, AutoCorrectSettings:Default
    LV_Add("", AutoCorrectWrong, AutoCorrectCorrect)
    GuiControl, AutoCorrectSettings:, AutoCorrectWrong,
    GuiControl, AutoCorrectSettings:, AutoCorrectCorrect,
return

AutoCorrectRemove:
    Gui, AutoCorrectSettings:Default
    row := LV_GetNext()
    if (row = 0)
        return
    
    LV_GetText(wrong, row, 1)
    global autoCorrectDictionary
    autoCorrectDictionary.Delete(wrong)
    LV_Delete(row)
return

AutoCorrectClear:
    global autoCorrectDictionary
    autoCorrectDictionary := {}
    Gui, AutoCorrectSettings:Default
    LV_Delete()
return

AutoCorrectImport:
    ; Добавляем стандартные исправления
    global autoCorrectDictionary
    if (!autoCorrectDictionary)
        autoCorrectDictionary := {}
    
    ; Частые опечатки
    autoCorrectDictionary["тоже"] := "тоже"
    autoCorrectDictionary["прсивет"] := "привет"
    autoCorrectDictionary["привте"] := "привет"
    autoCorrectDictionary["приевт"] := "привет"
    autoCorrectDictionary["спсибо"] := "спасибо"
    autoCorrectDictionary["спасбо"] := "спасибо"
    autoCorrectDictionary["пжлста"] := "пожалуйста"
    autoCorrectDictionary["хорошо"] := "хорошо"
    autoCorrectDictionary["хоршо"] := "хорошо"
    autoCorrectDictionary["нормлаьно"] := "нормально"
    autoCorrectDictionary["норамльно"] := "нормально"
    
    ; Обновляем ListView
    Gui, AutoCorrectSettings:Default
    LV_Delete()
    for wrong, correct in autoCorrectDictionary
        LV_Add("", wrong, correct)
    
    SB_SetText("Импортировано стандартных исправлений", 1)
return

AutoCorrectSave:
    Gui, AutoCorrectSettings:Submit
    global autoCorrectEnabled, autoCorrectDictionary
    
    autoCorrectEnabled := AutoCorrectEnabled
    
    ; Сохраняем в INI
    IniWrite, %autoCorrectEnabled%, %appDataDir%\AutoTyper.ini, AutoCorrect, Enabled
    
    ; Сохраняем словарь
    dictStr := ""
    for wrong, correct in autoCorrectDictionary
        dictStr .= wrong . "=" . correct . "|"
    IniWrite, %dictStr%, %appDataDir%\AutoTyper.ini, AutoCorrect, Dictionary
    
    Gui, AutoCorrectSettings:Destroy
    SB_SetText("Настройки авто-коррекции сохранены", 1)
return

AutoCorrectSettingsGuiClose:
    Gui, AutoCorrectSettings:Destroy
return

; === ПРИМЕНЕНИЕ АВТО-КОРРЕКЦИИ ===
ApplyAutoCorrect(word) {
    global autoCorrectEnabled, autoCorrectDictionary
    
    if (!autoCorrectEnabled || !autoCorrectDictionary)
        return word
    
    wordLower := Format("{:L}", word)
    if (autoCorrectDictionary.HasKey(wordLower))
        return autoCorrectDictionary[wordLower]
    
    return word
}

; ============================================
; === ПРЕСЕТЫ НАСТРОЕК ===
; ============================================

LoadSettingsPreset:
    Gui, 1:Default
    GuiControlGet, presetName,, SettingsPresetList
    if (presetName = "") {
        MsgBox, 48, Ошибка, Выберите пресет для загрузки!
        return
    }
    
    global settingsPresetsDir
    presetFile := settingsPresetsDir . "\" . presetName . ".ini"
    
    if (!FileExist(presetFile)) {
        MsgBox, 16, Ошибка, Файл пресета не найден!
        return
    }
    
    ; Загружаем настройки из пресета
    IniRead, pSpeed, %presetFile%, Settings, Speed, 50
    IniRead, pSpeedType, %presetFile%, Settings, SpeedType, Букв в секунду
    IniRead, pErrorLevel, %presetFile%, Settings, ErrorLevel, Нет
    IniRead, pTextCase, %presetFile%, Settings, TextCase, Обычный
    IniRead, pAutoCorrect, %presetFile%, Settings, AutoCorrect, 0
    IniRead, pRandomSpaces, %presetFile%, Settings, RandomSpaces, 0
    IniRead, pDoubleLetters, %presetFile%, Settings, DoubleLetters, 0
    IniRead, pCharDelayMin, %presetFile%, Settings, CharDelayMin, 10
    IniRead, pCharDelayMax, %presetFile%, Settings, CharDelayMax, 50
    IniRead, pMessagePauseMin, %presetFile%, Settings, MessagePauseMin, 500
    IniRead, pMessagePauseMax, %presetFile%, Settings, MessagePauseMax, 2000
    
    ; Применяем настройки
    GuiControl,, SpeedInput, %pSpeed%
    GuiControl, ChooseString, SpeedType, %pSpeedType%
    GuiControl, ChooseString, ErrorLevelSetting, %pErrorLevel%
    GuiControl, ChooseString, TextCase, %pTextCase%
    
    global currentSettingsPreset := presetName
    SB_SetText("Пресет загружен: " . presetName, 1)
return

SaveSettingsPreset:
    InputBox, presetName, Сохранить пресет, Введите название пресета:,, 300, 130
    if (ErrorLevel || presetName = "")
        return
    
    global settingsPresetsDir
    presetFile := settingsPresetsDir . "\" . presetName . ".ini"
    
    ; Получаем текущие настройки
    Gui, 1:Submit, NoHide
    
    ; Сохраняем в файл пресета
    IniWrite, %SpeedInput%, %presetFile%, Settings, Speed
    IniWrite, %SpeedType%, %presetFile%, Settings, SpeedType
    IniWrite, %ErrorLevelSetting%, %presetFile%, Settings, ErrorLevel
    IniWrite, %TextCase%, %presetFile%, Settings, TextCase
    
    global randomSpacesEnabled, doubleLettersEnabled, charDelayMin, charDelayMax
    global messagePauseMin, messagePauseMax
    
    IniWrite, %randomSpacesEnabled%, %presetFile%, Settings, RandomSpaces
    IniWrite, %doubleLettersEnabled%, %presetFile%, Settings, DoubleLetters
    IniWrite, %charDelayMin%, %presetFile%, Settings, CharDelayMin
    IniWrite, %charDelayMax%, %presetFile%, Settings, CharDelayMax
    IniWrite, %messagePauseMin%, %presetFile%, Settings, MessagePauseMin
    IniWrite, %messagePauseMax%, %presetFile%, Settings, MessagePauseMax
    
    ; Обновляем список пресетов
    Gosub, RefreshSettingsPresets
    
    global currentSettingsPreset := presetName
    SB_SetText("Пресет сохранён: " . presetName, 1)
return

DeleteSettingsPreset:
    Gui, 1:Default
    GuiControlGet, presetName,, SettingsPresetList
    if (presetName = "") {
        MsgBox, 48, Ошибка, Выберите пресет для удаления!
        return
    }
    
    MsgBox, 36, Подтверждение, Удалить пресет "%presetName%"?
    IfMsgBox, No
        return
    
    global settingsPresetsDir
    presetFile := settingsPresetsDir . "\" . presetName . ".ini"
    FileDelete, %presetFile%
    
    Gosub, RefreshSettingsPresets
    SB_SetText("Пресет удалён: " . presetName, 1)
return

RenameSettingsPreset:
    Gui, 1:Default
    GuiControlGet, oldName,, SettingsPresetList
    if (oldName = "") {
        MsgBox, 48, Ошибка, Выберите пресет для переименования!
        return
    }
    
    InputBox, newName, Переименовать пресет, Новое название:,, 300, 130,,,, %oldName%
    if (ErrorLevel || newName = "" || newName = oldName)
        return
    
    global settingsPresetsDir
    oldFile := settingsPresetsDir . "\" . oldName . ".ini"
    newFile := settingsPresetsDir . "\" . newName . ".ini"
    
    FileMove, %oldFile%, %newFile%
    
    Gosub, RefreshSettingsPresets
    SB_SetText("Пресет переименован: " . oldName . " → " . newName, 1)
return

RefreshSettingsPresets:
    global settingsPresetsDir
    
    presetList := ""
    Loop, Files, %settingsPresetsDir%\*.ini
    {
        name := SubStr(A_LoopFileName, 1, -4)  ; Убираем .ini
        presetList .= name . "|"
    }
    
    GuiControl,, SettingsPresetList, |%presetList%
return

; ============================================
; === ПЕРЕИМЕНОВАНИЕ ПРЕСЕТОВ ГЕНЕРАТОРА ===
; ============================================

RenameGenPreset:
    Gui, 1:Default
    GuiControlGet, currentTemplate,, GenTemplateList
    if (currentTemplate = "") {
        MsgBox, 48, Ошибка, Выберите шаблон для переименования!
        return
    }
    
    InputBox, newName, Переименовать шаблон, Новое название:,, 300, 130,,,, %currentTemplate%
    if (ErrorLevel || newName = "" || newName = currentTemplate)
        return
    
    global genTemplatesDir, genCurrentCategory, genCurrentSubcategory
    
    if (genCurrentSubcategory != "")
        folder := genTemplatesDir . "\" . genCurrentCategory . "\" . genCurrentSubcategory
    else if (genCurrentCategory != "")
        folder := genTemplatesDir . "\" . genCurrentCategory
    else
        folder := genTemplatesDir
    
    oldFile := folder . "\" . currentTemplate . ".txt"
    newFile := folder . "\" . newName . ".txt"
    
    FileMove, %oldFile%, %newFile%
    
    ; Обновляем список
    Gosub, RefreshGenTemplates
    SB_SetText("Шаблон переименован: " . currentTemplate . " → " . newName, 1)
return

; ============================================
; === ПЕРЕИМЕНОВАНИЕ ПРЕСЕТОВ ОСНОВНОГО ТЕКСТА ===
; ============================================

RenameMainPreset:
    Gui, 1:Default
    GuiControlGet, currentPreset,, CategoryList
    if (currentPreset = "") {
        MsgBox, 48, Ошибка, Выберите пресет для переименования!
        return
    }
    
    ; Проверяем, что это шаблон, а не категория
    global navigationLevel
    if (navigationLevel != "presets") {
        MsgBox, 48, Ошибка, Переименование доступно только для шаблонов!
        return
    }
    
    InputBox, newName, Переименовать шаблон, Новое название:,, 300, 130,,,, %currentPreset%
    if (ErrorLevel || newName = "" || newName = currentPreset)
        return
    
    global presetDir, currentCategory, currentSubcategory
    
    if (currentSubcategory != "")
        folder := presetDir . "\" . currentCategory . "\" . currentSubcategory
    else if (currentCategory != "")
        folder := presetDir . "\" . currentCategory
    else
        folder := presetDir
    
    oldFile := folder . "\" . currentPreset . ".txt"
    newFile := folder . "\" . newName . ".txt"
    
    FileMove, %oldFile%, %newFile%
    
    ; Обновляем список
    Gosub, LoadCategory
    SB_SetText("Шаблон переименован: " . currentPreset . " → " . newName, 1)
return


; ============================================
; === ПРИМЕНЕНИЕ СЛУЧАЙНЫХ ПРОБЕЛОВ ===
; ============================================

ApplyRandomSpaces(text) {
    global randomSpacesEnabled, randomSpacesFrequency, randomSpacesType
    
    if (!randomSpacesEnabled || randomSpacesFrequency <= 0)
        return text
    
    result := ""
    wordCount := 0
    
    Loop, Parse, text
    {
        char := A_LoopField
        result .= char
        
        if (char = " ") {
            wordCount++
            
            ; Проверяем, нужно ли добавить дополнительные пробелы
            if (Mod(wordCount, randomSpacesFrequency) = 0) {
                if (randomSpacesType = "Двойной") {
                    result .= " "
                } else if (randomSpacesType = "Тройной") {
                    result .= "  "
                } else if (randomSpacesType = "Случайный") {
                    Random, extraSpaces, 1, 2
                    Loop, %extraSpaces%
                        result .= " "
                }
            }
        }
    }
    
    return result
}

; ============================================
; === ПРИМЕНЕНИЕ DOUBLE/TRIPLE БУКВ ===
; ============================================

ApplyDoubleLetters(text) {
    global doubleLettersEnabled, doubleLettersFrequency, doubleLettersType, doubleLettersChars
    
    if (!doubleLettersEnabled || doubleLettersFrequency <= 0)
        return text
    
    result := ""
    charCount := 0
    
    Loop, Parse, text
    {
        char := A_LoopField
        charLower := Format("{:L}", char)
        
        ; Проверяем, является ли символ буквой для дублирования
        if (InStr(doubleLettersChars, charLower)) {
            charCount++
            
            if (Mod(charCount, doubleLettersFrequency) = 0) {
                if (doubleLettersType = "Double") {
                    result .= char . char
                } else if (doubleLettersType = "Triple") {
                    result .= char . char . char
                } else if (doubleLettersType = "Случайный") {
                    Random, repeatCount, 2, 3
                    Loop, %repeatCount%
                        result .= char
                }
                continue
            }
        }
        
        result .= char
    }
    
    return result
}

; ============================================
; === ПРИМЕНЕНИЕ РЕГИСТРА СЛОВ ===
; ============================================

ApplyCaseWords(text) {
    global caseWords
    
    if (!caseWords || caseWords.Length() = 0)
        return text
    
    words := StrSplit(text, " ")
    result := ""
    
    for i, word in words {
        wordLower := Format("{:L}", word)
        modified := false
        
        for j, item in caseWords {
            itemWordLower := Format("{:L}", item.word)
            if (wordLower = itemWordLower) {
                ; Увеличиваем счётчик
                item.currentCount++
                caseWords[j] := item
                
                ; Проверяем частоту
                if (Mod(item.currentCount, item.frequency) = 0) {
                    if (item.case = "ВЕРХНИЙ") {
                        StringUpper, word, word
                    } else if (item.case = "нижний") {
                        StringLower, word, word
                    } else if (item.case = "Первая Заглавная") {
                        StringLower, word, word
                        word := Format("{:U}", SubStr(word, 1, 1)) . SubStr(word, 2)
                    } else if (item.case = "кАЖДАЯ вТОРАЯ") {
                        newWord := ""
                        Loop, Parse, word
                        {
                            if (Mod(A_Index, 2) = 0)
                                newWord .= Format("{:U}", A_LoopField)
                            else
                                newWord .= Format("{:L}", A_LoopField)
                        }
                        word := newWord
                    }
                    modified := true
                }
                break
            }
        }
        
        result .= (result != "" ? " " : "") . word
    }
    
    return result
}

; ============================================
; === ПРИМЕНЕНИЕ ПАУЗ МЕЖДУ СООБЩЕНИЯМИ ===
; ============================================

GetMessagePauseDelay() {
    global messagePauseEnabled, messagePauseMin, messagePauseMax, messagePauseUnit
    
    if (!messagePauseEnabled)
        return 0
    
    Random, pauseMs, %messagePauseMin%, %messagePauseMax%
    
    ; Конвертируем в миллисекунды если нужно
    if (messagePauseUnit = "сек")
        pauseMs := pauseMs * 1000
    else if (messagePauseUnit = "мин")
        pauseMs := pauseMs * 60000
    
    return pauseMs
}

; ============================================
; === ПРИМЕНЕНИЕ ЗАДЕРЖКИ МЕЖДУ БУКВАМИ ===
; ============================================

GetCharDelay() {
    global charDelayEnabled, charDelayMin, charDelayMax
    
    if (!charDelayEnabled || charDelayMax <= 0)
        return 0
    
    Random, delayMs, %charDelayMin%, %charDelayMax%
    return delayMs
}

; ============================================
; === ПРОВЕРКА BURST-СЛОВА ===
; ============================================

IsBurstWord(word) {
    global speedBurstWords
    
    if (!speedBurstWords || speedBurstWords.Length() = 0)
        return false
    
    wordLower := Format("{:L}", word)
    
    for i, burstWord in speedBurstWords {
        if (Format("{:L}", burstWord) = wordLower)
            return true
    }
    
    return false
}

; ============================================
; === ПРИМЕНЕНИЕ АРИТМИИ К ЗАДЕРЖКЕ ===
; ============================================

ApplyArrhythmia(baseDelay) {
    global arrhythmiaEnabled, arrhythmiaIntensity
    
    if (!arrhythmiaEnabled || arrhythmiaIntensity <= 0)
        return baseDelay
    
    ; Вычисляем случайное отклонение
    maxVariation := baseDelay * arrhythmiaIntensity / 100
    Random, variation, % -maxVariation, %maxVariation%
    
    newDelay := baseDelay + variation
    return newDelay > 0 ? newDelay : 1
}

; ============================================
; === ПРИМЕНЕНИЕ ПЛАВНОСТИ К ЗАДЕРЖКЕ ===
; ============================================

ApplySmoothness(baseDelay, prevDelay) {
    global smoothnessEnabled, smoothnessLevel
    
    if (!smoothnessEnabled || smoothnessLevel <= 0)
        return baseDelay
    
    ; Плавный переход между задержками
    smoothFactor := smoothnessLevel / 100
    return Round(prevDelay * smoothFactor + baseDelay * (1 - smoothFactor))
}

; ============================================
; === ОБНОВЛЕНИЕ СПИСКА ПРЕСЕТОВ ПРИ СТАРТЕ ===
; ============================================

LoadSettingsPresetsOnStart:
    global settingsPresetsDir
    
    if (!FileExist(settingsPresetsDir))
        FileCreateDir, %settingsPresetsDir%
    
    presetList := ""
    Loop, Files, %settingsPresetsDir%\*.ini
    {
        name := SubStr(A_LoopFileName, 1, -4)
        presetList .= name . "|"
    }
    
    GuiControl,, SettingsPresetList, |%presetList%
return

; ============================================
; === ЗАГРУЗКА СОХРАНЁННЫХ ВСТАВОК БУКВ ===
; ============================================

LoadLetterInsertsOnStart:
    global letterInserts, appDataDir
    
    IniRead, savedLetterInserts, %appDataDir%\AutoTyper.ini, LetterInserts, Data
    if (savedLetterInserts = "ERROR" || savedLetterInserts = "" || savedLetterInserts = "empty")
        return
    
    letterInserts := []
    items := StrSplit(savedLetterInserts, "||")
    
    for i, item in items {
        if (item = "")
            continue
        parts := StrSplit(item, "|")
        if (parts.Length() >= 4) {
            ; Формат: letters;letters;...|position|n|count
            lettersStr := parts[1]
            lettersArr := StrSplit(lettersStr, ";")
            
            letterInserts.Push({letters: lettersArr, position: parts[2], n: parts[3], count: parts[4], enabled: true})
            
            ; Собираем строку для отображения
            displayLetters := ""
            for j, letter in lettersArr {
                displayLetters .= letter
                if (j < lettersArr.Length())
                    displayLetters .= ", "
            }
            
            Gui, 1:Default
            Gui, 1:ListView, LetterInsertsList
            LV_Add("", displayLetters, parts[2], parts[4], "Вкл")
        }
    }
return

; ============================================
; === СОХРАНЕНИЕ ВСТАВОК БУКВ ПРИ ВЫХОДЕ ===
; ============================================

SaveLetterInsertsOnExit:
    global letterInserts, appDataDir
    
    if (!letterInserts || letterInserts.Length() = 0) {
        IniWrite, empty, %appDataDir%\AutoTyper.ini, LetterInserts, Data
        return
    }
    
    dataStr := ""
    for i, item in letterInserts {
        ; Собираем буквы через ;
        lettersStr := ""
        for j, letter in item.letters {
            lettersStr .= letter
            if (j < item.letters.Length())
                lettersStr .= ";"
        }
        ; Формат: letters;letters;...|position|n|count||
        dataStr .= lettersStr . "|" . item.position . "|" . item.n . "|" . item.count . "||"
    }
    
    IniWrite, %dataStr%, %appDataDir%\AutoTyper.ini, LetterInserts, Data
return

; ============================================
; === ЗАГРУЗКА БИНДОВ ПРИ СТАРТЕ ===
; ============================================

LoadBindTemplatesOnStart:
    global bindTemplates, appDataDir
    
    IniRead, savedBinds, %appDataDir%\AutoTyper.ini, BindTemplates, Data
    if (savedBinds = "ERROR" || savedBinds = "" || savedBinds = "empty")
        return
    
    bindTemplates := []
    items := StrSplit(savedBinds, "||")
    
    for i, item in items {
        if (item = "")
            continue
        parts := StrSplit(item, "|")
        if (parts.Length() >= 6) {
            bindTemplates.Push({hotkey: parts[1], text: parts[2], speedType: parts[3], speedValue: parts[4], textCase: parts[5], errorLevel: parts[6], enabled: true})
            
            Gui, 1:Default
            Gui, 1:ListView, BindTemplatesList
            LV_Add("", parts[1], parts[2], parts[3] . " " . parts[4], parts[5], parts[6], "Вкл")
            
            ; Регистрируем хоткей
            RegisterBindHotkey(bindTemplates.Length())
        }
    }
return

; ============================================
; === СОХРАНЕНИЕ БИНДОВ ПРИ ВЫХОДЕ ===
; ============================================

SaveBindTemplatesOnExit:
    global bindTemplates, appDataDir
    
    if (!bindTemplates || bindTemplates.Length() = 0) {
        IniWrite, empty, %appDataDir%\AutoTyper.ini, BindTemplates, Data
        return
    }
    
    dataStr := ""
    for i, item in bindTemplates {
        dataStr .= item.hotkey . "|" . item.text . "|" . item.speedType . "|" . item.speedValue . "|" . item.textCase . "|" . item.errorLevel . "||"
    }
    
    IniWrite, %dataStr%, %appDataDir%\AutoTyper.ini, BindTemplates, Data
return


; ============================================
; === ОБНОВЛЕНИЕ СПИСКА ШАБЛОНОВ ГЕНЕРАТОРА ===
; ============================================

RefreshGenTemplates:
    global genTemplatesDir, genCurrentCategory, genCurrentSubcategory
    
    ; Определяем папку для поиска
    if (genCurrentSubcategory != "")
        folder := genTemplatesDir . "\" . genCurrentCategory . "\" . genCurrentSubcategory
    else if (genCurrentCategory != "")
        folder := genTemplatesDir . "\" . genCurrentCategory
    else
        folder := genTemplatesDir
    
    ; Очищаем и заполняем список
    templateList := ""
    Loop, Files, %folder%\*.txt
    {
        name := SubStr(A_LoopFileName, 1, -4)
        templateList .= name . "|"
    }
    
    GuiControl,, GenTemplateList, |%templateList%
return

; ============================================
; === ДОБАВЛЕНИЕ КНОПОК ПЕРЕИМЕНОВАНИЯ В GUI ===
; ============================================

; Примечание: Кнопки переименования можно добавить в соответствующие вкладки
; через редактирование GUI секций выше. Обработчики уже готовы:
; - RenameGenPreset - для шаблонов генератора
; - RenameMainPreset - для шаблонов основного текста
; - RenameSettingsPreset - для пресетов настроек

; ============================================
; === СИСТЕМА ЗАХВАТА КЛАВИШ ДЛЯ БИНДОВ ===
; ============================================

CaptureInsertHotkey:
    global isCapturingHotkey, capturedHotkey, captureTargetControl
    isCapturingHotkey := true
    capturedHotkey := ""
    captureTargetControl := "InsertHotkey"
    GuiControl, InsertDialog:, InsertCaptureBtn, ⏳ Ждём...
    GuiControl, InsertDialog:, InsertHotkey, Нажмите клавишу...
    SetTimer, CaptureKeyboardInput, 50
return

CaptureAutoEnterBind:
    global isCapturingHotkey, capturedHotkey, captureTargetControl
    isCapturingHotkey := true
    capturedHotkey := ""
    captureTargetControl := "AutoEnterBindHotkey"
    GuiControl,, AutoEnterBindCapture, ⏳
    GuiControl,, AutoEnterBindHotkey, Нажмите клавишу...
    SetTimer, CaptureKeyboardInput, 50
return

CaptureControlStartHotkey:
    global isCapturingHotkey, capturedHotkey, captureTargetControl
    isCapturingHotkey := true
    capturedHotkey := ""
    captureTargetControl := "ControlStartHotkey"
    GuiControl,, ControlStartCapture, ⏳
    GuiControl,, ControlStartHotkey, Нажмите клавишу...
    SetTimer, CaptureKeyboardInput, 50
return

CaptureControlStopHotkey:
    global isCapturingHotkey, capturedHotkey, captureTargetControl
    isCapturingHotkey := true
    capturedHotkey := ""
    captureTargetControl := "ControlStopHotkey"
    GuiControl,, ControlStopCapture, ⏳
    GuiControl,, ControlStopHotkey, Нажмите клавишу...
    SetTimer, CaptureKeyboardInput, 50
return

CaptureControlPauseHotkey:
    global isCapturingHotkey, capturedHotkey, captureTargetControl
    isCapturingHotkey := true
    capturedHotkey := ""
    captureTargetControl := "ControlPauseHotkey"
    GuiControl,, ControlPauseCapture, ⏳
    GuiControl,, ControlPauseHotkey, Нажмите клавишу...
    SetTimer, CaptureKeyboardInput, 50
return

CaptureControlEmergencyHotkey:
    global isCapturingHotkey, capturedHotkey, captureTargetControl
    isCapturingHotkey := true
    capturedHotkey := ""
    captureTargetControl := "ControlEmergencyHotkey"
    GuiControl,, ControlEmergencyCapture, ⏳
    GuiControl,, ControlEmergencyHotkey, Нажмите клавишу...
    SetTimer, CaptureKeyboardInput, 50
return

CaptureKeyboardInput:
    global isCapturingHotkey, capturedHotkey, captureTargetControl
    
    if (!isCapturingHotkey) {
        SetTimer, CaptureKeyboardInput, Off
        return
    }
    
    ; Проверяем модификаторы
    mods := ""
    if GetKeyState("Ctrl", "P")
        mods .= "^"
    if GetKeyState("Alt", "P")
        mods .= "!"
    if GetKeyState("Shift", "P")
        mods .= "+"
    if GetKeyState("LWin", "P") || GetKeyState("RWin", "P")
        mods .= "#"
    
    ; Проверяем основные клавиши
    keyList := "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z"
    keyList .= ",0,1,2,3,4,5,6,7,8,9"
    keyList .= ",F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,F11,F12"
    keyList .= ",Space,Enter,Tab,Escape,Backspace,Delete,Insert,Home,End,PgUp,PgDn"
    keyList .= ",Up,Down,Left,Right"
    keyList .= ",Numpad0,Numpad1,Numpad2,Numpad3,Numpad4,Numpad5,Numpad6,Numpad7,Numpad8,Numpad9"
    
    Loop, Parse, keyList, `,
    {
        if GetKeyState(A_LoopField, "P") {
            capturedHotkey := mods . A_LoopField
            isCapturingHotkey := false
            SetTimer, CaptureKeyboardInput, Off
            
            ; Обновляем контрол
            if (captureTargetControl = "InsertHotkey") {
                GuiControl, InsertDialog:, InsertHotkey, %capturedHotkey%
                GuiControl, InsertDialog:, InsertCaptureBtn, 🎯 Захват
            } else if (captureTargetControl = "AutoEnterBindHotkey") {
                GuiControl,, AutoEnterBindHotkey, %capturedHotkey%
                GuiControl,, AutoEnterBindCapture, 🎯
            } else if (captureTargetControl = "ControlStartHotkey") {
                GuiControl,, ControlStartHotkey, %capturedHotkey%
                GuiControl,, ControlStartCapture, 🎯
            } else if (captureTargetControl = "ControlStopHotkey") {
                GuiControl,, ControlStopHotkey, %capturedHotkey%
                GuiControl,, ControlStopCapture, 🎯
            } else if (captureTargetControl = "ControlPauseHotkey") {
                GuiControl,, ControlPauseHotkey, %capturedHotkey%
                GuiControl,, ControlPauseCapture, 🎯
            } else if (captureTargetControl = "ControlEmergencyHotkey") {
                GuiControl,, ControlEmergencyHotkey, %capturedHotkey%
                GuiControl,, ControlEmergencyCapture, 🎯
            }
            return
        }
    }
return


; ============================================
; === ОБРАБОТЧИКИ AUTO-ENTER ЦИКЛОВ ===
; ============================================

AddAutoEnterCycle:
    Gui, Submit, NoHide
    global autoEnterCycles
    
    if (!autoEnterCycles)
        autoEnterCycles := []
    
    words := AutoEnterCycleWords + 0
    if (words <= 0) {
        MsgBox, 48, Ошибка, Введите количество слов больше 0!
        return
    }
    
    autoEnterCycles.Push({words: words, enabled: true})
    
    Gui, 1:Default
    Gui, 1:ListView, AutoEnterCyclesList
    cycleNum := autoEnterCycles.Length()
    LV_Add("", cycleNum, words . " слов", "Вкл")
    
    UpdateAutoEnterCycleInfo()
    SB_SetText("Цикл добавлен: " . words . " слов", 1)
return

EditAutoEnterCycle:
    Gui, 1:Default
    Gui, 1:ListView, AutoEnterCyclesList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите цикл для редактирования!
        return
    }
    
    global autoEnterCycles
    InputBox, newWords, Редактировать цикл, Введите новое количество слов:, , 300, 150, , , , , % autoEnterCycles[row].words
    if (ErrorLevel || newWords = "")
        return
    
    autoEnterCycles[row].words := newWords + 0
    LV_Modify(row, "", row, newWords . " слов", autoEnterCycles[row].enabled ? "Вкл" : "Выкл")
    UpdateAutoEnterCycleInfo()
return

DeleteAutoEnterCycle:
    Gui, 1:Default
    Gui, 1:ListView, AutoEnterCyclesList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите цикл для удаления!
        return
    }
    
    global autoEnterCycles
    autoEnterCycles.RemoveAt(row)
    LV_Delete(row)
    
    ; Перенумеруем
    Loop, % LV_GetCount()
        LV_Modify(A_Index, "", A_Index)
    
    UpdateAutoEnterCycleInfo()
return

ClearAutoEnterCycles:
    MsgBox, 36, Подтверждение, Удалить все циклы Auto-Enter?
    IfMsgBox, No
        return
    
    global autoEnterCycles
    autoEnterCycles := []
    
    Gui, 1:Default
    Gui, 1:ListView, AutoEnterCyclesList
    LV_Delete()
    
    UpdateAutoEnterCycleInfo()
return

UpdateAutoEnterCycleInfo() {
    global autoEnterCycles
    
    if (!autoEnterCycles || autoEnterCycles.Length() = 0) {
        GuiControl,, AutoEnterCycleInfo, Нет циклов. Добавьте циклы для работы.
        return
    }
    
    info := ""
    for i, cycle in autoEnterCycles {
        info .= "Цикл " . i . ": " . cycle.words . " сл."
        if (i < autoEnterCycles.Length())
            info .= " → "
    }
    
    GuiControl,, AutoEnterCycleInfo, %info%
}


; ============================================
; === ОБРАБОТЧИКИ БИНДОВ AUTO-ENTER ===
; ============================================

AddAutoEnterBind:
    Gui, Submit, NoHide
    global autoEnterBinds, AutoEnterBindHotkey, AutoEnterBindAction
    
    if (!autoEnterBinds)
        autoEnterBinds := []
    
    if (AutoEnterBindHotkey = "" || AutoEnterBindHotkey = "Нажмите клавишу...") {
        MsgBox, 48, Ошибка, Сначала захватите горячую клавишу!
        return
    }
    
    autoEnterBinds.Push({hotkey: AutoEnterBindHotkey, action: AutoEnterBindAction, enabled: true})
    
    Gui, 1:Default
    Gui, 1:ListView, AutoEnterBindsList
    LV_Add("", AutoEnterBindHotkey, AutoEnterBindAction, "Вкл")
    
    ; Регистрируем хоткей
    RegisterAutoEnterBind(autoEnterBinds.Length())
    
    GuiControl,, AutoEnterBindHotkey,
    SB_SetText("Бинд Auto-Enter добавлен: " . AutoEnterBindHotkey, 1)
return

DeleteAutoEnterBind:
    Gui, 1:Default
    Gui, 1:ListView, AutoEnterBindsList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите бинд для удаления!
        return
    }
    
    global autoEnterBinds
    
    ; Отключаем хоткей
    try Hotkey, % autoEnterBinds[row].hotkey, Off
    
    autoEnterBinds.RemoveAt(row)
    LV_Delete(row)
return

RegisterAutoEnterBind(index) {
    global autoEnterBinds
    item := autoEnterBinds[index]
    
    if (!item.enabled)
        return
    
    try {
        fn := Func("ExecuteAutoEnterBind").Bind(index)
        Hotkey, % item.hotkey, %fn%, On
    }
}

ExecuteAutoEnterBind(index) {
    global autoEnterBinds, autoEnterCurrentCycle, autoEnterCycles, AutoEnterMode
    
    item := autoEnterBinds[index]
    
    if (item.action = "Следующий цикл") {
        autoEnterCurrentCycle++
        if (autoEnterCurrentCycle > autoEnterCycles.Length())
            autoEnterCurrentCycle := 1
    } else if (item.action = "Предыдущий цикл") {
        autoEnterCurrentCycle--
        if (autoEnterCurrentCycle < 1)
            autoEnterCurrentCycle := autoEnterCycles.Length()
    } else if (item.action = "Сброс циклов") {
        autoEnterCurrentCycle := 1
    } else if (item.action = "Вкл/Выкл Auto-Enter") {
        ; Переключаем режим
        if (AutoEnterMode = 1)
            GuiControl,, AutoEnterMode, 4
        else
            GuiControl,, AutoEnterMode, 1
    }
    
    UpdateAutoEnterTestStatus()
}

TestAutoEnter:
    UpdateAutoEnterTestStatus()
    MsgBox, 64, Тест Auto-Enter, Текущий статус обновлён в интерфейсе.
return

UpdateAutoEnterTestStatus() {
    global AutoEnterMode, autoEnterCurrentCycle, autoEnterCycles
    
    Gui, Submit, NoHide
    
    modeText := "Отключено"
    if (AutoEnterMode = 2)
        modeText := "Макс. слов"
    else if (AutoEnterMode = 3)
        modeText := "По времени"
    else if (AutoEnterMode = 4)
        modeText := "По циклам"
    else if (AutoEnterMode = 5)
        modeText := "По биндам"
    
    cycleWords := 0
    if (autoEnterCycles && autoEnterCycles.Length() >= autoEnterCurrentCycle)
        cycleWords := autoEnterCycles[autoEnterCurrentCycle].words
    
    status := "Статус: " . modeText . " | Текущий цикл: " . autoEnterCurrentCycle . " | Слов: " . cycleWords
    GuiControl,, AutoEnterTestStatus, %status%
}


; ============================================
; === ОБРАБОТЧИКИ ПРЕСЕТОВ БИНДОВ ===
; ============================================

SaveBindPreset:
    global bindTemplates, bindPresetsDir
    
    if (!bindTemplates || bindTemplates.Length() = 0) {
        MsgBox, 48, Ошибка, Нет шаблонов для сохранения!
        return
    }
    
    InputBox, presetName, Сохранить пресет, Введите имя пресета:, , 300, 150
    if (ErrorLevel || presetName = "")
        return
    
    filePath := bindPresetsDir . "\" . presetName . ".txt"
    
    content := ""
    for i, item in bindTemplates {
        content .= item.hotkey . "|" . item.text . "|" . item.speedType . "|" . item.speedValue . "|" . item.textCase . "|" . item.errorLevel . "`n"
    }
    
    FileDelete, %filePath%
    FileAppend, %content%, %filePath%, UTF-8
    
    RefreshBindPresetsList()
    MsgBox, 64, Успех, Пресет "%presetName%" сохранён!
return

LoadBindPreset:
    Gui, Submit, NoHide
    global bindTemplates, bindPresetsDir, BindPresetList
    
    if (BindPresetList = "") {
        MsgBox, 48, Ошибка, Выберите пресет для загрузки!
        return
    }
    
    filePath := bindPresetsDir . "\" . BindPresetList . ".txt"
    
    if (!FileExist(filePath)) {
        MsgBox, 48, Ошибка, Файл пресета не найден!
        return
    }
    
    ; Очищаем текущие бинды
    for i, item in bindTemplates {
        try Hotkey, % item.hotkey, Off
    }
    bindTemplates := []
    
    Gui, 1:Default
    Gui, 1:ListView, BindTemplatesList
    LV_Delete()
    
    ; Загружаем из файла
    FileRead, content, %filePath%
    Loop, Parse, content, `n, `r
    {
        if (A_LoopField = "")
            continue
        parts := StrSplit(A_LoopField, "|")
        if (parts.Length() >= 6) {
            bindTemplates.Push({hotkey: parts[1], text: parts[2], speedType: parts[3], speedValue: parts[4], textCase: parts[5], errorLevel: parts[6], enabled: true})
            LV_Add("", parts[1], parts[2], parts[3] . " " . parts[4], parts[5], parts[6], "Вкл")
            RegisterBindHotkey(bindTemplates.Length())
        }
    }
    
    SB_SetText("Пресет загружен: " . BindPresetList, 1)
return

DeleteBindPreset:
    Gui, Submit, NoHide
    global bindPresetsDir, BindPresetList
    
    if (BindPresetList = "") {
        MsgBox, 48, Ошибка, Выберите пресет для удаления!
        return
    }
    
    MsgBox, 36, Подтверждение, Удалить пресет "%BindPresetList%"?
    IfMsgBox, No
        return
    
    filePath := bindPresetsDir . "\" . BindPresetList . ".txt"
    FileDelete, %filePath%
    
    RefreshBindPresetsList()
    SB_SetText("Пресет удалён", 1)
return

RefreshBindPresets:
    RefreshBindPresetsList()
return

RefreshBindPresetsList() {
    global bindPresetsDir
    
    if (!FileExist(bindPresetsDir))
        FileCreateDir, %bindPresetsDir%
    
    presetList := ""
    Loop, Files, %bindPresetsDir%\*.txt
    {
        name := SubStr(A_LoopFileName, 1, -4)
        presetList .= name . "|"
    }
    
    GuiControl,, BindPresetList, |%presetList%
}


; ============================================
; === ОБРАБОТЧИКИ ВАРИАЦИЙ БИНДОВ ===
; ============================================

AddBindVariation:
    Gui, 1:Default
    Gui, 1:ListView, BindTemplatesList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Сначала выберите шаблон бинда!
        return
    }
    
    InputBox, variation, Добавить вариацию, Введите текст вариации:, , 400, 150
    if (ErrorLevel || variation = "")
        return
    
    global bindTemplates
    if (!bindTemplates[row].HasKey("variations"))
        bindTemplates[row].variations := []
    
    bindTemplates[row].variations.Push(variation)
    
    Gui, 1:ListView, BindVariationsList
    LV_Add("", variation)
    
    SB_SetText("Вариация добавлена", 1)
return

DeleteBindVariation:
    Gui, 1:Default
    Gui, 1:ListView, BindVariationsList
    varRow := LV_GetNext()
    if (varRow = 0) {
        MsgBox, 48, Ошибка, Выберите вариацию для удаления!
        return
    }
    
    Gui, 1:ListView, BindTemplatesList
    bindRow := LV_GetNext()
    if (bindRow = 0)
        return
    
    global bindTemplates
    if (bindTemplates[bindRow].HasKey("variations"))
        bindTemplates[bindRow].variations.RemoveAt(varRow)
    
    Gui, 1:ListView, BindVariationsList
    LV_Delete(varRow)
return

; ============================================
; === ОБРАБОТЧИКИ ВСТАВОК СЛОВ ДЛЯ БИНДОВ ===
; ============================================

AddBindWordInsert:
    Gui, Submit, NoHide
    global bindWordInserts, BindWordInsertText, BindWordInsertPos
    
    if (!bindWordInserts)
        bindWordInserts := []
    
    if (BindWordInsertText = "") {
        MsgBox, 48, Ошибка, Введите слово для вставки!
        return
    }
    
    bindWordInserts.Push({word: BindWordInsertText, position: BindWordInsertPos, enabled: true})
    
    Gui, 1:Default
    Gui, 1:ListView, BindWordInsertsList
    LV_Add("", BindWordInsertText, BindWordInsertPos)
    
    GuiControl,, BindWordInsertText,
    SB_SetText("Вставка слова добавлена", 1)
return

DeleteBindWordInsert:
    Gui, 1:Default
    Gui, 1:ListView, BindWordInsertsList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите вставку для удаления!
        return
    }
    
    global bindWordInserts
    bindWordInserts.RemoveAt(row)
    LV_Delete(row)
return

; ============================================
; === ОБРАБОТЧИКИ ВСТАВОК БУКВ ДЛЯ БИНДОВ ===
; ============================================

AddBindLetterInsert:
    Gui, Submit, NoHide
    global bindLetterInserts, BindLetterInsertChar, BindLetterInsertFreq
    
    if (!bindLetterInserts)
        bindLetterInserts := []
    
    if (BindLetterInsertChar = "") {
        MsgBox, 48, Ошибка, Введите букву для вставки!
        return
    }
    
    bindLetterInserts.Push({letter: BindLetterInsertChar, frequency: BindLetterInsertFreq, enabled: true})
    
    Gui, 1:Default
    Gui, 1:ListView, BindLetterInsertsList
    LV_Add("", BindLetterInsertChar, BindLetterInsertFreq . "%")
    
    GuiControl,, BindLetterInsertChar,
    SB_SetText("Вставка буквы добавлена", 1)
return

DeleteBindLetterInsert:
    Gui, 1:Default
    Gui, 1:ListView, BindLetterInsertsList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите вставку для удаления!
        return
    }
    
    global bindLetterInserts
    bindLetterInserts.RemoveAt(row)
    LV_Delete(row)
return


; ============================================
; === ДОПОЛНИТЕЛЬНЫЕ ОБРАБОТЧИКИ ===
; ============================================

DuplicateBindTemplate:
    Gui, 1:Default
    Gui, 1:ListView, BindTemplatesList
    row := LV_GetNext()
    if (row = 0) {
        MsgBox, 48, Ошибка, Выберите шаблон для копирования!
        return
    }
    
    global bindTemplates
    item := bindTemplates[row]
    
    ; Создаём копию
    newItem := {}
    newItem.hotkey := item.hotkey . "_copy"
    newItem.text := item.text
    newItem.speedType := item.speedType
    newItem.speedValue := item.speedValue
    newItem.textCase := item.textCase
    newItem.errorLevel := item.errorLevel
    newItem.enabled := false
    
    bindTemplates.Push(newItem)
    LV_Add("", newItem.hotkey, newItem.text, newItem.speedType . " " . newItem.speedValue, newItem.textCase, newItem.errorLevel, "Выкл")
    
    SB_SetText("Шаблон скопирован", 1)
return

ExportBindTemplates:
    global bindTemplates, bindPresetsDir
    
    if (!bindTemplates || bindTemplates.Length() = 0) {
        MsgBox, 48, Ошибка, Нет шаблонов для экспорта!
        return
    }
    
    FileSelectFile, exportFile, S16, %bindPresetsDir%\binds_export.txt, Экспорт биндов, Текстовые файлы (*.txt)
    if (exportFile = "")
        return
    
    content := ""
    for i, item in bindTemplates {
        content .= item.hotkey . "|" . item.text . "|" . item.speedType . "|" . item.speedValue . "|" . item.textCase . "|" . item.errorLevel . "`n"
    }
    
    FileDelete, %exportFile%
    FileAppend, %content%, %exportFile%, UTF-8
    
    MsgBox, 64, Успех, Бинды экспортированы в:`n%exportFile%
return

OpenBindsFolder:
    global bindPresetsDir
    if (!FileExist(bindPresetsDir))
        FileCreateDir, %bindPresetsDir%
    Run, %bindPresetsDir%
return

; ============================================
; === ОБРАБОТЧИКИ ОСНОВНОГО ТЕКСТА ===
; ============================================

ClearMainText:
    MsgBox, 36, Подтверждение, Очистить основной текст?
    IfMsgBox, No
        return
    GuiControl,, TypeText,
    Gosub, UpdateMainTextCharCount
    SB_SetText("Текст очищен", 1)
return

CopyMainText:
    Gui, Submit, NoHide
    Clipboard := TypeText
    SB_SetText("Текст скопирован в буфер", 1)
return

PasteMainText:
    GuiControl,, TypeText, %Clipboard%
    Gosub, UpdateMainTextCharCount
    SB_SetText("Текст вставлен из буфера", 1)
return

OpenTextFolder:
    global presetDir
    if (!FileExist(presetDir))
        FileCreateDir, %presetDir%
    Run, %presetDir%
return

RefreshCategories:
    LoadCategories()
    SB_SetText("Категории обновлены", 1)
return

; ============================================
; === ОБРАБОТЧИКИ TREEVIEW ОСНОВНОГО ТЕКСТА ===
; ============================================

MainTextTreeSelect:
    global MainTextTree, TypeText, presetDir, templatesDir
    
    ; Устанавливаем правильный GUI и TreeView
    Gui, 1:Default
    Gui, 1:TreeView, MainTextTree
    
    ; Проверяем, был ли двойной клик (A_GuiEvent = "DoubleClick" или "Normal")
    if (A_GuiEvent != "DoubleClick" && A_GuiEvent != "Normal")
        return
    
    ; Получаем выбранный элемент
    selectedItem := TV_GetSelection()
    if (!selectedItem)
        return
    
    ; Получаем текст элемента
    TV_GetText(itemText, selectedItem)
    
    ; Убираем заметки из названия (всё после " 📝 ")
    if (InStr(itemText, " 📝 ")) {
        itemText := SubStr(itemText, 1, InStr(itemText, " 📝 ") - 1)
    }
    
    ; Получаем родительский элемент
    parentItem := TV_GetParent(selectedItem)
    
    ; Определяем путь к файлу
    if (parentItem) {
        TV_GetText(parentText, parentItem)
        grandParentItem := TV_GetParent(parentItem)
        
        if (grandParentItem) {
            ; Это шаблон в подкатегории
            TV_GetText(grandParentText, grandParentItem)
            filePath := presetDir . "\" . grandParentText . "\" . parentText . "\" . itemText . ".txt"
            notesPath := presetDir . "\" . grandParentText . "\" . parentText . "\" . itemText . ".notes"
        } else {
            ; Это шаблон в категории или подкатегория
            if (FileExist(presetDir . "\" . parentText . "\" . itemText . ".txt")) {
                filePath := presetDir . "\" . parentText . "\" . itemText . ".txt"
                notesPath := presetDir . "\" . parentText . "\" . itemText . ".notes"
            } else {
                ; Это подкатегория, только при двойном клике разворачиваем
                if (A_GuiEvent = "DoubleClick")
                    TV_Modify(selectedItem, "Expand")
                return
            }
        }
    } else {
        ; Это категория, только при двойном клике разворачиваем
        if (A_GuiEvent = "DoubleClick")
            TV_Modify(selectedItem, "Expand")
        return
    }
    
    ; Загружаем содержимое файла только при двойном клике
    if (A_GuiEvent = "DoubleClick" && FileExist(filePath)) {
        FileRead, content, %filePath%
        GuiControl,, TypeText, %content%
        Gosub, UpdateMainTextCharCount
        
        ; Загружаем заметки если существуют
        if (FileExist(notesPath)) {
            FileRead, notesContent, %notesPath%
            GuiControl,, TemplateNotes, %notesContent%
        } else {
            GuiControl,, TemplateNotes,
        }
        Gosub, UpdateTemplateNotesCount
        
        GuiControl,, MainTreePath, Путь: %filePath%
        SB_SetText("✓ Загружен: " . itemText . " (текст + заметки)", 1)
    }
return

MainTreeRefresh:
    LoadMainTextTree()
    SB_SetText("Дерево шаблонов обновлено", 1)
return

MainTreeExpand:
    ; Разворачиваем все элементы дерева
    TV_Modify(0, "Expand")
    SB_SetText("Дерево развёрнуто", 1)
return

MainTreeNewCategory:
    InputBox, catName, Новая категория, Введите название категории:, , 300, 130
    if (ErrorLevel || catName = "")
        return
    
    newPath := presetDir . "\" . catName
    if (FileExist(newPath)) {
        MsgBox, 48, Ошибка, Категория уже существует!
        return
    }
    
    FileCreateDir, %newPath%
    LoadMainTextTree()
    SB_SetText("Категория создана: " . catName, 1)
return

MainTreeNewSubcat:
    selectedItem := TV_GetSelection()
    if (!selectedItem) {
        MsgBox, 48, Ошибка, Выберите категорию!
        return
    }
    
    TV_GetText(parentText, selectedItem)
    
    InputBox, subcatName, Новая подкатегория, Введите название подкатегории:, , 300, 130
    if (ErrorLevel || subcatName = "")
        return
    
    newPath := presetDir . "\" . parentText . "\" . subcatName
    if (FileExist(newPath)) {
        MsgBox, 48, Ошибка, Подкатегория уже существует!
        return
    }
    
    FileCreateDir, %newPath%
    LoadMainTextTree()
    SB_SetText("Подкатегория создана: " . subcatName, 1)
return

MainTreeNewTemplate:
    selectedItem := TV_GetSelection()
    if (!selectedItem) {
        MsgBox, 48, Ошибка, Выберите категорию или подкатегорию!
        return
    }
    
    TV_GetText(parentText, selectedItem)
    parentItem := TV_GetParent(selectedItem)
    
    InputBox, templateName, Новый шаблон, Введите название шаблона:, , 300, 130
    if (ErrorLevel || templateName = "")
        return
    
    if (parentItem) {
        TV_GetText(grandParentText, parentItem)
        filePath := presetDir . "\" . grandParentText . "\" . parentText . "\" . templateName . ".txt"
    } else {
        filePath := presetDir . "\" . parentText . "\" . templateName . ".txt"
    }
    
    if (FileExist(filePath)) {
        MsgBox, 48, Ошибка, Шаблон уже существует!
        return
    }
    
    FileAppend, , %filePath%
    LoadMainTextTree()
    SB_SetText("Шаблон создан: " . templateName, 1)
return

MainTreeDelete:
    selectedItem := TV_GetSelection()
    if (!selectedItem) {
        MsgBox, 48, Ошибка, Выберите элемент для удаления!
        return
    }
    
    TV_GetText(itemText, selectedItem)
    
    ; Убираем заметки из названия (всё после " 📝 ")
    if (InStr(itemText, " 📝 ")) {
        itemText := SubStr(itemText, 1, InStr(itemText, " 📝 ") - 1)
    }
    
    MsgBox, 36, Подтверждение, Удалить "%itemText%"?
    IfMsgBox, No
        return
    
    ; Определяем путь и удаляем
    parentItem := TV_GetParent(selectedItem)
    if (parentItem) {
        TV_GetText(parentText, parentItem)
        grandParentItem := TV_GetParent(parentItem)
        
        if (grandParentItem) {
            TV_GetText(grandParentText, grandParentItem)
            targetPath := presetDir . "\" . grandParentText . "\" . parentText . "\" . itemText . ".txt"
            FileDelete, %targetPath%
        } else {
            targetPath := presetDir . "\" . parentText . "\" . itemText
            if (InStr(FileExist(targetPath), "D")) {
                FileRemoveDir, %targetPath%, 1
            } else {
                FileDelete, %targetPath%.txt
            }
        }
    } else {
        targetPath := presetDir . "\" . itemText
        FileRemoveDir, %targetPath%, 1
    }
    
    LoadMainTextTree()
    SB_SetText("Удалено: " . itemText, 1)
return

MainTextChanged:
    Gosub, UpdateMainTextCharCount
    ; Словарь: фиксируем ввод TypeText (внутри AutoTyper) с debounce, чтобы не писать в файл на каждый символ
    if (dictEnabled && dictCaptureTypeTextEdits) {
        Gui, 1:Submit, NoHide
        DictScheduleTypeTextCapture(TypeText)
    }
return

MainTextSave:
    Gui, 1:Submit, NoHide
    selectedItem := TV_GetSelection()
    if (!selectedItem) {
        MsgBox, 48, Ошибка, Выберите шаблон для сохранения!
        return
    }
    
    TV_GetText(itemText, selectedItem)
    parentItem := TV_GetParent(selectedItem)
    
    if (!parentItem) {
        MsgBox, 48, Ошибка, Выберите шаблон, а не категорию!
        return
    }
    
    TV_GetText(parentText, parentItem)
    grandParentItem := TV_GetParent(parentItem)
    
    if (grandParentItem) {
        TV_GetText(grandParentText, grandParentItem)
        filePath := presetDir . "\" . grandParentText . "\" . parentText . "\" . itemText . ".txt"
        notesPath := presetDir . "\" . grandParentText . "\" . parentText . "\" . itemText . ".notes"
    } else {
        filePath := presetDir . "\" . parentText . "\" . itemText . ".txt"
        notesPath := presetDir . "\" . parentText . "\" . itemText . ".notes"
    }
    
    ; Сохраняем текст
    FileDelete, %filePath%
    FileAppend, %TypeText%, %filePath%
    
    ; Сохраняем заметки
    FileDelete, %notesPath%
    if (TemplateNotes != "")
        FileAppend, %TemplateNotes%, %notesPath%
    
    SB_SetText("✓ Сохранено: " . itemText . " (текст + заметки)", 1)
return

MainTextLoad:
    global MainTextTree, TypeText, presetDir
    
    ; Устанавливаем правильный GUI и TreeView
    Gui, 1:Default
    Gui, 1:TreeView, MainTextTree
    
    ; Получаем выбранный элемент
    selectedItem := TV_GetSelection()
    if (!selectedItem) {
        MsgBox, 48, Ошибка, Выберите шаблон в дереве!
        return
    }
    
    ; Получаем текст элемента
    TV_GetText(itemText, selectedItem)
    
    ; Получаем родительский элемент
    parentItem := TV_GetParent(selectedItem)
    
    ; Определяем путь к файлу
    if (parentItem) {
        TV_GetText(parentText, parentItem)
        grandParentItem := TV_GetParent(parentItem)
        
        if (grandParentItem) {
            ; Это шаблон в подкатегории
            TV_GetText(grandParentText, grandParentItem)
            filePath := presetDir . "\" . grandParentText . "\" . parentText . "\" . itemText . ".txt"
            notesPath := presetDir . "\" . grandParentText . "\" . parentText . "\" . itemText . ".notes"
        } else {
            ; Это шаблон в категории или подкатегория
            if (FileExist(presetDir . "\" . parentText . "\" . itemText . ".txt")) {
                filePath := presetDir . "\" . parentText . "\" . itemText . ".txt"
                notesPath := presetDir . "\" . parentText . "\" . itemText . ".notes"
            } else {
                MsgBox, 48, Ошибка, Выберите шаблон, а не папку!
                return
            }
        }
    } else {
        MsgBox, 48, Ошибка, Выберите шаблон, а не категорию!
        return
    }
    
    ; Загружаем содержимое файла
    if (FileExist(filePath)) {
        FileRead, content, %filePath%
        GuiControl,, TypeText, %content%
        Gosub, UpdateMainTextCharCount
        
        ; Загружаем заметки если существуют
        if (FileExist(notesPath)) {
            FileRead, notesContent, %notesPath%
            GuiControl,, TemplateNotes, %notesContent%
        } else {
            GuiControl,, TemplateNotes,
        }
        Gosub, UpdateTemplateNotesCount
        
        GuiControl,, MainTreePath, Путь: %filePath%
        SB_SetText("✓ Загружен: " . itemText . " (текст + заметки)", 1)
    } else {
        MsgBox, 48, Ошибка, Файл не найден: %filePath%
    }
return

MainTextClear:
    GuiControl,, TypeText,
    GuiControl,, TemplateNotes,
    Gosub, UpdateMainTextCharCount
    Gosub, UpdateTemplateNotesCount
    SB_SetText("Текст и заметки очищены", 1)
return

MainTextCopy:
    Gui, 1:Submit, NoHide
    Clipboard := TypeText
    SB_SetText("Текст скопирован в буфер", 1)
return

MainTextPaste:
    GuiControl,, TypeText, %Clipboard%
    Gosub, UpdateMainTextCharCount
    SB_SetText("Текст вставлен из буфера", 1)
return

MainTextToSlots:
    Gosub, ImportToSlots
return

MainTextRename:
    selectedItem := TV_GetSelection()
    if (!selectedItem) {
        MsgBox, 48, Ошибка, Выберите элемент для переименования!
        return
    }
    
    TV_GetText(oldName, selectedItem)
    
    ; Убираем заметки из названия (всё после " 📝 ")
    if (InStr(oldName, " 📝 ")) {
        oldName := SubStr(oldName, 1, InStr(oldName, " 📝 ") - 1)
    }
    
    ; Создаём диалог переименования с поддержкой эмодзи
    Gui, RenameDialog:Destroy
    Gui, RenameDialog:New, +Owner1, ✏️ Переименование
    Gui, RenameDialog:Font, s10, Segoe UI
    
    Gui, RenameDialog:Add, GroupBox, x10 y10 w480 h80, 📝 Новое название
    Gui, RenameDialog:Add, Edit, vRenameNewName x20 y30 w460 h20, %oldName%
    Gui, RenameDialog:Add, Text, x20 y55 w460 cGray, Можно использовать эмодзи: 📁 📝 ⭐ 🔥 💡 🎯 ✅ ❌ 🚀 💾
    
    Gui, RenameDialog:Add, GroupBox, x10 y100 w480 h120, 😀 Быстрые эмодзи
    Gui, RenameDialog:Add, Button, x20 y120 w40 h30 gAddEmoji, 📁
    Gui, RenameDialog:Add, Button, x65 y120 w40 h30 gAddEmoji, 📝
    Gui, RenameDialog:Add, Button, x110 y120 w40 h30 gAddEmoji, ⭐
    Gui, RenameDialog:Add, Button, x155 y120 w40 h30 gAddEmoji, 🔥
    Gui, RenameDialog:Add, Button, x200 y120 w40 h30 gAddEmoji, 💡
    Gui, RenameDialog:Add, Button, x245 y120 w40 h30 gAddEmoji, 🎯
    Gui, RenameDialog:Add, Button, x290 y120 w40 h30 gAddEmoji, ✅
    Gui, RenameDialog:Add, Button, x335 y120 w40 h30 gAddEmoji, ❌
    Gui, RenameDialog:Add, Button, x380 y120 w40 h30 gAddEmoji, 🚀
    Gui, RenameDialog:Add, Button, x425 y120 w40 h30 gAddEmoji, 💾
    
    Gui, RenameDialog:Add, Button, x20 y155 w40 h30 gAddEmoji, 🎮
    Gui, RenameDialog:Add, Button, x65 y155 w40 h30 gAddEmoji, 🎨
    Gui, RenameDialog:Add, Button, x110 y155 w40 h30 gAddEmoji, 🎵
    Gui, RenameDialog:Add, Button, x155 y155 w40 h30 gAddEmoji, 🎬
    Gui, RenameDialog:Add, Button, x200 y155 w40 h30 gAddEmoji, 📊
    Gui, RenameDialog:Add, Button, x245 y155 w40 h30 gAddEmoji, 📈
    Gui, RenameDialog:Add, Button, x290 y155 w40 h30 gAddEmoji, 🔔
    Gui, RenameDialog:Add, Button, x335 y155 w40 h30 gAddEmoji, 🔒
    Gui, RenameDialog:Add, Button, x380 y155 w40 h30 gAddEmoji, 🌟
    Gui, RenameDialog:Add, Button, x425 y155 w40 h30 gAddEmoji, 💬
    
    Gui, RenameDialog:Add, Button, x20 y190 w40 h30 gAddEmoji, 🏆
    Gui, RenameDialog:Add, Button, x65 y190 w40 h30 gAddEmoji, 🎁
    Gui, RenameDialog:Add, Button, x110 y190 w40 h30 gAddEmoji, 🌈
    Gui, RenameDialog:Add, Button, x155 y190 w40 h30 gAddEmoji, ⚡
    Gui, RenameDialog:Add, Button, x200 y190 w40 h30 gAddEmoji, 🔧
    Gui, RenameDialog:Add, Button, x245 y190 w40 h30 gAddEmoji, ⚙️
    Gui, RenameDialog:Add, Button, x290 y190 w40 h30 gAddEmoji, 🛠️
    Gui, RenameDialog:Add, Button, x335 y190 w40 h30 gAddEmoji, 📌
    Gui, RenameDialog:Add, Button, x380 y190 w40 h30 gAddEmoji, 🔖
    Gui, RenameDialog:Add, Button, x425 y190 w40 h30 gAddEmoji, 📎
    
    Gui, RenameDialog:Add, Button, x150 y230 w90 h30 gRenameDialogOK, ✅ OK
    Gui, RenameDialog:Add, Button, x250 y230 w90 h30 gRenameDialogCancel, ❌ Отмена
    
    Gui, RenameDialog:Show, w500 h270
return

AddEmoji:
    GuiControlGet, currentText, RenameDialog:, RenameNewName
    GuiControlGet, emojiBtn,, %A_GuiControl%
    GuiControl, RenameDialog:, RenameNewName, %currentText%%emojiBtn% 
    GuiControl, RenameDialog:Focus, RenameNewName
return

RenameDialogOK:
    Gui, RenameDialog:Submit, NoHide
    
    if (RenameNewName = "" || RenameNewName = oldName) {
        Gui, RenameDialog:Destroy
        return
    }
    
    ; Получаем путь к файлу
    selectedItem := TV_GetSelection()
    parentItem := TV_GetParent(selectedItem)
    
    if (parentItem) {
        TV_GetText(parentText, parentItem)
        grandParentItem := TV_GetParent(parentItem)
        
        if (grandParentItem) {
            ; Это шаблон в подкатегории
            TV_GetText(grandParentText, grandParentItem)
            oldPath := templatesDir . "\" . grandParentText . "\" . parentText . "\" . oldName . ".txt"
            newPath := templatesDir . "\" . grandParentText . "\" . parentText . "\" . RenameNewName . ".txt"
            notesOldPath := templatesDir . "\" . grandParentText . "\" . parentText . "\" . oldName . ".notes"
            notesNewPath := templatesDir . "\" . grandParentText . "\" . parentText . "\" . RenameNewName . ".notes"
        } else {
            ; Это шаблон в категории или подкатегория
            if (FileExist(templatesDir . "\" . parentText . "\" . oldName . ".txt")) {
                oldPath := templatesDir . "\" . parentText . "\" . oldName . ".txt"
                newPath := templatesDir . "\" . parentText . "\" . RenameNewName . ".txt"
                notesOldPath := templatesDir . "\" . parentText . "\" . oldName . ".notes"
                notesNewPath := templatesDir . "\" . parentText . "\" . RenameNewName . ".notes"
            } else {
                ; Это подкатегория
                oldPath := templatesDir . "\" . parentText . "\" . oldName
                newPath := templatesDir . "\" . parentText . "\" . RenameNewName
            }
        }
    } else {
        ; Это категория
        oldPath := templatesDir . "\" . oldName
        newPath := templatesDir . "\" . RenameNewName
    }
    
    ; Переименовываем
    if (FileExist(oldPath)) {
        if (InStr(FileExist(oldPath), "D")) {
            ; Это папка
            FileMoveDir, %oldPath%, %newPath%, 2
        } else {
            ; Это файл
            FileMove, %oldPath%, %newPath%, 1
            ; Переименовываем файл заметок если существует
            if (FileExist(notesOldPath))
                FileMove, %notesOldPath%, %notesNewPath%, 1
        }
        
        ; Обновляем TreeView
        TV_Modify(selectedItem, "", RenameNewName)
        SB_SetText("✓ Переименовано: " . oldName . " → " . RenameNewName, 1)
    } else {
        MsgBox, 48, Ошибка, Файл или папка не найдены!
    }
    
    Gui, RenameDialog:Destroy
return

RenameDialogCancel:
    Gui, RenameDialog:Destroy
return

MainTextMove:
    MsgBox, 64, Информация, Функция перемещения в разработке
return

UpdateMainTextCharCount:
    Gui, 1:Submit, NoHide
    charCount := StrLen(TypeText)
    wordCount := CountWords(TypeText)
    lineCount := CountLines(TypeText)
    GuiControl,, TypeTextCharCount, %charCount% символов | %wordCount% слов | %lineCount% строк
return

TemplateNotesChanged:
    Gosub, UpdateTemplateNotesCount
return

UpdateTemplateNotesCount:
    Gui, 1:Submit, NoHide
    notesCharCount := StrLen(TemplateNotes)
    GuiControl,, TemplateNotesCount, Заметок: %notesCharCount% символов
return

; ============================================
; === ОБРАБОТЧИКИ TREEVIEW ГЕНЕРАТОРА ===
; ============================================

GenTextTreeSelect:
    global GenTextTree, GenTemplateContent, genTemplatesDir
    global genCurrentTemplate, genCurrentCategory, genCurrentSubcategory
    
    ; Устанавливаем правильный GUI и TreeView
    Gui, 1:Default
    Gui, 1:TreeView, GenTextTree
    
    ; Проверяем тип события
    if (A_GuiEvent != "DoubleClick" && A_GuiEvent != "Normal")
        return
    
    selectedItem := TV_GetSelection()
    if (!selectedItem)
        return
    
    TV_GetText(itemText, selectedItem)
    parentItem := TV_GetParent(selectedItem)
    
    if (parentItem) {
        TV_GetText(parentText, parentItem)
        grandParentItem := TV_GetParent(parentItem)
        
        if (grandParentItem) {
            TV_GetText(grandParentText, grandParentItem)
            filePath := genTemplatesDir . "\" . grandParentText . "\" . parentText . "\" . itemText . ".txt"
            genCurrentCategory := grandParentText
            genCurrentSubcategory := parentText
            genCurrentTemplate := itemText
        } else {
            if (FileExist(genTemplatesDir . "\" . parentText . "\" . itemText . ".txt")) {
                filePath := genTemplatesDir . "\" . parentText . "\" . itemText . ".txt"
                genCurrentCategory := parentText
                genCurrentSubcategory := ""
                genCurrentTemplate := itemText
            } else {
                ; Это подкатегория, разворачиваем при двойном клике
                if (A_GuiEvent = "DoubleClick")
                    TV_Modify(selectedItem, "Expand")
                return
            }
        }
    } else {
        ; Это категория, разворачиваем при двойном клике
        if (A_GuiEvent = "DoubleClick")
            TV_Modify(selectedItem, "Expand")
        return
    }
    
    ; Загружаем при двойном клике
    if (A_GuiEvent = "DoubleClick" && FileExist(filePath)) {
        FileRead, content, %filePath%
        GuiControl,, GenTemplateContent, %content%
        GuiControl,, GenTreePath, Путь: %filePath%
        SB_SetText("✓ Загружен: " . genCurrentTemplate . " [" . genCurrentCategory . "/" . genCurrentSubcategory . "]", 1)
    }
return

GenTreeRefresh:
    LoadGenTextTree()
    SB_SetText("Дерево генератора обновлено", 1)
return

GenTreeExpand:
    TV_Modify(0, "Expand")
    SB_SetText("Дерево развёрнуто", 1)
return

GenTreeNewCategory:
    InputBox, catName, Новая категория, Введите название категории:, , 300, 130
    if (ErrorLevel || catName = "")
        return
    
    newPath := genTemplatesDir . "\" . catName
    if (FileExist(newPath)) {
        MsgBox, 48, Ошибка, Категория уже существует!
        return
    }
    
    FileCreateDir, %newPath%
    LoadGenTextTree()
    SB_SetText("Категория создана: " . catName, 1)
return

GenTreeNewSubcat:
    selectedItem := TV_GetSelection()
    if (!selectedItem) {
        MsgBox, 48, Ошибка, Выберите категорию!
        return
    }
    
    TV_GetText(parentText, selectedItem)
    
    InputBox, subcatName, Новая подкатегория, Введите название подкатегории:, , 300, 130
    if (ErrorLevel || subcatName = "")
        return
    
    newPath := genTemplatesDir . "\" . parentText . "\" . subcatName
    if (FileExist(newPath)) {
        MsgBox, 48, Ошибка, Подкатегория уже существует!
        return
    }
    
    FileCreateDir, %newPath%
    LoadGenTextTree()
    SB_SetText("Подкатегория создана: " . subcatName, 1)
return

GenTreeNewTemplate:
    selectedItem := TV_GetSelection()
    if (!selectedItem) {
        MsgBox, 48, Ошибка, Выберите категорию или подкатегорию!
        return
    }
    
    TV_GetText(parentText, selectedItem)
    parentItem := TV_GetParent(selectedItem)
    
    InputBox, templateName, Новый шаблон, Введите название шаблона:, , 300, 130
    if (ErrorLevel || templateName = "")
        return
    
    if (parentItem) {
        TV_GetText(grandParentText, parentItem)
        filePath := genTemplatesDir . "\" . grandParentText . "\" . parentText . "\" . templateName . ".txt"
    } else {
        filePath := genTemplatesDir . "\" . parentText . "\" . templateName . ".txt"
    }
    
    if (FileExist(filePath)) {
        MsgBox, 48, Ошибка, Шаблон уже существует!
        return
    }
    
    FileAppend, , %filePath%
    LoadGenTextTree()
    SB_SetText("Шаблон создан: " . templateName, 1)
return

; === ЗАГРУЗКА ВЫБРАННОГО ШАБЛОНА ДЛЯ ГЕНЕРАЦИИ ===
GenLoadSelectedTemplate:
    global genCurrentTemplate, genCurrentCategory, genCurrentSubcategory, genTemplatesDir
    
    Gui, 1:Default
    Gui, 1:TreeView, GenTextTree
    
    selectedItem := TV_GetSelection()
    if (!selectedItem) {
        MsgBox, 48, Ошибка, Выберите шаблон в дереве!
        return
    }
    
    TV_GetText(itemText, selectedItem)
    parentItem := TV_GetParent(selectedItem)
    
    if (!parentItem) {
        MsgBox, 48, Ошибка, Выберите шаблон, а не категорию!
        return
    }
    
    TV_GetText(parentText, parentItem)
    grandParentItem := TV_GetParent(parentItem)
    
    if (grandParentItem) {
        ; Это шаблон внутри подкатегории
        TV_GetText(grandParentText, grandParentItem)
        genCurrentCategory := grandParentText
        genCurrentSubcategory := parentText
        genCurrentTemplate := itemText
        filePath := genTemplatesDir . "\" . grandParentText . "\" . parentText . "\" . itemText . ".txt"
    } else {
        ; Проверяем, это шаблон или подкатегория
        testPath := genTemplatesDir . "\" . parentText . "\" . itemText . ".txt"
        if (FileExist(testPath)) {
            ; Это шаблон
            genCurrentCategory := parentText
            genCurrentSubcategory := ""
            genCurrentTemplate := itemText
            filePath := testPath
        } else {
            MsgBox, 48, Ошибка, Выберите шаблон, а не подкатегорию!
            return
        }
    }
    
    ; Загружаем содержимое
    if (FileExist(filePath)) {
        FileRead, content, %filePath%
        GuiControl,, GenTemplateContent, %content%
        GuiControl,, GenTreePath, Путь: %filePath%
        SB_SetText("✓ Шаблон загружен: " . genCurrentTemplate . " [" . genCurrentCategory . "/" . genCurrentSubcategory . "]", 1)
        MsgBox, 64, Успех, Шаблон загружен!`n`nКатегория: %genCurrentCategory%`nПодкатегория: %genCurrentSubcategory%`nШаблон: %genCurrentTemplate%`n`nТеперь можно использовать генерацию.
    } else {
        MsgBox, 48, Ошибка, Файл шаблона не найден:`n%filePath%
    }
return

GenTreeDelete:
    selectedItem := TV_GetSelection()
    if (!selectedItem) {
        MsgBox, 48, Ошибка, Выберите элемент для удаления!
        return
    }
    
    TV_GetText(itemText, selectedItem)
    
    MsgBox, 36, Подтверждение, Удалить "%itemText%"?
    IfMsgBox, No
        return
    
    parentItem := TV_GetParent(selectedItem)
    if (parentItem) {
        TV_GetText(parentText, parentItem)
        grandParentItem := TV_GetParent(parentItem)
        
        if (grandParentItem) {
            TV_GetText(grandParentText, grandParentItem)
            targetPath := genTemplatesDir . "\" . grandParentText . "\" . parentText . "\" . itemText . ".txt"
            FileDelete, %targetPath%
        } else {
            targetPath := genTemplatesDir . "\" . parentText . "\" . itemText
            if (InStr(FileExist(targetPath), "D")) {
                FileRemoveDir, %targetPath%, 1
            } else {
                FileDelete, %targetPath%.txt
            }
        }
    } else {
        targetPath := genTemplatesDir . "\" . itemText
        FileRemoveDir, %targetPath%, 1
    }
    
    LoadGenTextTree()
    SB_SetText("Удалено: " . itemText, 1)
return

GenTreeOpenFolder:
    Run, %genTemplatesDir%
return

GenContentEdit:
    selectedItem := TV_GetSelection()
    if (!selectedItem) {
        MsgBox, 48, Ошибка, Выберите шаблон для редактирования!
        return
    }
    
    ; Делаем поле редактируемым
    GuiControl, -ReadOnly, GenTemplateContent
    SB_SetText("Режим редактирования", 1)
return

GenContentCopy:
    Gui, 1:Submit, NoHide
    Clipboard := GenTemplateContent
    SB_SetText("Содержимое скопировано", 1)
return

GenContentClear:
    GuiControl,, GenTemplateContent,
    SB_SetText("Содержимое очищено", 1)
return

GenLoadIgnored:
    MsgBox, 64, Информация, Функция загрузки игнорируемых слов в разработке
return

; ============================================
; === ФУНКЦИИ ЗАГРУЗКИ TREEVIEW ===
; ============================================

LoadMainTextTree() {
    global MainTextTree, presetDir, treeItemData
    
    Gui, 1:Default
    Gui, 1:TreeView, MainTextTree
    TV_Delete()
    
    ; Очищаем хранилище данных
    treeItemData := {}
    
    ; Загружаем структуру папок
    Loop, Files, %presetDir%\*.*, D
    {
        categoryName := A_LoopFileName
        categoryItem := TV_Add(categoryName, 0, "Icon1")
        categoryPath := presetDir . "\" . categoryName
        
        ; Загружаем шаблоны в категории (файлы .txt)
        Loop, Files, %categoryPath%\*.txt
        {
            templateName := StrReplace(A_LoopFileName, ".txt", "")
            filePath := categoryPath . "\" . A_LoopFileName
            notesPath := categoryPath . "\" . templateName . ".notes"
            
            ; Проверяем наличие заметок
            displayName := templateName
            if (FileExist(notesPath)) {
                FileRead, notesContent, %notesPath%
                ; Берём первые 30 символов заметки для отображения
                notePreview := SubStr(notesContent, 1, 30)
                if (StrLen(notesContent) > 30)
                    notePreview .= "..."
                displayName := templateName . " 📝 " . notePreview
            }
            
            itemID := TV_Add(displayName, categoryItem, "Icon3")
            ; Сохраняем метаданные
            treeItemData[itemID] := {name: templateName, path: filePath, notesPath: notesPath}
        }
        
        ; Загружаем подкатегории
        Loop, Files, %categoryPath%\*.*, D
        {
            subcatName := A_LoopFileName
            subcatItem := TV_Add(subcatName, categoryItem, "Icon2")
            subcatPath := categoryPath . "\" . subcatName
            
            ; Загружаем шаблоны в подкатегории
            Loop, Files, %subcatPath%\*.txt
            {
                templateName := StrReplace(A_LoopFileName, ".txt", "")
                filePath := subcatPath . "\" . A_LoopFileName
                notesPath := subcatPath . "\" . templateName . ".notes"
                
                ; Проверяем наличие заметок
                displayName := templateName
                if (FileExist(notesPath)) {
                    FileRead, notesContent, %notesPath%
                    ; Берём первые 30 символов заметки для отображения
                    notePreview := SubStr(notesContent, 1, 30)
                    if (StrLen(notesContent) > 30)
                        notePreview .= "..."
                    displayName := templateName . " 📝 " . notePreview
                }
                
                itemID := TV_Add(displayName, subcatItem, "Icon3")
                ; Сохраняем метаданные
                treeItemData[itemID] := {name: templateName, path: filePath, notesPath: notesPath}
            }
        }
    }
}

LoadGenTextTree() {
    global GenTextTree, genTemplatesDir
    
    Gui, 1:Default
    Gui, 1:TreeView, GenTextTree
    TV_Delete()
    
    ; Загружаем структуру папок
    Loop, Files, %genTemplatesDir%\*.*, D
    {
        categoryName := A_LoopFileName
        categoryItem := TV_Add(categoryName, 0, "Icon1")
        categoryPath := genTemplatesDir . "\" . categoryName
        
        ; Загружаем шаблоны в категории (файлы .txt)
        Loop, Files, %categoryPath%\*.txt
        {
            templateName := StrReplace(A_LoopFileName, ".txt", "")
            TV_Add(templateName, categoryItem, "Icon3")
        }
        
        ; Загружаем подкатегории
        Loop, Files, %categoryPath%\*.*, D
        {
            subcatName := A_LoopFileName
            subcatItem := TV_Add(subcatName, categoryItem, "Icon2")
            subcatPath := categoryPath . "\" . subcatName
            
            ; Загружаем шаблоны в подкатегории
            Loop, Files, %subcatPath%\*.txt
            {
                templateName := StrReplace(A_LoopFileName, ".txt", "")
                TV_Add(templateName, subcatItem, "Icon3")
            }
        }
    }
}

CountWords(text) {
    words := StrSplit(text, [" ", "`n", "`r", "`t"])
    count := 0
    for index, word in words {
        if (word != "")
            count++
    }
    return count
}

CountLines(text) {
    lines := StrSplit(text, "`n")
    return lines.Length()
}

; ============================================
; === ОБРАБОТЧИКИ ОНЛАЙН-ШАБЛОНОВ ===
; ============================================

OnlineTemplateSelect:
    global OnlineTemplatesList, OnlineTemplateName, OnlineTemplateCategory, OnlineTemplateSize, OnlineTemplatePreview
    
    Gui, 1:Default
    Gui, ListView, OnlineTemplatesList
    
    if (A_GuiEvent != "DoubleClick" && A_GuiEvent != "Normal")
        return
    
    selectedRow := LV_GetNext()
    if (!selectedRow)
        return
    
    ; Получаем данные из выбранной строки
    LV_GetText(templateName, selectedRow, 1)
    LV_GetText(categoryName, selectedRow, 2)
    
    ; Обновляем глобальные переменные
    OnlineTemplateName := templateName
    OnlineTemplateCategory := categoryName
    
    ; Обновляем информацию о шаблоне в GUI
    GuiControl,, OnlineTemplateName, %templateName%
    GuiControl,, OnlineTemplateCategory, %categoryName%
    
    ; Загружаем превью
    GuiControl,, OnlineTemplateSize, Загрузка...
    GuiControl,, OnlineTemplatePreview, Загрузка превью шаблона...
    
    ; Загружаем реальное содержимое с GitHub
    Gosub, LoadOnlineTemplatePreview
return

RefreshOnlineTemplates:
    LoadOnlineTemplatesList()
    SB_SetText("Список онлайн-шаблонов обновлён", 1)
return

InstallSelectedTemplate:
    Gui, 1:Submit, NoHide
    
    if (OnlineTemplateName = "") {
        MsgBox, 48, Ошибка, Выберите шаблон для установки!
        return
    }
    
    ; Показываем меню выбора куда установить
    Menu, InstallMenu, Add, 📝 В Основной текст, InstallToMainText
    Menu, InstallMenu, Add, 🎲 В Генератор, InstallToGenerator
    Menu, InstallMenu, Add, 📦 В Слоты, InstallToSlots
    Menu, InstallMenu, Show
return

InstallToMainText:
    Gosub, DownloadToMainText
return

InstallToGenerator:
    Gosub, DownloadToGenerator
return

InstallToSlots:
    Gosub, DownloadToSlots
return

CheckForUpdates:
    MsgBox, 64, Проверка обновлений, Проверка обновлений онлайн-шаблонов...`n`nФункция в разработке.
    SB_SetText("Проверка обновлений завершена", 1)
return

OpenOnlineRepo:
    Run, https://github.com/IIo3uTuV4iK/templates
return

LoadOnlineTemplatePreview:
    global OnlineTemplateName, OnlineTemplateCategory, OnlineTemplatePreview
    Gui, 1:Submit, NoHide
    
    templateName := OnlineTemplateName
    categoryName := OnlineTemplateCategory
    
    ; Формируем URL для загрузки с GitHub
    repoURL := "https://raw.githubusercontent.com/IIo3uTuV4iK/templates/main/"
    fileURL := repoURL . categoryName . "/" . templateName . ".txt"
    
    ; Пытаемся загрузить содержимое
    try {
        ; Используем ComObjCreate для HTTP запроса
        http := ComObjCreate("WinHttp.WinHttpRequest.5.1")
        http.Open("GET", fileURL, false)
        http.Send()
        
        httpStatus := http.Status
        if (httpStatus = 200) {
            previewText := http.ResponseText
            fileSize := StrLen(previewText)
            
            ; Обновляем глобальную переменную
            OnlineTemplatePreview := previewText
            
            GuiControl,, OnlineTemplatePreview, %previewText%
            GuiControl,, OnlineTemplateSize, %fileSize% символов
            SB_SetText("Превью загружено: " . templateName, 1)
        } else {
            errorMsg := "Ошибка загрузки: HTTP " . httpStatus
            OnlineTemplatePreview := errorMsg
            GuiControl,, OnlineTemplatePreview, %errorMsg%
            GuiControl,, OnlineTemplateSize, Недоступно
            SB_SetText("Ошибка загрузки шаблона", 1)
        }
    } catch e {
        ; Если не удалось загрузить, показываем заглушку
        previewText := "Пример содержимого шаблона:`n`nПривет как дела`nСегодня хорошая погода`nЯ люблю программирование`n`n(Не удалось загрузить с GitHub)"
        OnlineTemplatePreview := previewText
        GuiControl,, OnlineTemplatePreview, %previewText%
        GuiControl,, OnlineTemplateSize, ~500 байт
        SB_SetText("Используется локальное превью", 1)
    }
return

DownloadToMainText:
    Gui, 1:Submit, NoHide
    
    if (OnlineTemplateName = "") {
        MsgBox, 48, Ошибка, Выберите шаблон для скачивания!
        return
    }
    
    ; Получаем содержимое из превью
    content := OnlineTemplatePreview
    
    ; Запрашиваем имя для сохранения
    InputBox, saveName, Сохранение шаблона, Введите имя для сохранения:, , 300, 130, , , , , %OnlineTemplateName%
    if (ErrorLevel || saveName = "")
        return
    
    ; Запрашиваем категорию
    InputBox, saveCategory, Выбор категории, Введите категорию (или оставьте пустым для корня):, , 300, 130, , , , , %OnlineTemplateCategory%
    if (ErrorLevel)
        return
    
    ; Сохраняем в основной текст
    if (saveCategory != "") {
        categoryPath := presetDir . "\" . saveCategory
        if (!FileExist(categoryPath))
            FileCreateDir, %categoryPath%
        filePath := categoryPath . "\" . saveName . ".txt"
    } else {
        filePath := presetDir . "\" . saveName . ".txt"
    }
    
    FileDelete, %filePath%
    FileAppend, %content%, %filePath%
    
    ; Обновляем TreeView основного текста если функция существует
    if (IsFunc("LoadMainTextTree"))
        LoadMainTextTree()
    
    MsgBox, 64, Успех, Шаблон "%saveName%" добавлен в основной текст!
    SB_SetText("Шаблон скачан: " . saveName, 1)
return

DownloadToGenerator:
    Gui, 1:Submit, NoHide
    
    if (OnlineTemplateName = "") {
        MsgBox, 48, Ошибка, Выберите шаблон для скачивания!
        return
    }
    
    content := OnlineTemplatePreview
    
    InputBox, saveName, Сохранение шаблона, Введите имя для сохранения:, , 300, 130, , , , , %OnlineTemplateName%
    if (ErrorLevel || saveName = "")
        return
    
    InputBox, saveCategory, Выбор категории, Введите категорию (или оставьте пустым для корня):, , 300, 130, , , , , %OnlineTemplateCategory%
    if (ErrorLevel)
        return
    
    if (saveCategory != "") {
        categoryPath := genTemplatesDir . "\" . saveCategory
        if (!FileExist(categoryPath))
            FileCreateDir, %categoryPath%
        filePath := categoryPath . "\" . saveName . ".txt"
    } else {
        filePath := genTemplatesDir . "\" . saveName . ".txt"
    }
    
    FileDelete, %filePath%
    FileAppend, %content%, %filePath%
    
    ; Обновляем TreeView генератора если функция существует
    if (IsFunc("LoadGenTextTree"))
        LoadGenTextTree()
    
    MsgBox, 64, Успех, Шаблон "%saveName%" добавлен в генератор!
    SB_SetText("Шаблон скачан: " . saveName, 1)
return

DownloadToSlots:
    Gui, 1:Submit, NoHide
    
    if (OnlineTemplateName = "") {
        MsgBox, 48, Ошибка, Выберите шаблон для скачивания!
        return
    }
    
    content := OnlineTemplatePreview
    
    ; Разбиваем на строки и добавляем в слоты
    global slots
    Loop, Parse, content, `n, `r
    {
        if (A_LoopField != "") {
            newSlot := {}
            newSlot.text := A_LoopField
            newSlot.delay := 0
            newSlot.delayUnit := "Секунды"
            newSlot.speed := 10
            slots.Push(newSlot)
        }
    }
    
    ; Обновляем ListView слотов
    if (IsFunc("UpdateSlotsList"))
        UpdateSlotsList()
    
    MsgBox, 64, Успех, Шаблон добавлен в слоты!
    SB_SetText("Шаблон добавлен в слоты", 1)
return

CopyOnlineTemplate:
    Gui, 1:Submit, NoHide
    Clipboard := OnlineTemplatePreview
    SB_SetText("Шаблон скопирован в буфер обмена", 1)
return

LoadOnlineTemplatesList() {
    global OnlineTemplatesList, OnlineTemplatesCount
    
    Gui, 1:Default
    Gui, ListView, OnlineTemplatesList
    
    GuiControl, -Redraw, OnlineTemplatesList
    LV_Delete()
    
    ; Загружаем список шаблонов с GitHub
    try {
        ; Пытаемся получить список файлов через GitHub API
        http := ComObjCreate("WinHttp.WinHttpRequest.5.1")
        apiURL := "https://api.github.com/repos/IIo3uTuV4iK/templates/contents"
        http.Open("GET", apiURL, false)
        http.SetRequestHeader("User-Agent", "AutoTyper")
        http.Send()
        
        httpStatus := http.Status
        if (httpStatus = 200) {
            ; Парсим JSON ответ (упрощенная версия)
            response := http.ResponseText
            
            ; Добавляем примеры (в реальной версии парсим JSON)
            LV_Add("", "Приветствия", "Общие")
            LV_Add("", "Прощания", "Общие")
            LV_Add("", "Благодарности", "Общие")
            LV_Add("", "Minecraft", "Игровые")
            LV_Add("", "Roblox", "Игровые")
            LV_Add("", "CS:GO", "Игровые")
            LV_Add("", "Копипасты", "Мемы")
            LV_Add("", "ASCII Art", "Мемы")
            LV_Add("", "Английский", "Обучение")
            LV_Add("", "Программирование", "Обучение")
            
            templateCount := LV_GetCount()
            GuiControl,, OnlineTemplatesCount, Доступно: %templateCount% шаблонов
            GuiControl,, OnlineStats, Доступно шаблонов: %templateCount%`nСкачано: 0`nПоследнее обновление: Сейчас`nСтатус: Подключено
            SB_SetText("Загружено шаблонов: " . templateCount, 1)
        }
    } catch e {
        ; Если не удалось подключиться, показываем примеры
        LV_Add("", "Приветствия", "Общие")
        LV_Add("", "Прощания", "Общие")
        LV_Add("", "Благодарности", "Общие")
        LV_Add("", "Minecraft", "Игровые")
        LV_Add("", "Roblox", "Игровые")
        
        templateCount := LV_GetCount()
        GuiControl,, OnlineTemplatesCount, Доступно: %templateCount% шаблонов (локально)
        GuiControl,, OnlineStats, Доступно шаблонов: %templateCount%`nСкачано: 0`nПоследнее обновление: Никогда`nСтатус: Офлайн режим
        SB_SetText("Используется локальный список", 1)
    }
    
    GuiControl, +Redraw, OnlineTemplatesList
    
    ; Обновляем время последней проверки
    FormatTime, currentTime, , dd.MM.yyyy HH:mm
    GuiControl,, OnlineLastCheck, Последняя проверка: %currentTime%
}

; ============================================
; === ОБРАБОТЧИКИ ЗАПИСИ С ТАЙМИНГАМИ ===
; ============================================

PauseRecording:
    global isRecording
    if (isRecording) {
        isRecording := false
        SetTimer, UpdateRecordTime, Off
        GuiControl,, RecordStatus, ⏸ Пауза
        SB_SetText("Запись на паузе", 1)
    }
return

ExportWithTiming:
    global recordedText, recordingKeyTimes, appDataDir
    
    if (recordedText = "") {
        MsgBox, 48, Ошибка, Нет записанного текста!
        return
    }
    
    FileSelectFile, exportFile, S16, %appDataDir%\records\recording_with_timing.json, Экспорт с таймингами, JSON файлы (*.json)
    if (exportFile = "")
        return
    
    ; Формируем JSON
    json := "{`n"
    json .= "  ""text"": """ . StrReplace(StrReplace(recordedText, "\", "\\"), """", "\""") . """,`n"
    json .= "  ""keyTimes"": [`n"
    
    for i, kt in recordingKeyTimes {
        json .= "    {""char"": """ . kt.char . """, ""delay"": " . kt.delay . "}"
        if (i < recordingKeyTimes.Length())
            json .= ","
        json .= "`n"
    }
    
    json .= "  ]`n"
    json .= "}"
    
    FileDelete, %exportFile%
    FileAppend, %json%, %exportFile%, UTF-8
    
    MsgBox, 64, Успех, Запись с таймингами экспортирована!
return

; ============================================
; === ОБНОВЛЕНИЕ СТАТИСТИКИ ОШИБОК ===
; ============================================

UpdateErrorStats() {
    global errorWordVariations
    
    wordCount := 0
    varCount := 0
    
    for word, variations in errorWordVariations {
        wordCount++
        if (IsObject(variations))
            varCount += variations.Length()
    }
    
    avg := wordCount > 0 ? Round(varCount / wordCount, 1) : 0
    
    GuiControl, ErrorSettings:, ErrorStatsText, Слов: %wordCount% | Вариаций: %varCount% | Среднее вариаций на слово: %avg%
}

ClearErrorWords:
    MsgBox, 36, Подтверждение, Удалить все слова и вариации?
    IfMsgBox, No
        return
    
    global errorWordVariations
    errorWordVariations := {}
    
    UpdateErrorWordsList()
    UpdateErrorStats()
return

AutoGenerateAll:
    global errorWordVariations
    
    if (errorWordVariations.Count() = 0) {
        MsgBox, 48, Ошибка, Сначала добавьте слова!
        return
    }
    
    InputBox, varCount, Авто-генерация, Сколько вариаций сгенерировать для каждого слова?, , 300, 150, , , , , 5
    if (ErrorLevel || varCount = "")
        return
    
    totalAdded := 0
    for word, variations in errorWordVariations {
        smartVars := GenerateSmartVariations(word, varCount)
        for i, v in smartVars {
            if (!Contains(errorWordVariations[word], v)) {
                errorWordVariations[word].Push(v)
                totalAdded++
            }
        }
    }
    
    UpdateErrorWordsList()
    UpdateErrorStats()
    MsgBox, 64, Готово, Добавлено %totalAdded% новых вариаций!
return

ResetErrorStats:
    MsgBox, 36, Подтверждение, Сбросить статистику ошибок?
    IfMsgBox, No
        return
    
    ; Очищаем статистику
    Gui, 1:Default
    Gui, 1:ListView, ErrorTypesList
    LV_Delete()
    
    ; Сбрасываем счетчики
    GuiControl,, ErrorStatsApplied, Применено: 0 раз
    GuiControl,, ErrorStatsCreated, Создано: 0
    GuiControl,, ErrorStatsSuccess, Успешно: 0 раз
    
    SB_SetText("Статистика ошибок сброшена", 1)
return

ExportErrorSettings:
    global errorWordVariations, appDataDir
    
    FileSelectFile, exportFile, S16, %appDataDir%\error_settings.txt, Экспорт настроек ошибок, Текстовые файлы (*.txt)
    if (exportFile = "")
        return
    
    content := ""
    for word, variations in errorWordVariations {
        content .= word . ":"
        for i, v in variations {
            content .= v
            if (i < variations.Length())
                content .= ","
        }
        content .= "`n"
    }
    
    FileDelete, %exportFile%
    FileAppend, %content%, %exportFile%, UTF-8
    
    MsgBox, 64, Успех, Настройки ошибок экспортированы!
return

; ============================================
; === ОБРАБОТЧИКИ ПРОФИЛЕЙ ОШИБОК ===
; ============================================

AddErrorProfile:
    InputBox, profileName, Новый профиль, Введите название профиля:, , 300, 150
    if (ErrorLevel || profileName = "")
        return
    
    Gui, 1:Default
    Gui, 1:TreeView, ErrorProfilesTree
    TV_Add(profileName, 0)
    
    SB_SetText("Профиль добавлен: " . profileName, 1)
return

DeleteErrorProfile:
    Gui, 1:Default
    Gui, 1:TreeView, ErrorProfilesTree
    selectedItem := TV_GetSelection()
    
    if (!selectedItem) {
        MsgBox, 48, Ошибка, Выберите профиль для удаления!
        return
    }
    
    TV_GetText(profileName, selectedItem)
    
    MsgBox, 36, Подтверждение, Удалить профиль "%profileName%"?
    IfMsgBox, No
        return
    
    TV_Delete(selectedItem)
    SB_SetText("Профиль удалён: " . profileName, 1)
return

SaveErrorProfile:
    Gui, 1:Default
    Gui, 1:TreeView, ErrorProfilesTree
    selectedItem := TV_GetSelection()
    
    if (!selectedItem) {
        MsgBox, 48, Ошибка, Выберите профиль для сохранения!
        return
    }
    
    TV_GetText(profileName, selectedItem)
    
    global errorRulesPresetsDir, errorWordVariations
    
    if (!FileExist(errorRulesPresetsDir))
        FileCreateDir, %errorRulesPresetsDir%
    
    profileFile := errorRulesPresetsDir . "\" . profileName . ".ini"
    
    ; Сохраняем настройки профиля
    IniWrite, %profileName%, %profileFile%, Profile, Name
    
    ; Сохраняем слова с вариациями
    wordCount := 0
    for word, variations in errorWordVariations {
        wordCount++
        section := "Word" . wordCount
        IniWrite, %word%, %profileFile%, %section%, Word
        
        varStr := ""
        for i, v in variations {
            varStr .= v
            if (i < variations.Length())
                varStr .= "|"
        }
        IniWrite, %varStr%, %profileFile%, %section%, Variations
    }
    
    IniWrite, %wordCount%, %profileFile%, Profile, WordCount
    
    MsgBox, 64, Успех, Профиль "%profileName%" сохранён!
    SB_SetText("Профиль сохранён: " . profileName, 1)
return

LoadErrorHistory:
    MsgBox, 64, История ошибок, Функция загрузки истории ошибок в разработке.
return

ClearErrorHistory:
    MsgBox, 36, Подтверждение, Очистить историю ошибок?
    IfMsgBox, No
        return
    
    SB_SetText("История ошибок очищена", 1)
return

; ============================================
; === ОБРАБОТЧИКИ ПРОФИЛЕЙ ПЕРЕМЕШИВАНИЯ ===
; ============================================

AddShuffleProfile:
    InputBox, profileName, Новый профиль, Введите название профиля перемешивания:, , 300, 150
    if (ErrorLevel || profileName = "")
        return
    
    Gui, 1:Default
    Gui, 1:TreeView, ShuffleProfilesTree
    TV_Add(profileName, 0)
    
    SB_SetText("Профиль перемешивания добавлен: " . profileName, 1)
return

DeleteShuffleProfile:
    Gui, 1:Default
    Gui, 1:TreeView, ShuffleProfilesTree
    selectedItem := TV_GetSelection()
    
    if (!selectedItem) {
        MsgBox, 48, Ошибка, Выберите профиль для удаления!
        return
    }
    
    TV_GetText(profileName, selectedItem)
    
    MsgBox, 36, Подтверждение, Удалить профиль перемешивания "%profileName%"?
    IfMsgBox, No
        return
    
    TV_Delete(selectedItem)
    SB_SetText("Профиль перемешивания удалён: " . profileName, 1)
return

SaveShuffleProfile:
    Gui, 1:Default
    Gui, 1:TreeView, ShuffleProfilesTree
    selectedItem := TV_GetSelection()
    
    if (!selectedItem) {
        MsgBox, 48, Ошибка, Выберите профиль для сохранения!
        return
    }
    
    TV_GetText(profileName, selectedItem)
    
    global appDataDir
    shufflePresetsDir := appDataDir . "\shuffle_presets"
    
    if (!FileExist(shufflePresetsDir))
        FileCreateDir, %shufflePresetsDir%
    
    profileFile := shufflePresetsDir . "\" . profileName . ".ini"
    
    ; Сохраняем настройки профиля перемешивания
    Gui, 1:Submit, NoHide
    
    IniWrite, %profileName%, %profileFile%, Profile, Name
    IniWrite, %TextShuffleLevel%, %profileFile%, Settings, ShuffleLevel
    IniWrite, %ShuffleRandomMode%, %profileFile%, Settings, RandomMode
    IniWrite, %ShuffleLowProb%, %profileFile%, Settings, LowProb
    IniWrite, %ShuffleMediumBehavior%, %profileFile%, Settings, MediumBehavior
    IniWrite, %ShuffleHighSuffixProb%, %profileFile%, Settings, HighSuffixProb
    IniWrite, %ShuffleHighSuffixCount%, %profileFile%, Settings, HighSuffixCount
    IniWrite, %ShuffleExtremeMode%, %profileFile%, Settings, ExtremeMode
    
    MsgBox, 64, Успех, Профиль перемешивания "%profileName%" сохранён!
    SB_SetText("Профиль перемешивания сохранён: " . profileName, 1)
return

LoadShuffleHistory:
    MsgBox, 64, История перемешивания, Функция загрузки истории перемешивания в разработке.
return

ClearShuffleHistory:
    MsgBox, 36, Подтверждение, Очистить историю перемешивания?
    IfMsgBox, No
        return
    
    SB_SetText("История перемешивания очищена", 1)
return

; ============================================
; === ОБРАБОТЧИКИ РАЗДЕЛИТЕЛЯ (SPLITTER) ===
; ============================================

; ============================================
; === ОБРАБОТЧИКИ КОНТЕКСТНОГО МЕНЮ ===
; ============================================

ContextSetLegitMode:
    GuiControl,, TypingMode, Legit-режим
    GuiControl,, LegitModeEnabled, 1
    global legitModeEnabled := true
    SB_SetText("Режим: Legit", 1)
return

ContextSetRageMode:
    GuiControl,, TypingMode, Rage-режим
    GuiControl,, RageModeEnabled, 1
    global rageModeEnabled := true
    SB_SetText("Режим: Rage", 1)
return

ContextSetNormalMode:
    GuiControl,, TypingMode, Обычный текст
    global legitModeEnabled := false
    global rageModeEnabled := false
    SB_SetText("Режим: Обычный текст", 1)
return

ContextSetGeneratorMode:
    GuiControl,, TypingMode, Генератор текста
    SB_SetText("Режим: Генератор текста", 1)
return

ContextStartTyping:
    Gosub, StartTyping
return

ContextStopTyping:
    Gosub, StopTyping
return

ContextPauseTyping:
    Gosub, PauseTyping
return

ContextEmergencyStopTyping:
    Gosub, EmergencyStopTyping
return

ContextResetSettings:
    MsgBox, 36, Подтверждение, Сбросить все настройки к значениям по умолчанию?
    IfMsgBox, No
        return
    
    ; Сброс основных настроек
    GuiControl,, SpeedInput, 50
    GuiControl,, RepeatInput, 1
    GuiControl,, ErrorGenLevel, 1
    GuiControl,, AutoEnterMode, 1
    GuiControl,, LegitModeEnabled, 0
    GuiControl,, RageModeEnabled, 0
    
    global legitModeEnabled := false
    global rageModeEnabled := false
    
    SB_SetText("Настройки сброшены", 1)
return

ContextOpenSettings:
    GuiControl, Choose, MainTabs, 13
    UpdateMenuHighlight("MenuSettings")
return


; ============================================
; === ЗАГРУЗКА/СОХРАНЕНИЕ ЦИКЛОВ ОГРАНИЧЕНИЯ ПЕЧАТИ ===
; ============================================

LoadPrintLimitCyclesOnStart:
    global printLimitCycles, appDataDir
    
    IniRead, savedPLC, %appDataDir%\AutoTyper.ini, PrintLimitCycles, Data
    if (savedPLC = "ERROR" || savedPLC = "" || savedPLC = "empty")
        return
    
    printLimitCycles := []
    items := StrSplit(savedPLC, "||")
    for i, item in items {
        item := Trim(item)
        if (item = "")
            continue
        parts := StrSplit(item, "|")
        if (parts.Length() >= 2) {
            t := parts[1]
            v := parts[2] + 0
            u := (parts.Length() >= 3) ? parts[3] : ""
            if (t = "words" || t = "lines" || t = "time") {
                printLimitCycles.Push({type: t, value: v, unit: u})
            }
        }
    }
    
    PrintLimitCycles_RebuildListView()
    UpdatePrintLimitCyclesInfo()
return

SavePrintLimitCyclesOnExit:
    global printLimitCycles, appDataDir
    
    if (!IsObject(printLimitCycles) || printLimitCycles.Length() = 0) {
        IniWrite, empty, %appDataDir%\AutoTyper.ini, PrintLimitCycles, Data
        return
    }
    
    dataStr := ""
    for i, item in printLimitCycles {
        t := item.type
        v := item.value + 0
        u := item.unit
        dataStr .= t . "|" . v
        if (t = "time")
            dataStr .= "|" . u
        dataStr .= "||"
    }
    
    IniWrite, %dataStr%, %appDataDir%\AutoTyper.ini, PrintLimitCycles, Data
return

; ============================================
; === ЗАГРУЗКА/СОХРАНЕНИЕ ЦИКЛОВ AUTO-ENTER ===
; ============================================

LoadAutoEnterCyclesOnStart:
    global autoEnterCycles, appDataDir
    
    IniRead, savedCycles, %appDataDir%\AutoTyper.ini, AutoEnterCycles, Data
    if (savedCycles = "ERROR" || savedCycles = "" || savedCycles = "empty")
        return
    
    autoEnterCycles := []
    items := StrSplit(savedCycles, "|")
    
    for i, item in items {
        if (item = "")
            continue
        autoEnterCycles.Push({words: item + 0, enabled: true})
        
        Gui, 1:Default
        Gui, 1:ListView, AutoEnterCyclesList
        LV_Add("", i, item . " слов", "Вкл")
    }
    
    UpdateAutoEnterCycleInfo()
return

SaveAutoEnterCyclesOnExit:
    global autoEnterCycles, appDataDir
    
    if (!autoEnterCycles || autoEnterCycles.Length() = 0) {
        IniWrite, empty, %appDataDir%\AutoTyper.ini, AutoEnterCycles, Data
        return
    }
    
    dataStr := ""
    for i, item in autoEnterCycles {
        dataStr .= item.words
        if (i < autoEnterCycles.Length())
            dataStr .= "|"
    }
    
    IniWrite, %dataStr%, %appDataDir%\AutoTyper.ini, AutoEnterCycles, Data
return

; ============================================
; === ЗАГРУЗКА/СОХРАНЕНИЕ БИНДОВ AUTO-ENTER ===
; ============================================

LoadAutoEnterBindsOnStart:
    global autoEnterBinds, appDataDir
    
    IniRead, savedBinds, %appDataDir%\AutoTyper.ini, AutoEnterBinds, Data
    if (savedBinds = "ERROR" || savedBinds = "" || savedBinds = "empty")
        return
    
    autoEnterBinds := []
    items := StrSplit(savedBinds, "||")
    
    for i, item in items {
        if (item = "")
            continue
        parts := StrSplit(item, "|")
        if (parts.Length() >= 2) {
            autoEnterBinds.Push({hotkey: parts[1], action: parts[2], enabled: true})
            
            Gui, 1:Default
            Gui, 1:ListView, AutoEnterBindsList
            LV_Add("", parts[1], parts[2], "Вкл")
            
            RegisterAutoEnterBind(autoEnterBinds.Length())
        }
    }
return

SaveAutoEnterBindsOnExit:
    global autoEnterBinds, appDataDir
    
    if (!autoEnterBinds || autoEnterBinds.Length() = 0) {
        IniWrite, empty, %appDataDir%\AutoTyper.ini, AutoEnterBinds, Data
        return
    }
    
    dataStr := ""
    for i, item in autoEnterBinds {
        dataStr .= item.hotkey . "|" . item.action . "||"
    }
    
    IniWrite, %dataStr%, %appDataDir%\AutoTyper.ini, AutoEnterBinds, Data
return

; === СОХРАНЕНИЕ И ЗАГРУЗКА ПРАВИЛ ВСТАВКИ ===

SaveInsertRulesOnExit:
    global insertRules, appDataDir
    
    ; Удаляем старые данные
    IniDelete, %appDataDir%\AutoTyper.ini, InsertRules
    
    if (!insertRules || insertRules.Length() = 0) {
        IniWrite, 0, %appDataDir%\AutoTyper.ini, InsertRules, Count
        return
    }
    
    ; Сохраняем количество правил
    ruleCount := insertRules.Length()
    IniWrite, %ruleCount%, %appDataDir%\AutoTyper.ini, InsertRules, Count
    
    ; Сохраняем каждое правило
    for i, rule in insertRules {
        section := "InsertRule" . i
        IniWrite, % rule.name, %appDataDir%\AutoTyper.ini, %section%, Name
        IniWrite, % rule.type, %appDataDir%\AutoTyper.ini, %section%, Type
        IniWrite, % rule.text, %appDataDir%\AutoTyper.ini, %section%, Text
        
        ; Заменяем пустые значения на маркер EMPTY
        param1Value := rule.param1 = "" ? "EMPTY" : rule.param1
        param2Value := rule.param2 = "" ? "EMPTY" : rule.param2
        
        IniWrite, %param1Value%, %appDataDir%\AutoTyper.ini, %section%, Param1
        IniWrite, %param2Value%, %appDataDir%\AutoTyper.ini, %section%, Param2
        IniWrite, % rule.param3, %appDataDir%\AutoTyper.ini, %section%, Param3
        IniWrite, % rule.enabled, %appDataDir%\AutoTyper.ini, %section%, Enabled
        IniWrite, % rule.probability, %appDataDir%\AutoTyper.ini, %section%, Probability
        IniWrite, % rule.applyErrors, %appDataDir%\AutoTyper.ini, %section%, ApplyErrors
    }
return

LoadInsertRulesOnStart:
    global insertRules, appDataDir
    
    IniRead, ruleCount, %appDataDir%\AutoTyper.ini, InsertRules, Count, 0
    
    if (ruleCount = 0)
        return
    
    insertRules := []
    
    Loop, %ruleCount% {
        section := "InsertRule" . A_Index
        IniRead, name, %appDataDir%\AutoTyper.ini, %section%, Name, Правило %A_Index%
        IniRead, type, %appDataDir%\AutoTyper.ini, %section%, Type, Вставка перед словом
        IniRead, text, %appDataDir%\AutoTyper.ini, %section%, Text,
        IniRead, param1, %appDataDir%\AutoTyper.ini, %section%, Param1, EMPTY
        IniRead, param2, %appDataDir%\AutoTyper.ini, %section%, Param2, EMPTY
        IniRead, param3, %appDataDir%\AutoTyper.ini, %section%, Param3, 0
        IniRead, enabled, %appDataDir%\AutoTyper.ini, %section%, Enabled, 1
        IniRead, probability, %appDataDir%\AutoTyper.ini, %section%, Probability, 100
        IniRead, applyErrors, %appDataDir%\AutoTyper.ini, %section%, ApplyErrors, 0
        
        ; Заменяем маркер EMPTY на пустую строку
        if (param1 = "EMPTY")
            param1 := ""
        if (param2 = "EMPTY")
            param2 := ""
        
        insertRules.Push({name: name, type: type, text: text, param1: param1, param2: param2, param3: param3, enabled: enabled, probability: probability, applyErrors: applyErrors})
    }
return

; Создать дефолтные пресеты правил вставки
CreateDefaultInsertRulesPresets:
    global insertRulesPresetsDir
    
    ; Пресет 1: Эмодзи и смайлики
    presetFile := insertRulesPresetsDir . "\Эмодзи и смайлики.ini"
    if (!FileExist(presetFile)) {
        IniWrite, 5, %presetFile%, Rules, Count
        IniWrite, Смайлик в начале, %presetFile%, Rule1, Name
        IniWrite, Вставка в начало текста, %presetFile%, Rule1, Type
        IniWrite, 😊, %presetFile%, Rule1, Text
        IniWrite, EMPTY, %presetFile%, Rule1, Param1
        IniWrite, EMPTY, %presetFile%, Rule1, Param2
        IniWrite, 0, %presetFile%, Rule1, Param3
        IniWrite, 1, %presetFile%, Rule1, Enabled
        IniWrite, 100, %presetFile%, Rule1, Probability
        IniWrite, 0, %presetFile%, Rule1, ApplyErrors
        
        IniWrite, Смайлик в конце, %presetFile%, Rule2, Name
        IniWrite, Вставка в конец текста, %presetFile%, Rule2, Type
        IniWrite, 😄, %presetFile%, Rule2, Text
        IniWrite, EMPTY, %presetFile%, Rule2, Param1
        IniWrite, EMPTY, %presetFile%, Rule2, Param2
        IniWrite, 0, %presetFile%, Rule2, Param3
        IniWrite, 1, %presetFile%, Rule2, Enabled
        IniWrite, 100, %presetFile%, Rule2, Probability
        IniWrite, 0, %presetFile%, Rule2, ApplyErrors
        
        IniWrite, Случайные эмодзи, %presetFile%, Rule3, Name
        IniWrite, Вставка случайно (N раз), %presetFile%, Rule3, Type
        IniWrite, 🎉, %presetFile%, Rule3, Text
        IniWrite, 3, %presetFile%, Rule3, Param1
        IniWrite, EMPTY, %presetFile%, Rule3, Param2
        IniWrite, 0, %presetFile%, Rule3, Param3
        IniWrite, 1, %presetFile%, Rule3, Enabled
        IniWrite, 50, %presetFile%, Rule3, Probability
        IniWrite, 0, %presetFile%, Rule3, ApplyErrors
        
        IniWrite, Сердечки после длинных слов, %presetFile%, Rule4, Name
        IniWrite, Вставка после длинных слов, %presetFile%, Rule4, Type
        IniWrite, ❤️, %presetFile%, Rule4, Text
        IniWrite, 8, %presetFile%, Rule4, Param1
        IniWrite, EMPTY, %presetFile%, Rule4, Param2
        IniWrite, 0, %presetFile%, Rule4, Param3
        IniWrite, 1, %presetFile%, Rule4, Enabled
        IniWrite, 30, %presetFile%, Rule4, Probability
        IniWrite, 0, %presetFile%, Rule4, ApplyErrors
        
        IniWrite, Огонь перед заглавными, %presetFile%, Rule5, Name
        IniWrite, Вставка перед заглавными словами, %presetFile%, Rule5, Type
        IniWrite, 🔥, %presetFile%, Rule5, Text
        IniWrite, EMPTY, %presetFile%, Rule5, Param1
        IniWrite, EMPTY, %presetFile%, Rule5, Param2
        IniWrite, 0, %presetFile%, Rule5, Param3
        IniWrite, 1, %presetFile%, Rule5, Enabled
        IniWrite, 40, %presetFile%, Rule5, Probability
        IniWrite, 0, %presetFile%, Rule5, ApplyErrors
    }
    
    ; Пресет 2: Знаки препинания
    presetFile := insertRulesPresetsDir . "\Знаки препинания.ini"
    if (!FileExist(presetFile)) {
        IniWrite, 4, %presetFile%, Rules, Count
        IniWrite, Многоточие после каждого 5-го слова, %presetFile%, Rule1, Name
        IniWrite, Вставка после каждого N-слова, %presetFile%, Rule1, Type
        IniWrite, ..., %presetFile%, Rule1, Text
        IniWrite, 5, %presetFile%, Rule1, Param1
        IniWrite, EMPTY, %presetFile%, Rule1, Param2
        IniWrite, 0, %presetFile%, Rule1, Param3
        IniWrite, 1, %presetFile%, Rule1, Enabled
        IniWrite, 100, %presetFile%, Rule1, Probability
        IniWrite, 0, %presetFile%, Rule1, ApplyErrors
        
        IniWrite, Восклицательный знак после длинных слов, %presetFile%, Rule2, Name
        IniWrite, Вставка после длинных слов, %presetFile%, Rule2, Type
        IniWrite, !, %presetFile%, Rule2, Text
        IniWrite, 10, %presetFile%, Rule2, Param1
        IniWrite, EMPTY, %presetFile%, Rule2, Param2
        IniWrite, 0, %presetFile%, Rule2, Param3
        IniWrite, 1, %presetFile%, Rule2, Enabled
        IniWrite, 50, %presetFile%, Rule2, Probability
        IniWrite, 0, %presetFile%, Rule2, ApplyErrors
        
        IniWrite, Вопросительный знак случайно, %presetFile%, Rule3, Name
        IniWrite, Вставка случайно (N раз), %presetFile%, Rule3, Type
        IniWrite, ?, %presetFile%, Rule3, Text
        IniWrite, 2, %presetFile%, Rule3, Param1
        IniWrite, EMPTY, %presetFile%, Rule3, Param2
        IniWrite, 0, %presetFile%, Rule3, Param3
        IniWrite, 1, %presetFile%, Rule3, Enabled
        IniWrite, 70, %presetFile%, Rule3, Probability
        IniWrite, 0, %presetFile%, Rule3, ApplyErrors
        
        IniWrite, Запятая через 3 слова, %presetFile%, Rule4, Name
        IniWrite, Вставка через N слов, %presetFile%, Rule4, Type
        IniWrite, `,, %presetFile%, Rule4, Text
        IniWrite, 3, %presetFile%, Rule4, Param1
        IniWrite, EMPTY, %presetFile%, Rule4, Param2
        IniWrite, 0, %presetFile%, Rule4, Param3
        IniWrite, 1, %presetFile%, Rule4, Enabled
        IniWrite, 60, %presetFile%, Rule4, Probability
        IniWrite, 0, %presetFile%, Rule4, ApplyErrors
    }
    
    ; Пресет 3: Усилители текста
    presetFile := insertRulesPresetsDir . "\Усилители текста.ini"
    if (!FileExist(presetFile)) {
        IniWrite, 5, %presetFile%, Rules, Count
        IniWrite, ОЧЕНЬ перед прилагательными, %presetFile%, Rule1, Name
        IniWrite, Вставка перед словами из списка, %presetFile%, Rule1, Type
        IniWrite, ОЧЕНЬ, %presetFile%, Rule1, Text
        IniWrite, хороший`,плохой`,красивый`,умный`,быстрый, %presetFile%, Rule1, Param1
        IniWrite, EMPTY, %presetFile%, Rule1, Param2
        IniWrite, 0, %presetFile%, Rule1, Param3
        IniWrite, 1, %presetFile%, Rule1, Enabled
        IniWrite, 80, %presetFile%, Rule1, Probability
        IniWrite, 0, %presetFile%, Rule1, ApplyErrors
        
        IniWrite, СУПЕР в начале, %presetFile%, Rule2, Name
        IniWrite, Вставка в начало текста, %presetFile%, Rule2, Type
        IniWrite, СУПЕР, %presetFile%, Rule2, Text
        IniWrite, EMPTY, %presetFile%, Rule2, Param1
        IniWrite, EMPTY, %presetFile%, Rule2, Param2
        IniWrite, 0, %presetFile%, Rule2, Param3
        IniWrite, 1, %presetFile%, Rule2, Enabled
        IniWrite, 100, %presetFile%, Rule2, Probability
        IniWrite, 0, %presetFile%, Rule2, ApplyErrors
        
        IniWrite, МЕГА перед заглавными, %presetFile%, Rule3, Name
        IniWrite, Вставка перед заглавными словами, %presetFile%, Rule3, Type
        IniWrite, МЕГА, %presetFile%, Rule3, Text
        IniWrite, EMPTY, %presetFile%, Rule3, Param1
        IniWrite, EMPTY, %presetFile%, Rule3, Param2
        IniWrite, 0, %presetFile%, Rule3, Param3
        IniWrite, 1, %presetFile%, Rule3, Enabled
        IniWrite, 50, %presetFile%, Rule3, Probability
        IniWrite, 0, %presetFile%, Rule3, ApplyErrors
        
        IniWrite, НЕВЕРОЯТНО случайно, %presetFile%, Rule4, Name
        IniWrite, Вставка случайно (N раз), %presetFile%, Rule4, Type
        IniWrite, НЕВЕРОЯТНО, %presetFile%, Rule4, Text
        IniWrite, 2, %presetFile%, Rule4, Param1
        IniWrite, EMPTY, %presetFile%, Rule4, Param2
        IniWrite, 0, %presetFile%, Rule4, Param3
        IniWrite, 1, %presetFile%, Rule4, Enabled
        IniWrite, 40, %presetFile%, Rule4, Probability
        IniWrite, 0, %presetFile%, Rule4, ApplyErrors
        
        IniWrite, АБСОЛЮТНО перед длинными словами, %presetFile%, Rule5, Name
        IniWrite, Вставка перед длинными словами, %presetFile%, Rule5, Type
        IniWrite, АБСОЛЮТНО, %presetFile%, Rule5, Text
        IniWrite, 9, %presetFile%, Rule5, Param1
        IniWrite, EMPTY, %presetFile%, Rule5, Param2
        IniWrite, 0, %presetFile%, Rule5, Param3
        IniWrite, 1, %presetFile%, Rule5, Enabled
        IniWrite, 30, %presetFile%, Rule5, Probability
        IniWrite, 0, %presetFile%, Rule5, ApplyErrors
    }
return
